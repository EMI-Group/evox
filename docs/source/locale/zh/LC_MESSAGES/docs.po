# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1980, Bill Huang
# This file is distributed under the same license as the EvoX package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: EvoX\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 1980-01-01 00:00+0000\n"
"PO-Revision-Date: 2024-01-31 08:31+0000\n"
"Last-Translator: BillHuang <bill.huang2001@gmail.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"evox/evox/zh_Hans/>\n"
"Language: zh\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 5.4-dev\n"
"Generated-By: Babel 2.14.0\n"

#: ../../source/api/algorithms/containers/cc.rst:3
#: ../../source/guide/advanced/4-container.md:28
msgid "Cooperative Coevolution"
msgstr "协同演化"

#: evox.algorithms.containers.coevolution.VectorizedCoevolution:2 of
msgid ""
"Automatically apply cooperative coevolution to any algorithm. The process"
" of cooperative coevolution is vectorized, meaning all sub-populations "
"will evolve at the same time in each generation."
msgstr "将协同演化自动应用于任何算法。协同演化的过程被向量化，意味着在每一代中，所有的子种群将同时进化。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.__init__
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.__init__
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell
#: evox.algorithms.containers.coevolution.Coevolution.__init__
#: evox.algorithms.containers.coevolution.Coevolution.setup
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.__init__
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup evox.algorithms.mo.bige.BiGE.setup
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup
#: evox.algorithms.mo.gde3.GDE3.setup evox.algorithms.mo.hype.HypE.setup
#: evox.algorithms.mo.ibea.IBEA.setup evox.algorithms.mo.knea.KnEA.setup
#: evox.algorithms.mo.lmocso.LMOCSO.setup evox.algorithms.mo.moead.MOEAD.setup
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup
#: evox.algorithms.mo.nsga2.NSGA2.setup evox.algorithms.mo.nsga3.NSGA3.setup
#: evox.algorithms.mo.rvea.RVEA.setup evox.algorithms.mo.spea2.SPEA2.setup
#: evox.algorithms.mo.sra.SRA.setup evox.algorithms.mo.tdea.TDEA.setup
#: evox.algorithms.so.de_variants.code.CoDE.setup
#: evox.algorithms.so.de_variants.de.DE.setup
#: evox.algorithms.so.de_variants.jade.JaDE.setup
#: evox.algorithms.so.de_variants.ode.ODE.setup
#: evox.algorithms.so.de_variants.sade.SaDE.setup
#: evox.algorithms.so.de_variants.shade.SHADE.setup
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup
#: evox.algorithms.so.es_variants.ars.ARS.__init__
#: evox.algorithms.so.es_variants.ars.ARS.setup
#: evox.algorithms.so.es_variants.asebo.ASEBO.__init__
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.__init__
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup
#: evox.algorithms.so.es_variants.des.DES.__init__
#: evox.algorithms.so.es_variants.des.DES.setup
#: evox.algorithms.so.es_variants.esmc.ESMC.__init__
#: evox.algorithms.so.es_variants.esmc.ESMC.setup
#: evox.algorithms.so.es_variants.guided_es.GuidedES.__init__
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup
#: evox.algorithms.so.es_variants.les.LES.__init__
#: evox.algorithms.so.es_variants.les.LES.setup
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup
#: evox.algorithms.so.es_variants.ma_es.MAES.setup
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup
#: evox.algorithms.so.es_variants.nes.XNES.setup
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.__init__
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup
#: evox.algorithms.so.es_variants.open_es.OpenES.setup
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.__init__
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup
#: evox.algorithms.so.es_variants.pgpe.PGPE.__init__
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup
#: evox.algorithms.so.es_variants.rmes.RMES.setup
#: evox.algorithms.so.es_variants.snes.SNES.__init__
#: evox.algorithms.so.es_variants.snes.SNES.setup
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup
#: evox.algorithms.so.pso_variants.cpso_s.CPSOS.__init__
#: evox.algorithms.so.pso_variants.cso.CSO.setup
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup
#: evox.algorithms.so.pso_variants.fips.FIPS.__init__
#: evox.algorithms.so.pso_variants.fips.FIPS.ask
#: evox.algorithms.so.pso_variants.fips.FIPS.setup
#: evox.algorithms.so.pso_variants.fips.FIPS.tell
#: evox.algorithms.so.pso_variants.pso.PSO.setup
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.__init__
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell
#: evox.core.algorithm.Algorithm.ask evox.core.algorithm.Algorithm.init_ask
#: evox.core.algorithm.Algorithm.init_tell evox.core.algorithm.Algorithm.tell
#: evox.core.module.Stateful.init evox.core.module.Stateful.setup
#: evox.core.problem.Problem.evaluate evox.core.state.State.__init__
#: evox.core.state.State.find_path_to evox.core.state.State.update
#: evox.metrics.hypervolume.HV.__init__ evox.monitors.eval_monitor.EvalMonitor
#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__
#: evox.monitors.pop_monitor.PopMonitor
#: evox.monitors.std_mo_monitor.StdMOMonitor
#: evox.monitors.std_so_monitor.StdSOMonitor
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.__init__
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.__init__
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup
#: evox.problems.numerical.lsmop.LSMOP1.__init__
#: evox.problems.numerical.lsmop.LSMOP2.__init__
#: evox.problems.numerical.lsmop.LSMOP3.__init__
#: evox.problems.numerical.lsmop.LSMOP4.__init__
#: evox.problems.numerical.lsmop.LSMOP5.__init__
#: evox.problems.numerical.lsmop.LSMOP6.__init__
#: evox.problems.numerical.lsmop.LSMOP7.__init__
#: evox.problems.numerical.lsmop.LSMOP8.__init__
#: evox.problems.numerical.lsmop.LSMOP9.__init__
#: evox.workflows.distributed.RayDistributedWorkflow.__init__
#: evox.workflows.distributed.RayDistributedWorkflow.setup
#: evox.workflows.non_jit_workflow.NonJitWorkflow.__init__
#: evox.workflows.non_jit_workflow.NonJitWorkflow.setup
#: evox.workflows.std_workflow.StdWorkflow.__init__
#: evox.workflows.std_workflow.StdWorkflow.enable_distributed
#: evox.workflows.std_workflow.StdWorkflow.enable_multi_devices
#: evox.workflows.std_workflow.StdWorkflow.setup of
msgid "Parameters"
msgstr "参数"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:2
#: evox.core.algorithm.Algorithm.init_ask:2 of
msgid "Ask the algorithm for the initial population"
msgstr "向算法获取初始化种群"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:4
#: evox.core.algorithm.Algorithm.init_ask:4 of
msgid ""
"Override this method if you need to initialize the population in a "
"special way. For example, Genetic Algorithm needs to evaluate the fitness"
" of the initial population of size N, but after that, it only need to "
"evaluate the fitness of the offspring of size M, and N != M. Since JAX "
"requires the function return to have static shape, we need to have two "
"different functions, one is the normal `ask` and another is `init_ask`."
msgstr ""
"如果您需要以特殊的方式初始化种群，请重写此方法。例如，遗传算法需要评估大小为 N 的初始种群的适应度，但在那之后，它只需要评估大小为 M "
"的后代的适应度，并且 N != M。由于 JAX 要求函数返回具有静态形状，因此我们需要有两个不同的函数，一个是常规的 `ask`，另一个是 "
"`init_ask`。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:9
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:13
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:9
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:9
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:9
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:9
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:9
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:9
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:9
#: evox.core.algorithm.Algorithm.ask:9
#: evox.core.algorithm.Algorithm.init_ask:13
#: evox.core.algorithm.Algorithm.init_tell:9
#: evox.core.algorithm.Algorithm.tell:9 evox.core.problem.Problem.evaluate:8
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:8
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:9
#: evox.workflows.std_workflow.StdWorkflow.enable_distributed:11
#: evox.workflows.std_workflow.StdWorkflow.enable_multi_devices:8 of
msgid "**state**"
msgstr "**状态**"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:13
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:9
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:9
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:9
#: evox.core.algorithm.Algorithm.ask:9
#: evox.core.algorithm.Algorithm.init_ask:13 of
msgid "The state of this algorithm."
msgstr "这个算法的状态。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell
#: evox.algorithms.containers.coevolution.Coevolution.setup
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup evox.algorithms.mo.bige.BiGE.setup
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup
#: evox.algorithms.mo.gde3.GDE3.setup evox.algorithms.mo.hype.HypE.setup
#: evox.algorithms.mo.ibea.IBEA.setup evox.algorithms.mo.knea.KnEA.setup
#: evox.algorithms.mo.lmocso.LMOCSO.setup evox.algorithms.mo.moead.MOEAD.setup
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup
#: evox.algorithms.mo.nsga2.NSGA2.setup evox.algorithms.mo.nsga3.NSGA3.setup
#: evox.algorithms.mo.rvea.RVEA.setup evox.algorithms.mo.spea2.SPEA2.setup
#: evox.algorithms.mo.sra.SRA.setup evox.algorithms.mo.tdea.TDEA.setup
#: evox.algorithms.so.de_variants.code.CoDE.setup
#: evox.algorithms.so.de_variants.de.DE.setup
#: evox.algorithms.so.de_variants.jade.JaDE.setup
#: evox.algorithms.so.de_variants.ode.ODE.setup
#: evox.algorithms.so.de_variants.sade.SaDE.setup
#: evox.algorithms.so.de_variants.shade.SHADE.setup
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup
#: evox.algorithms.so.es_variants.ars.ARS.setup
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup
#: evox.algorithms.so.es_variants.des.DES.setup
#: evox.algorithms.so.es_variants.esmc.ESMC.setup
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup
#: evox.algorithms.so.es_variants.les.LES.setup
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup
#: evox.algorithms.so.es_variants.ma_es.MAES.setup
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup
#: evox.algorithms.so.es_variants.nes.XNES.setup
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup
#: evox.algorithms.so.es_variants.open_es.OpenES.setup
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup
#: evox.algorithms.so.es_variants.rmes.RMES.setup
#: evox.algorithms.so.es_variants.snes.SNES.setup
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup
#: evox.algorithms.so.pso_variants.cso.CSO.setup
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup
#: evox.algorithms.so.pso_variants.fips.FIPS.ask
#: evox.algorithms.so.pso_variants.fips.FIPS.setup
#: evox.algorithms.so.pso_variants.fips.FIPS.tell
#: evox.algorithms.so.pso_variants.pso.PSO.setup
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell
#: evox.core.algorithm.Algorithm.ask evox.core.algorithm.Algorithm.init_ask
#: evox.core.algorithm.Algorithm.init_tell evox.core.algorithm.Algorithm.tell
#: evox.core.module.Stateful.init evox.core.module.Stateful.setup
#: evox.core.problem.Problem.evaluate
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup
#: evox.workflows.distributed.RayDistributedWorkflow.setup
#: evox.workflows.non_jit_workflow.NonJitWorkflow.setup
#: evox.workflows.std_workflow.StdWorkflow.enable_distributed
#: evox.workflows.std_workflow.StdWorkflow.enable_multi_devices
#: evox.workflows.std_workflow.StdWorkflow.setup of
msgid "Returns"
msgstr "返回值"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:14
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:14
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:18
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:14
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:14
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:14
#: evox.core.algorithm.Algorithm.ask:14
#: evox.core.algorithm.Algorithm.init_ask:18 of
msgid "population"
msgstr "种群"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:14
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:14
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:18
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:14
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:14
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:14
#: evox.core.algorithm.Algorithm.ask:14
#: evox.core.algorithm.Algorithm.init_ask:18 of
msgid "The candidate solution."
msgstr "候选解。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:29
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:29
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:29
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:33
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:29
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:29
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:29
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:29
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:29
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:29
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:29
#: evox.core.algorithm.Algorithm.ask:29
#: evox.core.algorithm.Algorithm.init_ask:33
#: evox.core.algorithm.Algorithm.init_tell:26
#: evox.core.algorithm.Algorithm.tell:29 of
msgid "state"
msgstr "状态"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:17
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:17
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:21
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:17
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:17
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:17
#: evox.core.algorithm.Algorithm.ask:17
#: evox.core.algorithm.Algorithm.init_ask:21
#: evox.core.problem.Problem.evaluate:16
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:16 of
msgid "The new state of the algorithm."
msgstr "算法的新的状态。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup
#: evox.algorithms.containers.coevolution.Coevolution.setup
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup
#: evox.core.algorithm.Algorithm.ask evox.core.algorithm.Algorithm.init_ask
#: evox.core.algorithm.Algorithm.init_tell evox.core.algorithm.Algorithm.tell
#: evox.core.module.Stateful.__init__ evox.core.module.Stateful.init
#: evox.core.module.Stateful.setup evox.core.problem.Problem.evaluate
#: evox.core.state.State.__init__ evox.core.state.State.find_path_to
#: evox.core.state.State.update
#: evox.workflows.std_workflow.StdWorkflow.enable_multi_devices of
msgid "Return type"
msgstr "返回值类型"

#: evox.core.algorithm.Algorithm.init_tell:2 of
msgid ""
"Tell the algorithm the fitness of the initial population Use in pair with"
" `init_ask`."
msgstr "告诉算法初始种群的适应度并应该与`init_ask`函数配对使用。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:9
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:9
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:9
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:9
#: evox.core.algorithm.Algorithm.init_tell:9
#: evox.core.algorithm.Algorithm.tell:9 of
msgid "The state of this algorithm"
msgstr "算法的状态"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:17
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:17
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:17
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:17
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:17
#: evox.core.algorithm.Algorithm.init_tell:14
#: evox.core.algorithm.Algorithm.tell:17 of
msgid "The new state of the algorithm"
msgstr "算法的新状态"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:2
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:2
#: evox.algorithms.containers.coevolution.Coevolution.setup:2
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup:2
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup:2
#: evox.algorithms.mo.bige.BiGE.setup:2
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup:2
#: evox.algorithms.mo.gde3.GDE3.setup:2 evox.algorithms.mo.hype.HypE.setup:2
#: evox.algorithms.mo.ibea.IBEA.setup:2 evox.algorithms.mo.knea.KnEA.setup:2
#: evox.algorithms.mo.lmocso.LMOCSO.setup:2
#: evox.algorithms.mo.moead.MOEAD.setup:2
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup:2
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup:2
#: evox.algorithms.mo.nsga2.NSGA2.setup:2
#: evox.algorithms.mo.nsga3.NSGA3.setup:2 evox.algorithms.mo.rvea.RVEA.setup:2
#: evox.algorithms.mo.spea2.SPEA2.setup:2 evox.algorithms.mo.sra.SRA.setup:2
#: evox.algorithms.mo.tdea.TDEA.setup:2
#: evox.algorithms.so.de_variants.code.CoDE.setup:2
#: evox.algorithms.so.de_variants.de.DE.setup:2
#: evox.algorithms.so.de_variants.jade.JaDE.setup:2
#: evox.algorithms.so.de_variants.ode.ODE.setup:2
#: evox.algorithms.so.de_variants.sade.SaDE.setup:2
#: evox.algorithms.so.de_variants.shade.SHADE.setup:2
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup:2
#: evox.algorithms.so.es_variants.ars.ARS.setup:2
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:2
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup:2
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup:2
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup:2
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup:2
#: evox.algorithms.so.es_variants.des.DES.setup:2
#: evox.algorithms.so.es_variants.esmc.ESMC.setup:2
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup:2
#: evox.algorithms.so.es_variants.les.LES.setup:2
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup:2
#: evox.algorithms.so.es_variants.ma_es.MAES.setup:2
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup:2
#: evox.algorithms.so.es_variants.nes.XNES.setup:2
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup:2
#: evox.algorithms.so.es_variants.open_es.OpenES.setup:2
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup:2
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup:2
#: evox.algorithms.so.es_variants.rmes.RMES.setup:2
#: evox.algorithms.so.es_variants.snes.SNES.setup:2
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup:2
#: evox.algorithms.so.pso_variants.cso.CSO.setup:2
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup:2
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:2
#: evox.algorithms.so.pso_variants.pso.PSO.setup:2
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup:2
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup:2
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:2
#: evox.core.module.Stateful.setup:2
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:2
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup:2
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:2
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup:2
#: evox.workflows.distributed.RayDistributedWorkflow.setup:2
#: evox.workflows.non_jit_workflow.NonJitWorkflow.setup:2
#: evox.workflows.std_workflow.StdWorkflow.setup:2 of
msgid "Setup mutable state here"
msgstr "在这里设置可变状态"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:4
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:4
#: evox.algorithms.containers.coevolution.Coevolution.setup:4
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup:4
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup:4
#: evox.algorithms.mo.bige.BiGE.setup:4
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup:4
#: evox.algorithms.mo.gde3.GDE3.setup:4 evox.algorithms.mo.hype.HypE.setup:4
#: evox.algorithms.mo.ibea.IBEA.setup:4 evox.algorithms.mo.knea.KnEA.setup:4
#: evox.algorithms.mo.lmocso.LMOCSO.setup:4
#: evox.algorithms.mo.moead.MOEAD.setup:4
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup:4
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup:4
#: evox.algorithms.mo.nsga2.NSGA2.setup:4
#: evox.algorithms.mo.nsga3.NSGA3.setup:4 evox.algorithms.mo.rvea.RVEA.setup:4
#: evox.algorithms.mo.spea2.SPEA2.setup:4 evox.algorithms.mo.sra.SRA.setup:4
#: evox.algorithms.mo.tdea.TDEA.setup:4
#: evox.algorithms.so.de_variants.code.CoDE.setup:4
#: evox.algorithms.so.de_variants.de.DE.setup:4
#: evox.algorithms.so.de_variants.jade.JaDE.setup:4
#: evox.algorithms.so.de_variants.ode.ODE.setup:4
#: evox.algorithms.so.de_variants.sade.SaDE.setup:4
#: evox.algorithms.so.de_variants.shade.SHADE.setup:4
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup:4
#: evox.algorithms.so.es_variants.ars.ARS.setup:4
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:4
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup:4
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup:4
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup:4
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup:4
#: evox.algorithms.so.es_variants.des.DES.setup:4
#: evox.algorithms.so.es_variants.esmc.ESMC.setup:4
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup:4
#: evox.algorithms.so.es_variants.les.LES.setup:4
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup:4
#: evox.algorithms.so.es_variants.ma_es.MAES.setup:4
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup:4
#: evox.algorithms.so.es_variants.nes.XNES.setup:4
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup:4
#: evox.algorithms.so.es_variants.open_es.OpenES.setup:4
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup:4
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup:4
#: evox.algorithms.so.es_variants.rmes.RMES.setup:4
#: evox.algorithms.so.es_variants.snes.SNES.setup:4
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup:4
#: evox.algorithms.so.pso_variants.cso.CSO.setup:4
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup:4
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:4
#: evox.algorithms.so.pso_variants.pso.PSO.setup:4
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup:4
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup:4
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:4
#: evox.core.module.Stateful.setup:4
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:4
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup:4
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:4
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup:4
#: evox.workflows.distributed.RayDistributedWorkflow.setup:4
#: evox.workflows.non_jit_workflow.NonJitWorkflow.setup:4
#: evox.workflows.std_workflow.StdWorkflow.setup:4 of
msgid ""
"The state it self is immutable, but it act as a mutable state by "
"returning new state each time."
msgstr "状态本身是不可变的，但是你可以通过生成一个新的状态来实现修改的操作。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:10
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:10
#: evox.algorithms.containers.coevolution.Coevolution.setup:10
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup:10
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup:10
#: evox.algorithms.mo.bige.BiGE.setup:10
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup:10
#: evox.algorithms.mo.gde3.GDE3.setup:10 evox.algorithms.mo.hype.HypE.setup:10
#: evox.algorithms.mo.ibea.IBEA.setup:10 evox.algorithms.mo.knea.KnEA.setup:10
#: evox.algorithms.mo.lmocso.LMOCSO.setup:10
#: evox.algorithms.mo.moead.MOEAD.setup:10
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup:10
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup:10
#: evox.algorithms.mo.nsga2.NSGA2.setup:10
#: evox.algorithms.mo.nsga3.NSGA3.setup:10
#: evox.algorithms.mo.rvea.RVEA.setup:10
#: evox.algorithms.mo.spea2.SPEA2.setup:10 evox.algorithms.mo.sra.SRA.setup:10
#: evox.algorithms.mo.tdea.TDEA.setup:10
#: evox.algorithms.so.de_variants.code.CoDE.setup:10
#: evox.algorithms.so.de_variants.de.DE.setup:10
#: evox.algorithms.so.de_variants.jade.JaDE.setup:10
#: evox.algorithms.so.de_variants.ode.ODE.setup:10
#: evox.algorithms.so.de_variants.sade.SaDE.setup:10
#: evox.algorithms.so.de_variants.shade.SHADE.setup:10
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup:10
#: evox.algorithms.so.es_variants.ars.ARS.setup:10
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:10
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup:10
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup:10
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup:10
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup:10
#: evox.algorithms.so.es_variants.des.DES.setup:10
#: evox.algorithms.so.es_variants.esmc.ESMC.setup:10
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup:10
#: evox.algorithms.so.es_variants.les.LES.setup:10
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup:10
#: evox.algorithms.so.es_variants.ma_es.MAES.setup:10
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup:10
#: evox.algorithms.so.es_variants.nes.XNES.setup:10
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup:10
#: evox.algorithms.so.es_variants.open_es.OpenES.setup:10
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup:10
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup:10
#: evox.algorithms.so.es_variants.rmes.RMES.setup:10
#: evox.algorithms.so.es_variants.snes.SNES.setup:10
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup:10
#: evox.algorithms.so.pso_variants.cso.CSO.setup:10
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup:10
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:10
#: evox.algorithms.so.pso_variants.pso.PSO.setup:10
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup:10
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup:10
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:10
#: evox.core.module.Stateful.init:9 evox.core.module.Stateful.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:12
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup:10
#: evox.workflows.distributed.RayDistributedWorkflow.setup:10
#: evox.workflows.non_jit_workflow.NonJitWorkflow.setup:10
#: evox.workflows.std_workflow.StdWorkflow.setup:10 of
msgid "**key**"
msgstr "**随机数生成器密钥**"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:10
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:10
#: evox.algorithms.containers.coevolution.Coevolution.setup:10
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup:10
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup:10
#: evox.algorithms.mo.bige.BiGE.setup:10
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup:10
#: evox.algorithms.mo.gde3.GDE3.setup:10 evox.algorithms.mo.hype.HypE.setup:10
#: evox.algorithms.mo.ibea.IBEA.setup:10 evox.algorithms.mo.knea.KnEA.setup:10
#: evox.algorithms.mo.lmocso.LMOCSO.setup:10
#: evox.algorithms.mo.moead.MOEAD.setup:10
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup:10
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup:10
#: evox.algorithms.mo.nsga2.NSGA2.setup:10
#: evox.algorithms.mo.nsga3.NSGA3.setup:10
#: evox.algorithms.mo.rvea.RVEA.setup:10
#: evox.algorithms.mo.spea2.SPEA2.setup:10 evox.algorithms.mo.sra.SRA.setup:10
#: evox.algorithms.mo.tdea.TDEA.setup:10
#: evox.algorithms.so.de_variants.code.CoDE.setup:10
#: evox.algorithms.so.de_variants.de.DE.setup:10
#: evox.algorithms.so.de_variants.jade.JaDE.setup:10
#: evox.algorithms.so.de_variants.ode.ODE.setup:10
#: evox.algorithms.so.de_variants.sade.SaDE.setup:10
#: evox.algorithms.so.de_variants.shade.SHADE.setup:10
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup:10
#: evox.algorithms.so.es_variants.ars.ARS.setup:10
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:10
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup:10
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup:10
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup:10
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup:10
#: evox.algorithms.so.es_variants.des.DES.setup:10
#: evox.algorithms.so.es_variants.esmc.ESMC.setup:10
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup:10
#: evox.algorithms.so.es_variants.les.LES.setup:10
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup:10
#: evox.algorithms.so.es_variants.ma_es.MAES.setup:10
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup:10
#: evox.algorithms.so.es_variants.nes.XNES.setup:10
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup:10
#: evox.algorithms.so.es_variants.open_es.OpenES.setup:10
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup:10
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup:10
#: evox.algorithms.so.es_variants.rmes.RMES.setup:10
#: evox.algorithms.so.es_variants.snes.SNES.setup:10
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup:10
#: evox.algorithms.so.pso_variants.cso.CSO.setup:10
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup:10
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:10
#: evox.algorithms.so.pso_variants.pso.PSO.setup:10
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup:10
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup:10
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:10
#: evox.core.module.Stateful.init:9 evox.core.module.Stateful.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:10
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup:10
#: evox.workflows.distributed.RayDistributedWorkflow.setup:10
#: evox.workflows.non_jit_workflow.NonJitWorkflow.setup:10
#: evox.workflows.std_workflow.StdWorkflow.setup:10 of
msgid "A PRNGKey."
msgstr "一个伪随机数生成器密钥。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:27
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:26
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:27
#: evox.algorithms.containers.coevolution.Coevolution.setup:27
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup:27
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup:27
#: evox.algorithms.mo.bige.BiGE.setup:27
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup:27
#: evox.algorithms.mo.gde3.GDE3.setup:27 evox.algorithms.mo.hype.HypE.setup:27
#: evox.algorithms.mo.ibea.IBEA.setup:27 evox.algorithms.mo.knea.KnEA.setup:27
#: evox.algorithms.mo.lmocso.LMOCSO.setup:27
#: evox.algorithms.mo.moead.MOEAD.setup:27
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup:27
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup:27
#: evox.algorithms.mo.nsga2.NSGA2.setup:27
#: evox.algorithms.mo.nsga3.NSGA3.setup:27
#: evox.algorithms.mo.rvea.RVEA.setup:27
#: evox.algorithms.mo.spea2.SPEA2.setup:27 evox.algorithms.mo.sra.SRA.setup:27
#: evox.algorithms.mo.tdea.TDEA.setup:27
#: evox.algorithms.so.de_variants.code.CoDE.setup:27
#: evox.algorithms.so.de_variants.de.DE.setup:27
#: evox.algorithms.so.de_variants.jade.JaDE.setup:27
#: evox.algorithms.so.de_variants.ode.ODE.setup:27
#: evox.algorithms.so.de_variants.sade.SaDE.setup:27
#: evox.algorithms.so.de_variants.shade.SHADE.setup:27
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup:27
#: evox.algorithms.so.es_variants.ars.ARS.setup:27
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:27
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup:27
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup:27
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup:27
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup:27
#: evox.algorithms.so.es_variants.des.DES.setup:27
#: evox.algorithms.so.es_variants.esmc.ESMC.setup:27
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup:27
#: evox.algorithms.so.es_variants.les.LES.setup:27
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup:27
#: evox.algorithms.so.es_variants.ma_es.MAES.setup:27
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup:27
#: evox.algorithms.so.es_variants.nes.XNES.setup:27
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup:27
#: evox.algorithms.so.es_variants.open_es.OpenES.setup:27
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup:27
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup:27
#: evox.algorithms.so.es_variants.rmes.RMES.setup:27
#: evox.algorithms.so.es_variants.snes.SNES.setup:27
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup:27
#: evox.algorithms.so.pso_variants.cso.CSO.setup:27
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup:27
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:27
#: evox.algorithms.so.pso_variants.pso.PSO.setup:27
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup:27
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup:27
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:27
#: evox.core.module.Stateful.init:26 evox.core.module.Stateful.setup:27
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:27
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup:27
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:27
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup:27
#: evox.workflows.distributed.RayDistributedWorkflow.setup:27
#: evox.workflows.non_jit_workflow.NonJitWorkflow.setup:27
#: evox.workflows.std_workflow.StdWorkflow.enable_distributed:28
#: evox.workflows.std_workflow.StdWorkflow.enable_multi_devices:29
#: evox.workflows.std_workflow.StdWorkflow.setup:27 of
msgid "State"
msgstr "状态"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:15
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:15
#: evox.algorithms.containers.coevolution.Coevolution.setup:15
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup:15
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup:15
#: evox.algorithms.mo.bige.BiGE.setup:15
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup:15
#: evox.algorithms.mo.gde3.GDE3.setup:15 evox.algorithms.mo.hype.HypE.setup:15
#: evox.algorithms.mo.ibea.IBEA.setup:15 evox.algorithms.mo.knea.KnEA.setup:15
#: evox.algorithms.mo.lmocso.LMOCSO.setup:15
#: evox.algorithms.mo.moead.MOEAD.setup:15
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup:15
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup:15
#: evox.algorithms.mo.nsga2.NSGA2.setup:15
#: evox.algorithms.mo.nsga3.NSGA3.setup:15
#: evox.algorithms.mo.rvea.RVEA.setup:15
#: evox.algorithms.mo.spea2.SPEA2.setup:15 evox.algorithms.mo.sra.SRA.setup:15
#: evox.algorithms.mo.tdea.TDEA.setup:15
#: evox.algorithms.so.de_variants.code.CoDE.setup:15
#: evox.algorithms.so.de_variants.de.DE.setup:15
#: evox.algorithms.so.de_variants.jade.JaDE.setup:15
#: evox.algorithms.so.de_variants.ode.ODE.setup:15
#: evox.algorithms.so.de_variants.sade.SaDE.setup:15
#: evox.algorithms.so.de_variants.shade.SHADE.setup:15
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup:15
#: evox.algorithms.so.es_variants.ars.ARS.setup:15
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:15
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup:15
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup:15
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup:15
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup:15
#: evox.algorithms.so.es_variants.des.DES.setup:15
#: evox.algorithms.so.es_variants.esmc.ESMC.setup:15
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup:15
#: evox.algorithms.so.es_variants.les.LES.setup:15
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup:15
#: evox.algorithms.so.es_variants.ma_es.MAES.setup:15
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup:15
#: evox.algorithms.so.es_variants.nes.XNES.setup:15
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup:15
#: evox.algorithms.so.es_variants.open_es.OpenES.setup:15
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup:15
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup:15
#: evox.algorithms.so.es_variants.rmes.RMES.setup:15
#: evox.algorithms.so.es_variants.snes.SNES.setup:15
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup:15
#: evox.algorithms.so.pso_variants.cso.CSO.setup:15
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup:15
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:15
#: evox.algorithms.so.pso_variants.pso.PSO.setup:15
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup:15
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup:15
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:15
#: evox.core.module.Stateful.setup:15
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:15
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup:15
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:15
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup:15
#: evox.workflows.distributed.RayDistributedWorkflow.setup:15
#: evox.workflows.non_jit_workflow.NonJitWorkflow.setup:15
#: evox.workflows.std_workflow.StdWorkflow.setup:15 of
msgid "The state of this module."
msgstr "这个模块的状态。"

#: evox.algorithms.containers.coevolution.Coevolution:2 of
msgid ""
"Automatically apply cooperative coevolution to any algorithm. The process"
" of cooperative coevolution is not vectorized, meaning all sub-"
"populations will evolve one at a time (round-robin) in each generation."
msgstr "将协同演化自动应用于任何算法。协同演化的过程未被向量化，这意味着在每一代中，所有子种群将逐一（轮流）进行进化。"

#: ../../source/api/algorithms/containers/clustered.rst:3
msgid "Clustered Algorithm"
msgstr "聚类算法"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm:2 of
msgid ""
"A container that split the encoding into subproblems, and run an "
"Algorithm on each."
msgstr "一个容器，它将编码分割成若干子问题，并在每个子问题上运行一个算法。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm:4 of
msgid ""
"Can take in any base algorithm, split the problem into n different sub-"
"problems and solve each problem using the base algorithm. Dim must be a "
"multiple of num_cluster, and num_cluster must be a multiple of num_gpus."
msgstr ""
"能够接收任何基础算法，将问题分割成 n "
"个不同的子问题，并使用基础算法解决每个子问题。其中，维度（Dim）必须是簇数量（num_cluster）的倍数，而簇数量（num_cluster）必须是"
" GPU 数量（num_gpus）的倍数。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:2
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:2
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:2
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:2
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:2
#: evox.core.algorithm.Algorithm.ask:2 of
msgid "Ask the algorithm"
msgstr "询问这个算法"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:4
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:4
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:4
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:4
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:4
#: evox.core.algorithm.Algorithm.ask:4 of
msgid "Ask the algorithm for points to explore"
msgstr "向算法询问要探索的点"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:2
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:2
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:2
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:2
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:2
#: evox.core.algorithm.Algorithm.tell:2 of
msgid "Tell the algorithm more information"
msgstr "告诉算法更多的信息"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:4
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:4
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:4
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:4
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:4
#: evox.core.algorithm.Algorithm.tell:4 of
msgid ""
"Tell the algorithm about the points it chose and their corresponding "
"fitness"
msgstr "告诉算法它选择的点以及它们对应的适应度"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:12
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:12
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:12
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:12
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:12
#: evox.core.algorithm.Algorithm.tell:12 of
msgid "**fitness**"
msgstr "**适应度**"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:12
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:12
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:12
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:12
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:12
#: evox.core.algorithm.Algorithm.tell:12 of
msgid "The fitness"
msgstr "适应度值"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm:2 of
msgid "Cluster container with random mask"
msgstr "带有随机掩码的簇容器"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm:4 of
msgid ""
"pop_size is needed, because JAX needs static shape, if pop_size is None, "
"it will try to read pop_size from base_algorithm"
msgstr "需要指定种群大小（pop_size），因为 JAX 需要静态形状，如果种群大小（pop_size）未设定，系统将尝试从基础算法中读取种群大小"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:2
#: evox.core.module.Stateful.init:2 of
msgid "Initialize this module and all submodules"
msgstr "初始化这个模块和所有的子模块"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:4
#: evox.core.module.Stateful.init:4 of
msgid "This method should not be overwritten."
msgstr "此方法不应被复写。"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:14
#: evox.core.module.Stateful.init:14 of
msgid "The state of this module and all submodules combined."
msgstr "该模块及其所有子模块的组合之和。"

#: ../../source/api/algorithms/containers/index.rst:3
msgid "Containers"
msgstr "容器"

#: ../../source/api/algorithms/containers/tree.rst:3
msgid "Tree Algorithm"
msgstr "树算法"

#: ../../source/api/algorithms/index.rst:3
msgid "Algorithms"
msgstr "算法"

#: evox.algorithms:1 of
msgid ""
"The module that contains all pre-defined algorithms, including both "
"single-objective algorithms and multi-objective algorithms."
msgstr "包含所有预定义算法的模块，包括单目标算法和多目标算法。"

#: ../../source/api/algorithms/mo/bce_ibea.rst:3
msgid "BCEIBEA"
msgstr "BCEIBEA"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:2 of
msgid "Bi-criterion evolution based IBEA"
msgstr "Bi-criterion evolution based IBEA"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:4 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/7347391"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/7347391"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:6 of
msgid ""
"Note: The number of outer iterations needs to be set to Maximum "
"Generation*2+1."
msgstr "注意：外部迭代次数需要设置为最大代数（Maximum Generation）的两倍加一。"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:25 evox.algorithms.mo.ibea.IBEA:21
#: evox.algorithms.mo.lmocso.LMOCSO:23 evox.algorithms.mo.rvea.RVEA:24 of
msgid "Args:"
msgstr "参数："

#: evox.algorithms.mo.bce_ibea.BCEIBEA:25 of
msgid ""
"kappa (float, optional): The scaling factor for selecting parents in the "
"environmental selection."
msgstr "kappa（浮点型，可选）：环境选择中用于选择父代的缩放因子。"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:10 of
msgid ""
"It controls the probability of selecting parents based on their fitness "
"values. Defaults to 0.05."
msgstr "它控制了基于个体适应度值选择父代的概率。默认值为0.05。"

#: ../../source/api/algorithms/mo/bige.rst:3
msgid "BiGE"
msgstr "BiGE"

#: evox.algorithms.mo.bige.BiGE:2 of
msgid "BiGE algorithm"
msgstr "BiGE算法"

#: evox.algorithms.mo.bige.BiGE:4 of
msgid "link: https://doi.org/10.1016/j.artint.2015.06.007"
msgstr "链接：https://doi.org/10.1016/j.artint.2015.06.007"

#: ../../source/api/algorithms/mo/eagmoead.rst:3
msgid "EAG-MOEA/D"
msgstr "EAG-MOEA/D"

#: evox.algorithms.mo.eagmoead.EAGMOEAD:2 of
msgid "EAG-MOEA/D algorithm"
msgstr "EAG-MOEA/D算法"

#: evox.algorithms.mo.eagmoead.EAGMOEAD:4 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/6882229"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/6882229"

#: ../../source/api/algorithms/mo/gde3.rst:3
msgid "GDE3"
msgstr "GDE3"

#: evox.algorithms.mo.gde3.GDE3:2 of
msgid "GDE3 algorithm"
msgstr "GDE3算法"

#: evox.algorithms.mo.gde3.GDE3:4 of
msgid "link: https://ieeexplore.ieee.org/document/1554717"
msgstr "链接：https://ieeexplore.ieee.org/document/1554717"

#: evox.algorithms.mo.gde3.GDE3.__init__:3 of
msgid "Parameters for Differential Evolution"
msgstr "差分演化的参数"

#: evox.algorithms.mo.gde3.GDE3.__init__:4 of
msgid "F"
msgstr "F"

#: evox.algorithms.mo.gde3.GDE3.__init__:5 of
msgid "The scaling factor"
msgstr "缩放因子"

#: evox.algorithms.mo.gde3.GDE3.__init__:22 of
msgid "CR"
msgstr "CR"

#: evox.algorithms.mo.gde3.GDE3.__init__:7 of
msgid "The probability of crossover"
msgstr "交叉概率"

#: ../../source/api/algorithms/mo/hype.rst:3
msgid "HypE"
msgstr "HypE"

#: evox.algorithms.mo.hype.HypE:2 of
msgid "HypE algorithm"
msgstr "HypE算法"

#: evox.algorithms.mo.hype.HypE:4 of
msgid ""
"link: https://direct.mit.edu/evco/article-abstract/19/1/45/1363/HypE-An-"
"Algorithm-for-Fast-Hypervolume-Based-Many"
msgstr ""
"链接：https://direct.mit.edu/evco/article-abstract/19/1/45/1363/HypE-An-"
"Algorithm-for-Fast-Hypervolume-Based-Many"

#: ../../source/api/algorithms/mo/ibea.rst:3
msgid "IBEA"
msgstr "IBEA"

#: evox.algorithms.mo.ibea.IBEA:2 of
msgid "IBEA algorithm"
msgstr "IBEA算法"

#: evox.algorithms.mo.ibea.IBEA:4 of
msgid "link: https://link.springer.com/chapter/10.1007/978-3-540-30217-9_84"
msgstr "链接：https://link.springer.com/chapter/10.1007/978-3-540-30217-9_84"

#: evox.algorithms.mo.ibea.IBEA:7 of
msgid "kappa: fitness scaling factor. Default: 0.05"
msgstr "kappa：适应度缩放因子。默认值：0.05"

#: ../../source/api/algorithms/mo/index.rst:3
msgid "Multi-objective"
msgstr "多目标"

#: ../../source/api/algorithms/mo/knea.rst:3
msgid "KnEA"
msgstr "KnEA"

#: evox.algorithms.mo.knea.KnEA:2 of
msgid "KnEA algorithm"
msgstr "KnEA算法"

#: evox.algorithms.mo.knea.KnEA:4 of
msgid "link: https://ieeexplore.ieee.org/document/6975108"
msgstr "链接：https://ieeexplore.ieee.org/document/6975108"

#: ../../source/api/algorithms/mo/lmocso.rst:3
msgid "LMOCSO"
msgstr "LMOCSO"

#: evox.algorithms.mo.lmocso.LMOCSO:2 of
msgid "LMOCSO algorithm"
msgstr "LMOCSO算法"

#: evox.algorithms.mo.lmocso.LMOCSO:4 of
msgid "link: https://ieeexplore.ieee.org/document/8681243"
msgstr "链接：https://ieeexplore.ieee.org/document/8681243"

#: evox.algorithms.mo.lmocso.LMOCSO:7 of
msgid ""
"alpha : The parameter controlling the rate of change of penalty. Defaults"
" to 2. max_gen : The maximum number of generations. Defaults to 100. If "
"the number of iterations is not 100, change the value based on the actual"
" value."
msgstr "alpha：控制罚分变化率的参数。默认值为2。max_gen：最大代数。默认值为100。如果迭代次数不是100，根据实际值更改该值。"

#: ../../source/api/algorithms/mo/moead.rst:3
msgid "MOEA/D"
msgstr "MOEA/D"

#: evox.algorithms.mo.moead.MOEAD:2 of
msgid "MOEA/D algorithm"
msgstr "MOEA/D算法"

#: evox.algorithms.mo.moead.MOEAD:4 of
msgid "link: https://ieeexplore.ieee.org/document/4358754"
msgstr "链接：https://ieeexplore.ieee.org/document/4358754"

#: ../../source/api/algorithms/mo/moeaddra.rst:3
msgid "MOEA/D-DRA"
msgstr "MOEA/D-DRA"

#: evox.algorithms.mo.moeaddra.MOEADDRA:2 of
msgid "MOEA/D-DRA algorithm"
msgstr "MOEA/D-DRA算法"

#: evox.algorithms.mo.moeaddra.MOEADDRA:4 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/4982949"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/4982949"

#: ../../source/api/algorithms/mo/moeadm2m.rst:3
msgid "MOEA/D-M2M"
msgstr "MOEA/D-M2M"

#: evox.algorithms.mo.moeadm2m.MOEADM2M:2 of
msgid "MOEA/D based on MOP to MOP algorithm"
msgstr "MOEA/D M2M 算法"

#: evox.algorithms.mo.moeadm2m.MOEADM2M:4 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/6595549"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/6595549"

#: ../../source/api/algorithms/mo/nsga2.rst:3
msgid "NSGA-II"
msgstr "NSGA-II"

#: evox.algorithms.mo.nsga2.NSGA2:2 of
msgid "NSGA-II algorithm"
msgstr "NSGA-II算法"

#: evox.algorithms.mo.nsga2.NSGA2:4 of
msgid "link: https://ieeexplore.ieee.org/document/996017"
msgstr "链接：https://ieeexplore.ieee.org/document/996017"

#: ../../source/api/algorithms/mo/nsga3.rst:3
msgid "NSGA-III"
msgstr "NSGA-III"

#: evox.algorithms.mo.nsga3.NSGA3:2 of
msgid "NSGA-III algorithm"
msgstr "NSGA-III算法"

#: evox.algorithms.mo.nsga3.NSGA3:4 of
msgid "link: https://ieeexplore.ieee.org/document/6600851"
msgstr "链接：https://ieeexplore.ieee.org/document/6600851"

#: ../../source/api/algorithms/mo/rvea.rst:3
msgid "RVEA"
msgstr "RVEA"

#: evox.algorithms.mo.rvea.RVEA:2 of
msgid "RVEA algorithms"
msgstr "RVEA算法"

#: evox.algorithms.mo.rvea.RVEA:4 of
msgid "link: https://ieeexplore.ieee.org/document/7386636"
msgstr "链接：https://ieeexplore.ieee.org/document/7386636"

#: evox.algorithms.mo.rvea.RVEA:7 of
msgid ""
"alpha : The parameter controlling the rate of change of penalty. Defaults"
" to 2. fr : The frequency of reference vector adaptation. Defaults to "
"0.1. max_gen : The maximum number of generations. Defaults to 100. If the"
" number of iterations is not 100, change the value based on the actual "
"value."
msgstr "alpha：控制罚分变化率的参数。默认值为2。fr：参考向量适应频率。默认值为0.1。max_gen：最大代数。默认值为100。如果迭代次数不是100，根据实际值更改该值。"

#: ../../source/api/algorithms/mo/spea2.rst:3
msgid "SPEA2"
msgstr "SPEA2"

#: evox.algorithms.mo.spea2.SPEA2:2 of
msgid "SPEA2 algorithm"
msgstr "SPEA2算法"

#: evox.algorithms.mo.spea2.SPEA2:4 of
msgid "link: https://www.research-collection.ethz.ch/handle/20.500.11850/145755"
msgstr "链接：https://www.research-collection.ethz.ch/handle/20.500.11850/145755"

#: ../../source/api/algorithms/mo/sra.rst:3
msgid "SRA"
msgstr "SRA"

#: evox.algorithms.mo.sra.SRA:2 of
msgid "Stochastic ranking algorithm"
msgstr "随机排序算法"

#: evox.algorithms.mo.sra.SRA:4 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/7445185"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/7445185"

#: ../../source/api/algorithms/mo/tdea.rst:3
msgid "tDEA"
msgstr "tDEA"

#: evox.algorithms.mo.tdea.TDEA:2 of
msgid "Theta-dominance based evolutionary algorithm"
msgstr "基于θ优势的演化算法"

#: evox.algorithms.mo.tdea.TDEA:4 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/7080938"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/7080938"

#: ../../source/api/algorithms/so/amalgam.rst:3
msgid "AMaLGaM"
msgstr "AMaLGaM"

#: ../../source/api/algorithms/so/ars.rst:3
msgid "ARS"
msgstr "ARS"

#: ../../source/api/algorithms/so/asebo.rst:3
msgid "ASEBO"
msgstr "ASEBO"

#: ../../source/api/algorithms/so/clpso.rst:3
msgid "CLPSO"
msgstr "CLPSO"

#: ../../source/api/algorithms/so/cma_es.rst:3
msgid "CMA-ES"
msgstr "CMA-ES"

#: evox.algorithms.so.es_variants.cma_es.CMAES.__init__:2
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.__init__:2
#: evox.algorithms.so.es_variants.ma_es.LMMAES.__init__:2
#: evox.algorithms.so.es_variants.ma_es.MAES.__init__:2
#: evox.algorithms.so.es_variants.rmes.RMES.__init__:2 of
msgid ""
"This implementation follows `The CMA Evolution Strategy: A Tutorial "
"<https://arxiv.org/pdf/1604.00772.pdf>`_."
msgstr ""
"这个实现遵循了《CMA 演化策略：教程》（The CMA Evolution Strategy: A "
"Tutorial），详情可见：https://arxiv.org/pdf/1604.00772.pdf。"

#: evox.algorithms.so.es_variants.cma_es.CMAES.__init__:5
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.__init__:5
#: evox.algorithms.so.es_variants.ma_es.LMMAES.__init__:5
#: evox.algorithms.so.es_variants.ma_es.MAES.__init__:5
#: evox.algorithms.so.es_variants.rmes.RMES.__init__:5 of
msgid ""
"CMA-ES involves eigendecomposition, which introduces relatively large "
"numerical error, and may lead to non-deterministic behavior on different "
"hardware backends."
msgstr "CMA-ES涉及特征分解，这会引入相对较大的数值误差，并可能导致在不同硬件后端上的非确定性行为。"

#: ../../source/api/algorithms/so/code.rst:3
msgid "CoDE"
msgstr "CoDE"

#: evox.algorithms.so.de_variants.code.CoDE:2 of
msgid ""
"CoDE Wang Y, Cai Z, Zhang Q. Differential evolution with composite trial "
"vector generation strategies and control parameters[J]. IEEE transactions"
" on evolutionary computation, 2011, 15(1): 55-66."
msgstr ""
"CoDE Wang Y, Cai Z, Zhang Q. Differential evolution with composite trial "
"vector generation strategies and control parameters[J]. IEEE transactions"
" on evolutionary computation, 2011, 15(1): 55-66."

#: ../../source/api/algorithms/so/cpso_s.rst:3
msgid "CPSO_S"
msgstr "CPSO_S"

#: evox.algorithms.so.pso_variants.cpso_s.CPSOS:2 of
msgid ""
"Cooperative particle swarm optimizer. Implemented using EvoX's built-in "
"coevolution framework. CPSOS essentially a wrapper around PSO and "
"Coevolution."
msgstr "协同粒子群优化器（CPSO）在EvoX库中通过其内置的协同演化框架得以实现，实质上，CPSOS本质上是对PSO（粒子群优化算法）和协同演化的封装。"

#: evox.algorithms.so.pso_variants.cpso_s.CPSOS:6 of
msgid "https://ieeexplore.ieee.org/document/1304845"
msgstr "https://ieeexplore.ieee.org/document/1304845"

#: ../../source/api/algorithms/so/cr_fm_nes.rst:3
msgid "CR-FM-NES"
msgstr "CR-FM-NES"

#: ../../source/api/algorithms/so/cso.rst:3
msgid "CSO"
msgstr "CSO"

#: ../../source/api/algorithms/so/de.rst:3
msgid "DE"
msgstr "DE"

#: ../../source/api/algorithms/so/des.rst:3
msgid "DES"
msgstr "DES"

#: ../../source/api/algorithms/so/dms_pso_el.rst:3
msgid "DMS-PSO-EL"
msgstr "DMS-PSO-EL"

#: ../../source/api/algorithms/so/esmc.rst:3
msgid "ESMC"
msgstr "ESMC"

#: ../../source/api/algorithms/so/fips.rst:3
msgid "FIPS"
msgstr "FIPS"

#: ../../source/api/algorithms/so/guide_es.rst:3
msgid "GuidedES"
msgstr "GuidedES"

#: ../../source/api/algorithms/so/index.rst:3
msgid "Single-objective"
msgstr "单目标"

#: ../../source/api/algorithms/so/jade.rst:3
msgid "JaDE"
msgstr "JaDE"

#: evox.algorithms.so.de_variants.jade.JaDE:2 of
msgid ""
"JaDE Zhang J, Sanderson A C. JADE: adaptive differential evolution with "
"optional external archive[J]. IEEE Transactions on evolutionary "
"computation, 2009, 13(5): 945-958."
msgstr ""
"JaDE Zhang J, Sanderson A C. JADE: adaptive differential evolution with "
"optional external archive[J]. IEEE Transactions on evolutionary "
"computation, 2009, 13(5): 945-958."

#: ../../source/api/algorithms/so/les.rst:3
msgid "LES"
msgstr "LES"

#: ../../source/api/algorithms/so/ma_es.rst:3
msgid "MA-ES"
msgstr "MA-ES"

#: ../../source/api/algorithms/so/nes.rst:3
msgid "xNES"
msgstr "xNES"

#: evox.algorithms.so.es_variants.nes.SeparableNES.__init__:2
#: evox.algorithms.so.es_variants.nes.XNES.__init__:2 of
msgid "See [link](https://arxiv.org/pdf/1106.4487.pdf) for default parameters"
msgstr "参考链接[link](https://arxiv.org/pdf/1106.4487.pdf)中的默认参数"

#: ../../source/api/algorithms/so/noise_reuse_es.rst:3
msgid "Noise-Reuse-ES"
msgstr "Noise-Reuse-ES"

#: ../../source/api/algorithms/so/ode.rst:3
msgid "ODE"
msgstr "ODE"

#: ../../source/api/algorithms/so/open_es.rst:3
msgid "OpenES"
msgstr "OpenES"

#: evox.algorithms.so.es_variants.open_es.OpenES.__init__:2 of
msgid ""
"Implement the algorithm described in \"Evolution Strategies as a Scalable"
" Alternative to Reinforcement Learning\" from "
"https://arxiv.org/abs/1703.03864"
msgstr ""
"实现论文 \"Evolution Strategies as a Scalable Alternative to Reinforcement "
"Learning\" 中描述的算法，链接为https://arxiv.org/abs/1703.03864"

#: ../../source/api/algorithms/so/persistent_es.rst:3
msgid "PersistentES"
msgstr "PersistentES"

#: ../../source/api/algorithms/so/pgpe.rst:3
msgid "PGPE"
msgstr "PGPE"

#: ../../source/api/algorithms/so/pso.rst:3
msgid "PSO"
msgstr "PSO"

#: ../../source/api/algorithms/so/rmes.rst:3
msgid "RMES"
msgstr "RMES"

#: ../../source/api/algorithms/so/sade.rst:3
msgid "SaDE"
msgstr "SaDE"

#: evox.algorithms.so.de_variants.sade.SaDE:2 of
msgid ""
"SaDE Qin A K, Huang V L, Suganthan P N. Differential evolution algorithm "
"with strategy adaptation for global numerical optimization[J]. IEEE "
"transactions on Evolutionary Computation, 2008, 13(2): 398-417."
msgstr ""
"SaDE Qin A K, Huang V L, Suganthan P N. Differential evolution algorithm "
"with strategy adaptation for global numerical optimization[J]. IEEE "
"transactions on Evolutionary Computation, 2008, 13(2): 398-417."

#: ../../source/api/algorithms/so/shade.rst:3
msgid "SHADE"
msgstr "SHADE"

#: evox.algorithms.so.de_variants.shade.SHADE:2 of
msgid ""
"SHADE Tanabe R, Fukunaga A. Success-history based parameter adaptation "
"for differential evolution[C]//2013 IEEE congress on evolutionary "
"computation. IEEE, 2013: 71-78."
msgstr ""
"SHADE Tanabe R, Fukunaga A. Success-history based parameter adaptation "
"for differential evolution[C]//2013 IEEE congress on evolutionary "
"computation. IEEE, 2013: 71-78."

#: ../../source/api/algorithms/so/sl_pso_gs.rst:3
msgid "SL-PSO-GS"
msgstr "SL-PSO-GS"

#: ../../source/api/algorithms/so/sl_pso_us.rst:3
msgid "SL-PSO-US"
msgstr "SL-PSO-US"

#: ../../source/api/algorithms/so/snes.rst:3
msgid "SNES"
msgstr "SNES"

#: ../../source/api/algorithms/so/swmmpso.rst:3
msgid "SWMMPSO"
msgstr "SWMMPSO"

#: ../../source/api/core/algorithm.rst:3
msgid "Algorithm Class"
msgstr "算法类"

#: evox.core.algorithm.Algorithm:2 evox.core.problem.Problem:2 of
msgid "Base class for all algorithms"
msgstr "所有算法的基类"

#: ../../source/api/core/index.rst:3
msgid "Core Classes"
msgstr "核心类"

#: ../../source/api/core/module.rst:3
msgid "Module Class"
msgstr "模块类"

#: evox.core.module.Stateful:2 of
msgid "Base class for all evox modules."
msgstr "所有EvoX模块的基础类。"

#: evox.core.module.Stateful:4 of
msgid "This module allow easy managing of states."
msgstr "这个模块允许轻松管理状态。"

#: evox.core.module.Stateful:6 of
msgid ""
"All the constants (e.g. hyperparameters) are initialized in the "
"``__init__``, and mutated states are initialized in the ``setup`` method."
msgstr "所有常数（例如超参数）都在“ __init__” 中初始化，而变异状态则在 “setup” 方法中初始化。"

#: evox.core.module.Stateful:9 of
msgid ""
"The ``init`` method will automatically call the ``setup`` of the current "
"module and recursively call ``setup`` methods of all submodules."
msgstr "“init” 方法将自动调用当前模块的 “setup”，并递归地调用所有子模块的 “setup” 方法。"

#: ../../source/api/core/problem.rst:3
msgid "Problem Class"
msgstr "问题类"

#: evox.core.problem.Problem.evaluate:2
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:2 of
msgid "Evaluate the fitness at given points"
msgstr "在给定点评估适应度"

#: evox.core.problem.Problem.evaluate:-1 evox.core.problem.Problem.evaluate:16
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:-1
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:16 of
msgid "dict"
msgstr "字典"

#: evox.core.problem.Problem.evaluate:8
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:8 of
msgid "The state of this problem."
msgstr "这个问题的状态。"

#: evox.core.problem.Problem.evaluate:11
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:11 of
msgid "**X**"
msgstr "**X**"

#: evox.core.problem.Problem.evaluate:-1 evox.core.problem.Problem.evaluate:31
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:-1
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:31 of
msgid "ndarray"
msgstr "ndarray"

#: evox.core.problem.Problem.evaluate:11
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:11 of
msgid "The population."
msgstr "种群。"

#: evox.core.problem.Problem.evaluate:19
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:19 of
msgid "The fitness."
msgstr "适应度值。"

#: ../../source/api/core/state.rst:3
msgid "State Class"
msgstr "状态类"

#: evox.core.state.State:2 of
msgid "A class represents state"
msgstr "一个表示状态的类"

#: evox.core.state.State:4 of
msgid ""
"``State`` is immutable, to update state, use the ``update`` method or the"
" ``|`` operator. ``State`` has already implemented ``tree_flatten``, "
"``tree_unflatten`` and has registered as a valid pytree node. So it can "
"be used as pytree with JAX without any issue."
msgstr ""
"“State ”是不可变的，要更新状态，请使用“update ” 方法或 “| ”运算符。“State ” 已经实现了 "
"“tree_flatten”、“tree_unflatten ”并且已注册为有效的 pytree 节点。因此，它可以与 JAX 一起作为 "
"pytree 使用。"

#: evox.core.state.State.__init__:2 of
msgid "Construct a ``State`` from dict or keyword arguments"
msgstr "从Python字典（dict）或关键字（keyword arguments）构建一个状态（State）对象"

#: evox.core.state.State.__init__:23 evox.core.state.State.update:28 of
msgid "Example::"
msgstr "例子："

#: evox.core.state.State.find_path_to:2 of
msgid ""
"Find the state with node_id matching the state_id A hint can be given "
"with the module_name"
msgstr "找到节点 ID 与状态 ID 匹配的状态。可以通过模块名称给出提示"

#: evox.core.state.State.update:2 of
msgid "Update the current State with another State or dict and return new State."
msgstr "使用另一个 State 或 dict 更新当前 State，并返回新的 State。"

#: evox.core.state.State.update:4 of
msgid "This method also accept keyword arguments."
msgstr "这个方法也接受关键字参数。"

#: ../../source/api/metrics/gd.rst:3
msgid "Generational Distance"
msgstr "世代距离"

#: ../../source/api/metrics/hv.rst:3
msgid "Hypervolume"
msgstr "超体积"

#: evox.metrics.hypervolume.HV:2 of
msgid ""
"Hypervolume indicator Implemented using monte carlo. We offers two "
"different sample methods: `bounding_cube` and `each_cube`. With "
"`bounding_cube`, we draw samples from a hypercube that can bound all "
"objectives. With `each_cube`, we draw samples from each hypercube form by"
" each objective and the reference point. Since reference point is often "
"far from pf, `bounding_cube` method usually gives more accurate result."
msgstr ""
"超体积指标，使用蒙特卡洛方法实现。我们提供两种不同的样本方法：`bounding_cube` 和 `each_cube`。使用 "
"`bounding_cube` 方法，我们从一个可以包围所有目标的超立方体中抽取样本。使用 `each_cube` "
"方法，我们从由每个目标和参考点形成的每个超立方体中抽取样本。由于参考点通常远离帕雷托前沿（pf），`bounding_cube`方法通常能提供更准确的结果。"

#: evox.metrics.hypervolume.HV.__init__:8 of
msgid "**ref**"
msgstr "**ref**"

#: evox.metrics.hypervolume.HV.__init__:8 of
msgid "The reference point."
msgstr "参考点。"

#: evox.metrics.hypervolume.HV.__init__:11 of
msgid "**num_sample**"
msgstr "**样本数量**"

#: evox.metrics.hypervolume.HV.__init__:11 of
msgid "Number of samples to draw when doing monte carlo."
msgstr "在使用蒙特卡洛方法的时候样本的数量。"

#: evox.metrics.hypervolume.HV.__init__:28 of
msgid "**sample_method**"
msgstr "**sample_method**"

#: evox.metrics.hypervolume.HV.__init__:14 of
msgid "`bounding_cube` or `each_cube`. Default to `bounding_cube`."
msgstr "`bounding_cube` 或 `each_cube`. 默认为 `bounding_cube`."

#: ../../source/api/metrics/igd.rst:3
msgid "Inverted Generational Distance"
msgstr "反世代距离"

#: ../../source/api/metrics/index.rst:3
msgid "Metrics"
msgstr "度量指标"

#: ../../source/api/monitors/eval.rst:3
#, fuzzy
msgid "Evaluation Monitor"
msgstr "可选监控器。"

#: evox.monitors.eval_monitor.EvalMonitor:2 of
msgid ""
"Evaluation monitor. Used for both single-objective and multi-objective "
"workflow. Hooked around the evaluation process, can monitor the "
"offspring, their corresponding fitness and keep track of the evaluation "
"count. Moreover, it can also record the best solution or the pareto front"
" on-the-fly."
msgstr ""

#: evox.monitors.eval_monitor.EvalMonitor:13 of
#, fuzzy
msgid "**full_fit_history**"
msgstr "**record_fit_history**"

#: evox.monitors.eval_monitor.EvalMonitor:12
#: evox.monitors.std_mo_monitor.StdMOMonitor:17
#: evox.monitors.std_so_monitor.StdSOMonitor:14 of
msgid ""
"Whether to record the full history of fitness value. Default to True. "
"Setting it to False may reduce memory usage."
msgstr "是否记录适应度值的完整历史。默认为True。将其设置为FALSE可能会减少内存使用。"

#: evox.monitors.eval_monitor.EvalMonitor:17 of
#, fuzzy
msgid "**full_sol_history**"
msgstr "**record_fit_history**"

#: evox.monitors.eval_monitor.EvalMonitor:16 of
#, fuzzy
msgid ""
"Whether to record the full history of solutions. Default to False. "
"Setting it to True may increase memory usage."
msgstr "是否记录适应度值的完整历史。默认为True。将其设置为FALSE可能会减少内存使用。"

#: evox.monitors.eval_monitor.EvalMonitor:21 of
#, fuzzy
msgid "**topk**"
msgstr "**record_topk**"

#: evox.monitors.eval_monitor.EvalMonitor:20 of
#, fuzzy
msgid ""
"Only affect Single-objective optimization. The number of elite solutions "
"to record. Default to 1, which will record the best individual."
msgstr "控制录制多少精英解决方案。默认为1，它将记录最好的个体。"

#: evox.monitors.eval_monitor.EvalMonitor:42 of
#, fuzzy
msgid "**calc_pf**"
msgstr "**record_pf**"

#: evox.monitors.eval_monitor.EvalMonitor:24 of
#, fuzzy
msgid ""
"Only affect Multi-objective optimization. Whether to keep updating the "
"pareto front during the run. (The Archive) Default to False. Setting it "
"to True will cause the monitor to maintain a pareto front of all the "
"solutions with unlimited size, which may hurt performance."
msgstr "是否在运行过程中记录帕累托前沿。默认值为假（False）。将其设置为真（True）将导致监视器维护一个无限大小的所有解决方案的帕累托前沿，这可能会影响性能。"

#: ../../source/api/monitors/evoxvis.rst:3
msgid "EvoXVis Monitor"
msgstr "EvoXVis 监视器"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor:2 of
msgid ""
"This class serialize data to apache arrow format, which can be picked up "
"and used in EvoXVis. The tensors are stored as fixed size binary and the "
"dtype is recorded in the metadata."
msgstr "这个类将数据序列化为可以在EvoXVis中提取和使用的apache arrow格式。张量被存储为固定大小的二进制，并且数据类型被记录在元数据中。"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:10 of
msgid "**base_filename**"
msgstr "**base_filename**"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:8 of
msgid ""
"The base filename of the log file, the final filename will be "
"``<base_filename>_<i>.arrow``, where i is an incrementing number."
msgstr "日志文件的基本文件名，最终文件名将是``<base_filename>_<i>.arrow``，其中i是递增的数字。"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:17 of
msgid "**out_dir**"
msgstr "**out_dir**"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:13 of
msgid ""
"This directory to write the log file into. When set to None, the default "
"directory will be used. The default is ``<TEMP_DIR>/evox``, on Windows, "
"it's usually ``C:\\TEMP\\evox``, and on MacOS/Linux/BSDs it's "
"``/tmp/evox``."
msgstr "将日志文件写入的目录。当设置为None时，将使用默认目录。默认为``<TEMP_DIR>/evox``，在Windows上通常为``C：\\temp\\evox``，在MacOS/Linux/BSD上为``/tMP/evox``。"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:22 of
msgid "**out_type**"
msgstr "**out_type**"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:20 of
msgid ""
"\"stream\" or \"file\", For more information, please refer to "
"https://arrow.apache.org/docs/python/ipc.html"
msgstr ""
"\"stream\" 或\"file\"，更多信息，请参考 "
"https://arrow.apache.org/docs/python/ipc.html"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:29
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:16 of
msgid "**batch_size**"
msgstr "**batch_size**"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:25 of
msgid ""
"The monitor will buffer the data in memory and write out every `batch "
"size`. Choose a larger value may improve I/O performance and improve "
"compression ratio, if compression is enabled. Default to 64."
msgstr "监控器会将数据缓存在内存中，并写出每个`batch size`。如果启用了压缩，则选择较大的值可能会提高I/O性能并提高压缩比。默认为64。"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:48 of
msgid "**compression**"
msgstr "**compression**"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:32 of
msgid ""
"Controls the compression algorithm used when writing to the file. "
"Available options are None, \"lz4\", \"zstd\", \"lz4\" is extremely fast,"
" with poor compression ratio, \"zstd\" is fast, but also with good "
"compression ratio."
msgstr "控制写入文件时使用的压缩算法。可供选择的有None、“lz4”、“zstd”，“lz4”速度极快，压缩比差，“zstd”速度快，同时压缩比也很好。"

#: ../../source/api/monitors/index.rst:3
msgid "Monitors"
msgstr "监视器"

#: ../../source/api/monitors/pop.rst:3
#, fuzzy
msgid "Population Monitor"
msgstr "可选监控器。"

#: evox.monitors.pop_monitor.PopMonitor:2 of
msgid ""
"Population monitor, used to monitor the population inside the genetic "
"algorithm."
msgstr ""

#: evox.monitors.pop_monitor.PopMonitor:10 of
#, fuzzy
msgid "**population_name**"
msgstr "种群"

#: evox.monitors.pop_monitor.PopMonitor:9 of
msgid "The name of the population in the state. Default to \"population\"."
msgstr ""

#: evox.monitors.pop_monitor.PopMonitor:14 of
#, fuzzy
msgid "**fitness_name**"
msgstr "**适应度**"

#: evox.monitors.pop_monitor.PopMonitor:13 of
msgid "The name of the fitness in the state. Default to \"fitness\"."
msgstr ""

#: evox.monitors.pop_monitor.PopMonitor:20 of
#, fuzzy
msgid "**to_host**"
msgstr "**mo_keys**"

#: evox.monitors.pop_monitor.PopMonitor:17 of
msgid ""
"Whether to move the population and fitness to host memory (ram). Doing so"
" can reduce memory usage on device (vram), but also introduces overhead "
"of data transfer. Default to False."
msgstr ""

#: evox.monitors.pop_monitor.PopMonitor:40 of
#, fuzzy
msgid "**fitness_only**"
msgstr "**适应度**"

#: evox.monitors.pop_monitor.PopMonitor:23 of
msgid ""
"Whether to only record the fitness. Setting it to True will disable the "
"recording of population (decision space), only the fitness (objective "
"space) will be recorded. This can reduce memory usage if you only care "
"about the fitness. Default to False."
msgstr ""

#: ../../source/api/monitors/std_mo.rst:3
msgid "Standard Multi-objective Monitor"
msgstr "标准多目标监视器"

#: evox.monitors.std_mo_monitor.StdMOMonitor:2 of
msgid ""
"Standard multi-objective monitor Used for multi-objective workflow, can "
"monitor fitness and record the pareto front."
msgstr "标准多目标监视器，用于多目标工作流，可以监控适应度并记录帕累托前沿。"

#: evox.monitors.std_mo_monitor.StdMOMonitor:14 of
msgid "**record_pf**"
msgstr "**record_pf**"

#: evox.monitors.std_mo_monitor.StdMOMonitor:10 of
msgid ""
"Whether to record the pareto front during the run. Default to False. "
"Setting it to True will cause the monitor to maintain a pareto front of "
"all the solutions with unlimited size, which may hurt performance."
msgstr "是否在运行过程中记录帕累托前沿。默认值为假（False）。将其设置为真（True）将导致监视器维护一个无限大小的所有解决方案的帕累托前沿，这可能会影响性能。"

#: evox.monitors.std_mo_monitor.StdMOMonitor:31
#: evox.monitors.std_so_monitor.StdSOMonitor:28 of
msgid "**record_fit_history**"
msgstr "**record_fit_history**"

#: ../../source/api/monitors/std_so.rst:3
msgid "Standard Single-objective Monitor"
msgstr "标准单目标监视器"

#: evox.monitors.std_so_monitor.StdSOMonitor:2 of
msgid ""
"Standard single-objective monitor Used for single-objective workflow, can"
" monitor fitness and the population."
msgstr "标准单目标监控器 用于单目标工作流，可以监控适应度和种群。"

#: evox.monitors.std_so_monitor.StdSOMonitor:11 of
msgid "**record_topk**"
msgstr "**record_topk**"

#: evox.monitors.std_so_monitor.StdSOMonitor:10 of
msgid ""
"Control how many elite solutions are recorded. Default is 1, which will "
"record the best individual."
msgstr "控制录制多少精英解决方案。默认为1，它将记录最好的个体。"

#: ../../source/api/problems/index.rst:3
msgid "Problems"
msgstr "问题"

#: evox.problems:1 of
msgid "The module that contains all pre-defined problems"
msgstr "包含所有预定义的问题的模块"

#: ../../source/api/problems/neuroevolution/index.rst:3
msgid "Neuroevolution"
msgstr "神经演化"

#: ../../source/api/problems/neuroevolution/reinforcement_learning/brax.rst:3
msgid "Brax-based Problem"
msgstr "基于Brax的问题"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:2 of
msgid "Contruct a brax-based problem"
msgstr "构造一个基于Brax的问题"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:9
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:9 of
msgid "**policy**"
msgstr "**策略**"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:8
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:8 of
msgid ""
"A function that accept two arguments the first one is the parameter and "
"the second is the input."
msgstr "一个接受两个参数的函数，第一个参数是参数本身，第二个是输入。"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:12
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:15 of
msgid "**env_name**"
msgstr "**env_name**"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:12 of
msgid "The environment name."
msgstr "环境名。"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:15 of
msgid ""
"The number of brax environments to run in parallel. Usually this should "
"match the population size at the algorithm side."
msgstr "要并行运行的BRAX环境的数量。通常，这应该与算法端的种群大小相匹配。"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:19 of
msgid "**cap_episode**"
msgstr "**cap_episode**"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:19 of
msgid "The maximum number episodes to run."
msgstr "运行的最大episode数量。"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:36 of
msgid "**backend**"
msgstr "**后端**"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:22 of
msgid ""
"Brax's backend, one of \"generalized\", \"positional\", \"spring\". "
"Default to \"generalized\"."
msgstr "Brax的后端，是“generalized”、“positional”、“spring”中的其中一个。默认为“generalized”。"

#: ../../source/api/problems/neuroevolution/reinforcement_learning/env_pool.rst:3
msgid "Env Pool"
msgstr "环境池"

#: ../../source/api/problems/neuroevolution/reinforcement_learning/gym.rst:3
msgid "Gym"
msgstr "Gym"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:2 of
msgid "Construct a gym problem"
msgstr "构建一个gym 问题"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:12
#: evox.workflows.distributed.RayDistributedWorkflow.__init__:20 of
msgid "**num_workers**"
msgstr "**num_workers**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:12 of
msgid "Number of worker actors."
msgstr "工作者（worker）actor的数量。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:15 of
msgid "The name of the gym environment."
msgstr "Gym环境的名称。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:18 of
msgid "**env_options**"
msgstr "**env_options**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:18 of
msgid "The options of the gym environment."
msgstr "gym 环境的选项。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:21 of
msgid "**env_creator**"
msgstr "**env_creator**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:21 of
msgid "A function with zero argument that returns an environment when called."
msgstr "一个调用时返回一个环境的零参数函数。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:28 of
msgid "**mo_keys**"
msgstr "**mo_keys**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:24 of
msgid ""
"Optional, a list of strings. If set, the environment is treated as a "
"multi-objective problem, and different objective values are obtained "
"through the `info` term returned by Gym. The `mo_keys` parameter provides"
" the keys for accessing the objective values in the info dictionary. The "
"objective values will be returned in the same order as specified in "
"`mo_keys`."
msgstr "可选参数，一个字符串列表。如果设置，环境被视为一个多目标问题，不同的目标值通过Gym返回的`info`项获取。`mo_keys`参数提供了在info字典中访问目标值的键。目标值将按照在`mo_keys`中指定的顺序返回。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:36 of
msgid "**controller_options**"
msgstr "**控制器选项**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:31 of
msgid ""
"The runtime options for controller actor. This actor is used to control "
"workers and run the policy at each step. For example, to enable GPU "
"acceleration on the policy network, set this field to::"
msgstr "控制器actor的运行时选项。这个actor用于控制工作者worker，并在每一步运行策略。例如，要启用策略网络的GPU加速功能，请将此字段设置为::"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:52 of
msgid "**worker_options**"
msgstr "**工作者选项**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:39 of
msgid "The runtime options for worker actors."
msgstr "工作者（actor）的运行时选项。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:2 of
msgid ""
"Visualize your policy, passin a single set of weights, and it will be put"
" in the environment for interaction."
msgstr "可视化您的策略，通过传递一组权重，该策略将会被置于环境中进行互动展示。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:9
#: evox.workflows.std_workflow.StdWorkflow.enable_distributed:11
#: evox.workflows.std_workflow.StdWorkflow.enable_multi_devices:8 of
msgid "The state."
msgstr "状态。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:12 of
msgid "This key will be used to seed the test environment."
msgstr "此密钥将会作为测试环境的随机数种子。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:15 of
msgid "**weights**"
msgstr "**权重**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:15 of
msgid "A single set of weights for your policy."
msgstr "策略的一组权重。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:41 of
msgid "**ale_render_mode**"
msgstr "**ale_render_mode**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:18 of
msgid "'rgb_array' or 'human'."
msgstr "'rgb_array' 或 'human'。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:20 of
msgid ""
"In 'rgb_array' mode, this function will return a list of frames, each "
"frame is a numpy array."
msgstr "在\"rgb_array\"模式下，该函数将返回一个帧列表，每个帧都是一个numpy数组。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:23 of
msgid ""
"In 'human' mode, the frame should be displayed directly onto your screen."
" However, if your using remote python environment, for example vscode ssh"
" or jupyter notebook, this method may fail to find a valid display. "
"Default to 'rgb_array'."
msgstr ""
"在\"human\"模式下，帧应直接显示在屏幕上。但是，如果您正在使用远程Python环境（例如VSCode SSH或Jupyter "
"Notebook），这种方法可能无法找到有效的显示器，因此默认设置为\"rgb_array\"模式。"

#: ../../source/api/problems/neuroevolution/reinforcement_learning/index.rst:3
msgid "Reinforcement Learning"
msgstr "强化学习"

#: ../../source/api/problems/neuroevolution/supervised_learning/index.rst:3
msgid "Supervised Learning"
msgstr "监督学习"

#: ../../source/api/problems/neuroevolution/supervised_learning/torchvision.rst:3
msgid "Torchvision Dataset"
msgstr "Torchvision 数据集"

#: ../../source/api/problems/numerical/index.rst:3
msgid "Numerical Benchmarks"
msgstr "数值基准测试"

#: ../../source/api/problems/numerical/test_functions/ackley.rst:3
msgid "Ackley"
msgstr "Ackley"

#: ../../source/api/problems/numerical/test_functions/griewank.rst:3
msgid "Griewank"
msgstr "Griewank"

#: ../../source/api/problems/numerical/test_functions/index.md:1
msgid "Test functions"
msgstr "测试函数"

#: ../../source/api/problems/numerical/test_functions/rastrigin.rst:3
msgid "Rastrigin"
msgstr "Rastrigin"

#: ../../source/api/problems/numerical/test_functions/rosenbrock.rst:3
msgid "Rosenbrock"
msgstr "Rosenbrock"

#: ../../source/api/problems/numerical/test_functions/schwefel.rst:3
msgid "Schwefel"
msgstr "Schwefel"

#: evox.problems.numerical.schwefel.Schwefel:2 of
msgid "The Schwefel function The minimum is x = [420.9687462275036, ...]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/api/problems/numerical/test_functions/sphere.rst:3
msgid "Sphere"
msgstr "Sphere"

#: ../../source/api/problems/numerical/test_suits/cec2022.rst:3
msgid "CEC2022 Test Suit"
msgstr "CEC2022 测试套件"

#: evox.problems.numerical.cec2022_so.CEC2022TestSuit:2 of
msgid ""
"Instantiation format: problem_instance = CEC2022.create(1) i.e., "
"problem_instance = F1_CEC2022()"
msgstr ""
"实例化格式：problem_instance = CEC2022.create(1)，即 problem_instance = "
"F1_CEC2022()"

#: evox.problems.numerical.cec2022_so.F10_CEC2022:2
#: evox.problems.numerical.cec2022_so.F11_CEC2022:2
#: evox.problems.numerical.cec2022_so.F12_CEC2022:2
#: evox.problems.numerical.cec2022_so.F1_CEC2022:2
#: evox.problems.numerical.cec2022_so.F2_CEC2022:2
#: evox.problems.numerical.cec2022_so.F3_CEC2022:2
#: evox.problems.numerical.cec2022_so.F4_CEC2022:2
#: evox.problems.numerical.cec2022_so.F5_CEC2022:2
#: evox.problems.numerical.cec2022_so.F6_CEC2022:2
#: evox.problems.numerical.cec2022_so.F7_CEC2022:2
#: evox.problems.numerical.cec2022_so.F8_CEC2022:2
#: evox.problems.numerical.cec2022_so.F9_CEC2022:2 of
msgid "Test problems of CEC2022"
msgstr "CEC2022测试问题集"

#: ../../source/api/problems/numerical/test_suits/dtlz.rst:3
msgid "DTLZ Test Suit"
msgstr "DTLZ测试套件"

#: ../../source/api/problems/numerical/test_suits/index.md:1
msgid "Test suits"
msgstr "测试套件"

#: ../../source/api/problems/numerical/test_suits/lsmop.rst:3
msgid "LSMOP Test Suit"
msgstr "LSMOP测试套件"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:2
#: evox.problems.numerical.lsmop.LSMOP2.__init__:2
#: evox.problems.numerical.lsmop.LSMOP3.__init__:2
#: evox.problems.numerical.lsmop.LSMOP4.__init__:2
#: evox.problems.numerical.lsmop.LSMOP5.__init__:2
#: evox.problems.numerical.lsmop.LSMOP6.__init__:2
#: evox.problems.numerical.lsmop.LSMOP7.__init__:2
#: evox.problems.numerical.lsmop.LSMOP8.__init__:2
#: evox.problems.numerical.lsmop.LSMOP9.__init__:2 of
msgid "init"
msgstr "init"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:8
#: evox.problems.numerical.lsmop.LSMOP2.__init__:8
#: evox.problems.numerical.lsmop.LSMOP3.__init__:8
#: evox.problems.numerical.lsmop.LSMOP4.__init__:8
#: evox.problems.numerical.lsmop.LSMOP5.__init__:8
#: evox.problems.numerical.lsmop.LSMOP6.__init__:8
#: evox.problems.numerical.lsmop.LSMOP7.__init__:8
#: evox.problems.numerical.lsmop.LSMOP8.__init__:8
#: evox.problems.numerical.lsmop.LSMOP9.__init__:8 of
msgid "**d**"
msgstr "**维度**"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:8
#: evox.problems.numerical.lsmop.LSMOP2.__init__:8
#: evox.problems.numerical.lsmop.LSMOP3.__init__:8
#: evox.problems.numerical.lsmop.LSMOP4.__init__:8
#: evox.problems.numerical.lsmop.LSMOP5.__init__:8
#: evox.problems.numerical.lsmop.LSMOP6.__init__:8
#: evox.problems.numerical.lsmop.LSMOP7.__init__:8
#: evox.problems.numerical.lsmop.LSMOP8.__init__:8
#: evox.problems.numerical.lsmop.LSMOP9.__init__:8 of
msgid "the dimension of decision space"
msgstr "决策空间的维度"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:11
#: evox.problems.numerical.lsmop.LSMOP2.__init__:11
#: evox.problems.numerical.lsmop.LSMOP3.__init__:11
#: evox.problems.numerical.lsmop.LSMOP4.__init__:11
#: evox.problems.numerical.lsmop.LSMOP5.__init__:11
#: evox.problems.numerical.lsmop.LSMOP6.__init__:11
#: evox.problems.numerical.lsmop.LSMOP7.__init__:11
#: evox.problems.numerical.lsmop.LSMOP8.__init__:11
#: evox.problems.numerical.lsmop.LSMOP9.__init__:11 of
msgid "**m**"
msgstr "**目标数目**"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:11
#: evox.problems.numerical.lsmop.LSMOP2.__init__:11
#: evox.problems.numerical.lsmop.LSMOP3.__init__:11
#: evox.problems.numerical.lsmop.LSMOP4.__init__:11
#: evox.problems.numerical.lsmop.LSMOP5.__init__:11
#: evox.problems.numerical.lsmop.LSMOP6.__init__:11
#: evox.problems.numerical.lsmop.LSMOP7.__init__:11
#: evox.problems.numerical.lsmop.LSMOP8.__init__:11
#: evox.problems.numerical.lsmop.LSMOP9.__init__:11 of
msgid "the number of object"
msgstr "目标数量"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:27
#: evox.problems.numerical.lsmop.LSMOP2.__init__:27
#: evox.problems.numerical.lsmop.LSMOP3.__init__:27
#: evox.problems.numerical.lsmop.LSMOP4.__init__:27
#: evox.problems.numerical.lsmop.LSMOP5.__init__:27
#: evox.problems.numerical.lsmop.LSMOP6.__init__:27
#: evox.problems.numerical.lsmop.LSMOP7.__init__:27
#: evox.problems.numerical.lsmop.LSMOP8.__init__:27
#: evox.problems.numerical.lsmop.LSMOP9.__init__:27 of
msgid "**ref_num**"
msgstr "**ref_num**"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:14
#: evox.problems.numerical.lsmop.LSMOP2.__init__:14
#: evox.problems.numerical.lsmop.LSMOP3.__init__:14
#: evox.problems.numerical.lsmop.LSMOP4.__init__:14
#: evox.problems.numerical.lsmop.LSMOP5.__init__:14
#: evox.problems.numerical.lsmop.LSMOP6.__init__:14
#: evox.problems.numerical.lsmop.LSMOP7.__init__:14
#: evox.problems.numerical.lsmop.LSMOP8.__init__:14
#: evox.problems.numerical.lsmop.LSMOP9.__init__:14 of
msgid "ref_num * m is the Population of PF"
msgstr "ref_num * m 是 Pareto 前沿（PF）的种群数量"

#: ../../source/api/problems/numerical/test_suits/maf.rst:3
msgid "MaF Test Suit"
msgstr "MaF测试套件"

#: ../../source/api/problems/numerical/test_suits/zdt.rst:3
msgid "ZDT Test Suit"
msgstr "ZDT测试套件"

#: ../../source/api/workflows/distributed.rst:3
msgid "Ray-based Distributed Workflow"
msgstr "基于Ray的分布式工作流"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:2 of
msgid "Create a distributed workflow"
msgstr "创建分布式工作流"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:4 of
msgid ""
"Distributed workflow can distribute the workflow to different nodes, it "
"will create num_workers copies of the workflows with the same seed, and "
"at each step each workflow only evaluate part of the population, then "
"pass the fitness to other nodes to recreate the whole fitness array."
msgstr "分布式工作流能够将工作流程分布到不同的节点上。它会使用相同的随机种子创建num_workers个相同工作流程副本，并且在每一步中，每个工作流程仅评估种群的一部分，然后将适应度值传递给其他节点以重建整个适应度数组。这样，通过各节点间的协作，实现大规模并行计算和优化过程的高效执行。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:9 of
#, fuzzy
msgid "sol_transforms and fit_transforms are applied at each node,"
msgstr "适应度变换，这个变换在每个工作节点上应用。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:14
#: evox.workflows.non_jit_workflow.NonJitWorkflow.__init__:8
#: evox.workflows.std_workflow.StdWorkflow.__init__:8 of
msgid "**algorithm**"
msgstr "**算法**"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:14
#: evox.workflows.non_jit_workflow.NonJitWorkflow.__init__:8
#: evox.workflows.std_workflow.StdWorkflow.__init__:8 of
msgid "The algorithm."
msgstr "算法。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:17
#: evox.workflows.non_jit_workflow.NonJitWorkflow.__init__:11
#: evox.workflows.std_workflow.StdWorkflow.__init__:11 of
msgid "**problem**"
msgstr "**问题**"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:17
#: evox.workflows.non_jit_workflow.NonJitWorkflow.__init__:11
#: evox.workflows.std_workflow.StdWorkflow.__init__:11 of
msgid "The problem."
msgstr "问题。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:20 of
msgid "Number of workers."
msgstr "工作者的数目。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:24
#: evox.workflows.non_jit_workflow.NonJitWorkflow.__init__:18
#: evox.workflows.std_workflow.StdWorkflow.__init__:20 of
msgid "**opt_direction**"
msgstr "**opt_direction**"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:23
#: evox.workflows.non_jit_workflow.NonJitWorkflow.__init__:17
#: evox.workflows.std_workflow.StdWorkflow.__init__:19 of
msgid ""
"The optimization direction, can be either \"min\" or \"max\" or a list of"
" \"min\"/\"max\" to specific the direction for each objective."
msgstr "优化方向，可以是\"min\"（最小化）或\"max\"（最大化），也可以是一个包含\"min\"/\"max\"的列表来指定每个目标的具体优化方向。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:27 of
msgid "**options**"
msgstr "**options**"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:27 of
msgid "The runtime options of the worker actor."
msgstr "工作者（worker）actor的运行时选项。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:30 of
#, fuzzy
msgid "**sol_transforms:**"
msgstr "**pop_transform:**"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:30 of
msgid "Population transform, this transform is applied at each worker node."
msgstr "Population transform，这种转换会被应用到每一个worker节点。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:46 of
#, fuzzy
msgid "**fit_transforms:**"
msgstr "**fit_transform**"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:33 of
msgid "Fitness transform, this transform is applied at each worker node."
msgstr "适应度变换，这个变换在每个工作节点上应用。"

#: ../../source/api/workflows/index.rst:3
msgid "Workflows"
msgstr "工作流"

#: ../../source/api/workflows/non_jit.rst:3
#, fuzzy
msgid "Non-jit Workflow"
msgstr "UniWorkflow"

#: evox.workflows.non_jit_workflow.NonJitWorkflow.__init__:14
#: evox.workflows.std_workflow.StdWorkflow.__init__:16 of
msgid "**monitor**"
msgstr "**监控器**"

#: evox.workflows.non_jit_workflow.NonJitWorkflow.__init__:14 of
msgid "Optional monitor."
msgstr "可选监控器。"

#: evox.workflows.non_jit_workflow.NonJitWorkflow.__init__:25 of
#, fuzzy
msgid "**sol_transforms**"
msgstr "**pop_transform**"

#: evox.workflows.non_jit_workflow.NonJitWorkflow.__init__:21
#: evox.workflows.std_workflow.StdWorkflow.__init__:23 of
#, fuzzy
msgid ""
"Optional candidate solution transform function, usually used to decode "
"the candidate solution into the format that can be understood by the "
"problem. Should be a list of functions, and the functions will be applied"
" in the order of the list."
msgstr "可选种群变换函数，通常用于将种群解码为问题能够理解的格式。"

#: evox.workflows.non_jit_workflow.NonJitWorkflow.__init__:44
#: evox.workflows.std_workflow.StdWorkflow.__init__:33 of
#, fuzzy
msgid "**fit_transforms**"
msgstr "**fit_transform**"

#: evox.workflows.non_jit_workflow.NonJitWorkflow.__init__:28
#: evox.workflows.std_workflow.StdWorkflow.__init__:30 of
#, fuzzy
msgid ""
"Optional fitness transform function. usually used to apply fitness "
"shaping. Should be a list of functions, and the functions will be applied"
" in the order of the list."
msgstr "可选适应度变换函数，通常用于应用适应度整形。"

#: evox.workflows.non_jit_workflow.NonJitWorkflow.sample:2 of
msgid "Sample the algorithm but don't change it's state"
msgstr "对算法采样但不改变它的状态"

#: ../../source/api/workflows/standard.rst:3
msgid "Standard Workflow"
msgstr "标准工作流"

#: evox.workflows.std_workflow.StdWorkflow:2 of
msgid ""
"Experimental unified workflow, designed to provide unparallel performance"
" for EC workflow."
msgstr "实验中的统一workflow，设计目的是大幅提升EC的性能."

#: evox.workflows.std_workflow.StdWorkflow:5 of
msgid ""
"Provide automatic multi-device (e.g. multiple gpus) computation as well "
"as distributed computation using JAX's native components."
msgstr "提供自动多设备（例如，多个GPU）计算以及使用JAX的原生组件进行分布式计算。"

#: evox.workflows.std_workflow.StdWorkflow:8 of
msgid ""
"Monitor is called using JAX's asynchronous host callback, thus closing "
"the monitor is needed to wait for the callback to complete."
msgstr "监视器是使用JAX的异步主机回调调用的，因此需要关闭监视器以等待回调完成。"

#: evox.workflows.std_workflow.StdWorkflow.__init__:14 of
msgid ""
"Optional monitor(s). Configure a single monitor or a list of monitors. "
"The monitors will be called in the order of the list."
msgstr ""

#: evox.workflows.std_workflow.StdWorkflow.__init__:27 of
#, fuzzy
msgid "**sol_transform**"
msgstr "**pop_transform**"

#: evox.workflows.std_workflow.StdWorkflow.__init__:37 of
msgid "**jit_problem**"
msgstr "**jit_problem**"

#: evox.workflows.std_workflow.StdWorkflow.__init__:36 of
msgid "If the problem can be jit compiled by JAX or not. Default to True."
msgstr "问题是否可以通过JAX进行jit编译。默认为True。"

#: evox.workflows.std_workflow.StdWorkflow.__init__:56 of
msgid "**num_objectives**"
msgstr "**num_objectives**"

#: evox.workflows.std_workflow.StdWorkflow.__init__:40 of
msgid ""
"Number of objectives. When the problem can be jit compiled, this field is"
" not needed. When the problem cannot be jit compiled, this field should "
"be set, if not, default to 1."
msgstr "目标数量。当问题可以被 JIT（即时编译）时，这个字段不是必需的。当问题不能被 JIT 编译时，应设置这个字段，如果没有设置，默认为 1。"

#: evox.workflows.std_workflow.StdWorkflow.enable_distributed:2 of
msgid ""
"Enable the distributed workflow to run across multiple nodes. To use "
"jax's distribution ability, one need to run the same program on all nodes"
" with different parameters in `jax.distributed.initialize`."
msgstr ""
"启用分布式工作流在多个节点上运行。要使用 JAX 的分布式处理能力，需要在所有节点上运行相同的程序，并在 "
"jax.distributed.initialize 中使用不同的参数。"

#: evox.workflows.std_workflow.StdWorkflow.enable_distributed:16 of
msgid "The sharded state, distributed amoung all nodes."
msgstr "分布在所有节点上的分片状态。"

#: evox.workflows.std_workflow.StdWorkflow.enable_multi_devices:2 of
msgid "Enable the workflow to run on multiple local devices."
msgstr "允许workflow利用单台机器的多个设备（GPU）。"

#: evox.workflows.std_workflow.StdWorkflow.enable_multi_devices:12 of
msgid "**devices**"
msgstr "**设备**"

#: evox.workflows.std_workflow.StdWorkflow.enable_multi_devices:11 of
msgid "A list of devices. If set to None, all local devices will be used."
msgstr "设备列表。如果设置为“None”，将使用所有本地设备。"

#: evox.workflows.std_workflow.StdWorkflow.enable_multi_devices:17 of
msgid "The sharded state, distributed amoung all devices."
msgstr "分布在所有设备上的分片状态。"

#: ../../source/example/atari_pong.ipynb:10002
msgid "Solving Pong with EvoX"
msgstr "用EvoX解决Pong问题"

#: ../../source/example/atari_pong.ipynb:10005
msgid ""
"Running this notebook requires installing evox, gymnasium, ale-py as well"
" as Pong's image. Due to copy right issues, we cannot distribute the "
"image here. Please follow the instructions [here](https://github.com"
"/Farama-Foundation/AutoROM) to install the image."
msgstr ""
"运行这个文档需要先安装 evox，gymnasium，ale-"
"py以及Pong这个游戏的镜像文件。由于版权问题，我们无法在这里给出游戏镜像文件。请按照这里[AutoROM](https://github.com"
"/Farama-Foundation/AutoROM)的教程安装游戏镜像。"

#: ../../source/example/custom_algorithm_and_problem.ipynb:10002
msgid "Custom algorithm and problem"
msgstr "自定义算法和问题"

#: ../../source/example/custom_algorithm_and_problem.ipynb:10004
msgid ""
"This this notebook, we will show how to use the `Algorithm` and `Problem`"
" classes to create a custom algorithm and problem. We will use the one-"
"max problem as an example. The one-max problem is a simple problem where "
"the goal is to maximize the number of ones in a binary string. For "
"example, the string `01011` has a fitness of 3."
msgstr ""
"在这个文档中，我们将会展示如何通过`Algorithm`和`Problem`两个类来写一个自定义的算法和问题。我们将会以one-max问题为例"
"。one-max问题是一个非常简单的问题，这个问题的目标是最大化一个由0或1组成的字符串中1的数量。比如说字符串`01011`的适应度值是3。"

#: ../../source/example/gym_classic_control.ipynb:10002
msgid "Classic control with Gym"
msgstr "基于Gym的经典控制问题"

#: ../../source/example/gym_classic_control.ipynb:10004
msgid ""
"In this notebook, we will use the Gym to train an agent that solves "
"classic control problems."
msgstr "在这个文档里，我们会借助Gym来训练一个解决经典控制问题的智能体。"

#: ../../source/example/gym_classic_control.ipynb:70002
msgid "Now run the workflow. You may see warnings like"
msgstr "现在运行workflow。你可能会看到这样的警报"

#: ../../source/example/gym_classic_control.ipynb:70007
msgid ""
"This is expected behaivor, because we have a controller thread that "
"manages a group of Gym workers, and the controller thread does not use "
"GPU."
msgstr "这是预期的行为，因为我们有一个控制器线程来管理一组Gym工作线程，而控制器线程并不使用GPU。"

#: ../../source/example/gym_classic_control.ipynb:70010
msgid ""
"If the program stucks, you may want to check whether is `num_workers` is "
"larger than the number of available cores on your computer."
msgstr "如果程序卡住了，你可能需要检查 num_workers 设置的值是否大于你电脑上可用核心的数量。"

#: ../../source/example/index.md:1
msgid "EvoX's examples"
msgstr "EvoX的样例"

#: ../../source/example/pso_ackley.ipynb:10002
msgid "Numerical Optimization"
msgstr "数值优化"

#: ../../source/example/pso_ackley.ipynb:10004
msgid ""
"In this notebook, we will use the Particle Swarm Optimization (PSO) "
"algorithm to find the minimum of the Ackley function."
msgstr "在这个文档里，我们会使用粒子群算法来寻找Ackley测试问题的最小值。"

#: ../../source/guide/advanced/1-state.md:1
msgid "Working with state in EvoX"
msgstr "在EvoX中使用State"

#: ../../source/guide/advanced/1-state.md:3
#, fuzzy
msgid "EvoX is designed around stateful computation."
msgstr "EvoX是基于状态计算设计的。"

#: ../../source/guide/advanced/1-state.md:5
msgid ""
"There are two most fundamental classes, namely {class}`Stateful "
"<evox.Stateful>` and {class}`State <evox.State>`."
msgstr "有两个最基本的类，即 {class}Stateful <evox.Stateful> 和 {class}State <evox.State>。"

#: ../../source/guide/advanced/1-state.md:7
#, fuzzy
msgid ""
"All class that involves stateful computation are inherited from "
"`Stateful`. In EvoX, `Algorithm`, `Problem`, `Operator` and workflows are"
" all stateful."
msgstr ""
"所有涉及状态计算的类都继承自 "
"Stateful。在EvoX中，Algorithm（算法）、Problem（问题）、Operator（操作符）和工作流都是有状态的。"

#: ../../source/guide/advanced/1-state.md:9
msgid "The idea behind the design"
msgstr "设计背后的想法"

#: ../../source/guide/advanced/1-state.md:11
msgid "hierarchical state"
msgstr "分层状态"

#: ../../source/guide/advanced/1-state.md:16
#, fuzzy
msgid ""
"Here we have five different objects, and notice that they have a "
"hierarchical structure. To work with such structures, at each level, we "
"must \"lift the state\" by managing the states of child components. So, "
"the state at the `workflow` level must contain the state of both "
"`algorithm` and `problem`, and since the state at the `algorithm` level "
"must contain the state of both operators, the state `workflow` level "
"actually needs to handle states from all 5 components."
msgstr ""
"这里我们有五个不同的对象，注意它们具有层次结构。为了处理这种结构，在每个层级我们必须通过管理子组件的状态来“提升状态”。因此，workflow "
"层级的状态必须包含 algorithm（算法）和 problem（问题）的状态，由于 algorithm 层级的状态必须包含所有操作符的状态，所以"
" workflow 层级的状态实际上需要处理来自所有5个组件的状态。"

#: ../../source/guide/advanced/1-state.md:22
#, fuzzy
msgid ""
"However, it is frustrating to manage the hierarchy manually, and it is "
"not good for modular design. To solve this problem, we introduce "
"`Stateful` and `State`."
msgstr "然而，手动管理这种层次结构是令人沮丧的，而且不利于模块化设计。为了解决这个问题，我们引入了 Stateful 和 State。"

#: ../../source/guide/advanced/1-state.md:25
#, fuzzy
msgid "An Overview of Stateful"
msgstr "关于状态的概述"

#: ../../source/guide/advanced/1-state.md:27
#, fuzzy
msgid ""
"In a `Stateful` class, all immutable data are initialized in `__init__`, "
"the initial mutable state is generated in `setup`, besides these two "
"methods and private methods(start with \"\\_\"), all other methods are "
"wrapped with `use_state`."
msgstr ""
"在 Stateful 类中，所有不可变数据都在 __init__ 中初始化，初始的可变状态在 setup 中生成，除了这两个方法和私有方法（以 "
"\"_\" 开头）之外，所有其他方法都用 use_state 包装。"

#: ../../source/guide/advanced/1-state.md:48
msgid ""
"will be wrapped with `use_state` decorator. This decorator requires the "
"method have the following signature:"
msgstr "将会用 use_state 装饰器包装。这个装饰器要求方法具有以下签名："

#: ../../source/guide/advanced/1-state.md:54
#, fuzzy
msgid "which is a common pattern in stateful computation."
msgstr "这是状态计算中常见的模式。"

#: ../../source/guide/advanced/1-state.md:56
#, fuzzy
msgid ""
":::{warning} Currently, for all user-defined private methods, the name of"
" the method should start with `_``. :::"
msgstr ":::{警告} 目前，对于所有用户定义的私有方法，方法名称应该以 _ 开头。 :::"

#: ../../source/guide/advanced/1-state.md:60
msgid "An overview of State"
msgstr "关于状态的概述"

#: ../../source/guide/advanced/1-state.md:62
msgid ""
"In EvoX `State` represents a tree of states, which stores the state of "
"the current object and all child objects."
msgstr "在EvoX中，“State”代表一个状态树，它存储当前对象和所有子对象的状态。"

#: ../../source/guide/advanced/1-state.md:64
msgid "Combined together"
msgstr "结合一起"

#: ../../source/guide/advanced/1-state.md:66
#, fuzzy
msgid ""
"When combined together, they will automatically go 1 level down in the "
"tree of states, and merge the subtree back to the current level."
msgstr "当它们组合在一起时，将自动下降到状态树的下一层，并将子树合并回当前层。"

#: ../../source/guide/advanced/1-state.md:70
msgid "So you could write code like this."
msgstr "所以你可以这样写代码。"

#: ../../source/guide/advanced/1-state.md:81
msgid ""
"Notice that, when calling the method `step`, `state` is the state of the "
"workflow, but when calling `self.algorithm.ask`, `state` behaves like the"
" state of the algorithm, and after the call, the state of the algorithm "
"is automatically merged back into the state of the workflow."
msgstr ""
"请注意，当调用 step 方法时，state 是工作流的状态，但是当调用 self.algorithm.ask 时，state "
"的行为就像是算法的状态，调用之后，算法的状态会自动合并回工作流的状态。"

#: ../../source/guide/advanced/2-jit-able.md:1
msgid "Jit-able components"
msgstr "Jit-able 组件"

#: ../../source/guide/advanced/2-jit-able.md:3
msgid "A common pitfall in jit"
msgstr "jit中常见的一个陷阱"

#: ../../source/guide/advanced/2-jit-able.md:5
msgid ""
"In JAX, it's hard to jump out of a jit-compiled function, meaning if you "
"jit-compile one function, then all other functions used within this "
"function must also be jit-compiled."
msgstr ""
"在 JAX 中，跳出一个 JIT 编译的函数是困难的，这意味着如果你 JIT 编译了一个函数，那么在这个函数内部使用的所有其他函数也必须被 JIT"
" 编译。"

#: ../../source/guide/advanced/2-jit-able.md:8
#, fuzzy
msgid "For example, the following code will result in a compilation error."
msgstr "例如，下面的代码将导致编译错误"

#: ../../source/guide/advanced/2-jit-able.md:19
#, fuzzy
msgid ""
"Even though `bar` is not marked with `jax.jit`, it is still compiled as "
"`foo` calls `bar`. And since `bar` uses the dynamic index, which is not "
"compatible with `jax.jit`, an error will occur."
msgstr ""
"尽管 bar 没有被标记为 jax.jit，但由于 foo 调用了 bar，它仍然会被编译。由于 bar 使用了动态索引，这与 jax.jit "
"不兼容，因此会发生错误。"

#: ../../source/guide/advanced/2-jit-able.md:22
msgid "Solution"
msgstr "解决方案"

#: ../../source/guide/advanced/2-jit-able.md:24
#, fuzzy
msgid ""
"To solve is problem, it is common practice to jit-compile low-level "
"components, thus giving high-level components more freedom. In EvoX, we "
"have some general rules on whether a function should be jit-able or not."
msgstr ""
"为了解决这个问题，通常的做法是 JIT 编译低层组件，从而给高层组件更多的自由。在 EvoX 中，我们有一些关于函数是否应该是可 JIT "
"编译的通用规则。"

#: ../../source/guide/advanced/2-jit-able.md
msgid "Component"
msgstr "组件"

#: ../../source/guide/advanced/2-jit-able.md
msgid "jit-able"
msgstr "可以被jit编译的"

#: ../../source/guide/advanced/2-jit-able.md
#, fuzzy
msgid "`Workflow`"
msgstr "工作流"

#: ../../source/guide/advanced/2-jit-able.md
msgid "Optional"
msgstr "可选的"

#: ../../source/guide/advanced/2-jit-able.md
#, fuzzy
msgid "`Algorithm`"
msgstr "算法"

#: ../../source/guide/advanced/2-jit-able.md
msgid "Yes"
msgstr "是的"

#: ../../source/guide/advanced/2-jit-able.md
#, fuzzy
msgid "`Problem`"
msgstr "问题"

#: ../../source/guide/advanced/2-jit-able.md
#, fuzzy
msgid "`Operators`"
msgstr "操作符"

#: ../../source/guide/advanced/2-jit-able.md
#, fuzzy
msgid "`Monitor`"
msgstr "监控器"

#: ../../source/guide/advanced/2-jit-able.md
msgid "No"
msgstr "不是"

#: ../../source/guide/advanced/2-jit-able.md:35
msgid ""
"For standard workflow, one can jit compile when not using monitors and "
"working with jit-able problems. But even though the workflow can be "
"compiled, there isn't much performance gain. For problems, it depends on "
"the task."
msgstr ""
"对于标准工作流，当不使用监视器并且处理可 JIT 编译的问题时，可以进行 JIT "
"编译。但即使工作流可以被编译，性能提升也不大。对于问题，这取决于任务。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:7
msgid "Custom algorithms and problems in EvoX"
msgstr "EvoX中的自定义算法和问题"

#: ../../source/guide/advanced/3-custom-alg-pro.md:9
msgid ""
"In this chapter, we will introduce how to implement your own algorithm in"
" EvoX."
msgstr "在本章中，我们将介绍如何在 EvoX 中实现您自己的算法。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:11
msgid "The Algorithm Class"
msgstr "算法类"

#: ../../source/guide/advanced/3-custom-alg-pro.md:13
#, fuzzy
msgid ""
"The {class}`Algorithm <evox.Algorithm>` class is inherited from "
"{class}`Stateful <evox.Stateful>`. Besides the things in `Stateful`, you "
"should also implement an `ask` and a `tell` method. In total, there are "
"four methods one needs to implement."
msgstr ""
"{class}Algorithm <evox.Algorithm> 类继承自 {class}Stateful <evox.Stateful>。除了"
" Stateful 中的内容外，您还应该实现一个 ask 方法和一个 tell 方法。总共有四个方法需要实现。"

#: ../../source/guide/advanced/3-custom-alg-pro.md
#: ../../source/guide/advanced/3-custom-alg-pro.md:88
msgid "Method"
msgstr "方法"

#: ../../source/guide/advanced/3-custom-alg-pro.md
#: ../../source/guide/advanced/3-custom-alg-pro.md:88
msgid "Signature"
msgstr "签名"

#: ../../source/guide/advanced/3-custom-alg-pro.md
#: ../../source/guide/advanced/3-custom-alg-pro.md:88
msgid "Usage"
msgstr "使用情况"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "\\_\\_init\\_\\_"
msgstr "\\_\\_init\\_\\_"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "{python}`(self, ...)`"
msgstr "{python}`(self, ...)`"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid ""
"Initialize hyperparameters that are fixed though out the optimization "
"process, for example, the `population size`."
msgstr "初始化在整个优化过程中固定的超参数，例如，`population size`。"

#: ../../source/guide/advanced/3-custom-alg-pro.md
#: ../../source/guide/advanced/3-custom-alg-pro.md:92
msgid "setup"
msgstr "设置"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "{python}`(self, RRNGKey) -> State`"
msgstr "{python}`(self, RRNGKey) -> State`"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "Initialize mutable state, for example the `momentum`."
msgstr "初始化可变状态，例如`momentum`。"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "ask"
msgstr "ask"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "{python}`(self, State) -> Array, State`"
msgstr "{python}`(self, State) -> Array, State`"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "Gives a candidate population for evaluation."
msgstr "给出用于评估的候选种群。"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "tell"
msgstr "tell"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "{python}`(self, State, Array) -> State`"
msgstr "{python}`(self, State, Array) -> State`"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid ""
"Receive the fitness for the candidate population and update the "
"algorithm's state."
msgstr "接收候选种群的适应度并更新算法的状态。"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "init_ask (Optional)"
msgstr "init_ask (可选的)"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid ""
"Gives initial population for evaluation. The population can have "
"different shape than `ask`."
msgstr "提供用于评估的初始种群。种群的形状可以与`ask`不同。"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "init_tell (Optional)"
msgstr "init_tell (可选的 )"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid ""
"Receive the fitness for the initial population and update the algorithm's"
" state."
msgstr "接收初始种群的适应度并更新算法的状态。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:26
#: ../../source/guide/advanced/3-custom-alg-pro.md:81
#, fuzzy
msgid "Migrate from traditional EC libraries"
msgstr "迁移自传统的EC库"

#: ../../source/guide/advanced/3-custom-alg-pro.md:28
#, fuzzy
msgid ""
"In a traditional EC library, algorithms usually call the objective "
"function internally, which gives the following layout"
msgstr "在传统的EC库中，算法通常在内部调用目标函数，其布局如下"

#: ../../source/guide/advanced/3-custom-alg-pro.md:36
msgid "But in EvoX, we have a flat layout"
msgstr "但在 EvoX 中，我们采用了扁平布局"

#: ../../source/guide/advanced/3-custom-alg-pro.md:42
msgid "Here is a pseudocode of a genetic algorithm."
msgstr "这是一个遗传算法的伪代码。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:57
#, fuzzy
msgid "And here is what each part of the algorithm corresponds to in EvoX."
msgstr "这里是算法的每个部分在 EvoX 中对应的内容。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:77
msgid "The Problem Class"
msgstr "问题类"

#: ../../source/guide/advanced/3-custom-alg-pro.md:79
#, fuzzy
msgid ""
"The Problem class is quite simple, beside `__init__` and `setup`, the "
"only required method is `evaluate``."
msgstr "`Problem` 类相当简单，除了 `__init__` 和 `setup`，唯一必需的方法是 `evaluate`。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:83
#, fuzzy
msgid ""
"There is one thing to notice here, `evaluate` is a stateful function, "
"meaning it should accept a state and return a new state. So, if you are "
"working with numerical benchmark functions, which don't need to be "
"stateful, you can simply ignore the state, but remember that you still "
"have to use this stateful interface."
msgstr ""
"这里有一点需要注意，`evaluate` "
"是一个有状态的函数，这意味着它应该接受一个状态并返回一个新状态。所以，如果你正在处理不需要有状态的数值基准函数，你可以简单地忽略状态，但请记住，你仍然需要使用这个有状态的接口。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:90
msgid "__init__"
msgstr "__init__"

#: ../../source/guide/advanced/3-custom-alg-pro.md:90
msgid ":python:`(self, ...)`"
msgstr ":python:`(self, ...)`"

#: ../../source/guide/advanced/3-custom-alg-pro.md:90
msgid "Initialize the settings of the problem."
msgstr "为问题初始化设置。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:92
msgid ":python:`(self, RRNGKey) -> State`"
msgstr ":python:`(self, RRNGKey) -> State`"

#: ../../source/guide/advanced/3-custom-alg-pro.md:92
msgid "Initialize mutable state of this problem."
msgstr "初始化这个问题的可变状态。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:94
msgid "evaluate"
msgstr "评估"

#: ../../source/guide/advanced/3-custom-alg-pro.md:94
msgid ":python:`(self, State, Array) -> Array, State`"
msgstr ":python:`(self, State, Array) -> Array, State`"

#: ../../source/guide/advanced/3-custom-alg-pro.md:94
msgid "Evaluate the fitness of the given candidate solution."
msgstr "评估给定候选解的适应度。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:98
msgid "More on the problem's state"
msgstr "关于问题的状态的更多信息"

#: ../../source/guide/advanced/3-custom-alg-pro.md:100
#, fuzzy
msgid ""
"If you still wonder what the problem's state actually does, here are the "
"explanations."
msgstr "如果您仍然想知道问题的状态实际上是做什么的，以下是解释。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:102
#, fuzzy
msgid ""
"Unlike numerical benchmark functions, real-life problems are more complex"
" and may require stateful computations. Here are some examples:"
msgstr "与数值基准函数不同，现实生活中的问题更加复杂，可能需要有状态的计算。以下是一些例子："

#: ../../source/guide/advanced/3-custom-alg-pro.md:105
#, fuzzy
msgid ""
"When dealing with ANN training, we often have the training, validation "
"and testing phases. This implies that the same solution could have "
"different fitness values during different phases. So clearly, we can't "
"model the `evaluate` as a stateless pure function anymore. To implement "
"this mechanism, simply put a value in the state to indicate the phase."
msgstr "在处理人工神经网络(ANN)训练时，我们通常有训练、验证和测试阶段。这意味着同一个解决方案在不同阶段可能有不同的适应度值。因此，显然我们不能再将`evaluate`建模为一个无状态的纯函数。要实现这种机制，只需在状态中放置一个值来指示阶段。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:109
#, fuzzy
msgid ""
"Virtual batch norm is an effective trick especially when dealing with RL "
"tasks. To implement this mechanism, the problem must be stateful, as the "
"problem has to remember the initial batch norm parameters during the "
"first run."
msgstr "虚拟批量归一化是一个有效的技巧，特别是在处理强化学习(RL)任务时。要实现这种机制，问题必须是有状态的，因为问题需要记住第一次运行时的初始批量归一化参数。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:113
msgid "Example"
msgstr "样例"

#: ../../source/guide/advanced/3-custom-alg-pro.md:115
#, fuzzy
msgid ""
"Here we give an example of implementing the OneMax problem, along with a "
"genetic algorithm that solves this problem. The problem itself is "
"straightforward, the fitness is defined as the sum of every digit in a "
"fixed-length bitstring. For example, \"100111\" gives 4 and \"000101\" "
"gives 2."
msgstr ""
"这里我们给出了一个实现 OneMax "
"问题的例子，以及解决这个问题的遗传算法。这个问题本身很直接，适应度定义为固定长度比特串中每个数字的总和。例如，\"100111\" 的适应度是 "
"4，而 \"000101\" 的适应度是 2。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:119
#, fuzzy
msgid ""
"Let's start with implementing the OneMax problem. In JAX a bitstring can "
"be easily represented with a tensor of type bool."
msgstr "让我们从实现 OneMax 问题开始。在 JAX 中，比特串可以很容易地用布尔类型的张量来表示。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:144
msgid ""
"Then we implement a genetic algorithm that uses bitflip mutation and one-"
"point crossover."
msgstr "然后我们实现了一个遗传算法，使用位翻转变异和单点交叉。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:204
msgid "Now, you can assemble a workflow and run it."
msgstr "现在你可以组合出一个workflow并运行。"

#: ../../source/guide/advanced/4-container.md:1
msgid "Container Algorithms"
msgstr "容器算法"

#: ../../source/guide/advanced/4-container.md:3
#, fuzzy
msgid ""
"Container algorithms are a special type of algorithms that work by "
"containing other algorithms and cannot work on their own. Container "
"algorithms can be used to compose a series of normal algorithms together."
msgstr "容器算法是一种特殊类型的算法，通过包含其他算法来工作，不能单独工作。容器算法可以用来将一系列普通算法组合在一起。"

#: ../../source/guide/advanced/4-container.md:6
msgid "Working with expensive algorithms"
msgstr "处理高成本算法"

#: ../../source/guide/advanced/4-container.md:8
#, fuzzy
msgid ""
"Many algorithms are expensive in terms of space or time. For example, "
"CMA-ES requires $O(N^2)$ space. Thus, it is costly to run CMA-ES on high-"
"dimension problems. Sep-CMA-ES scales better but sacrifices the "
"performance. That's where the container algorithm comes in. With it, we "
"can easily construct a variant of CMA-ES that uses $O((\\frac{N}{M})^2)$ "
"space, where $M$ is the number of blocks. This variant is a balance "
"between the normal CMA-ES and Sep-CMA-ES."
msgstr ""
"许多算法在空间或时间方面的成本都很高。例如，CMA-ES需要$O(N^2)$的空间。因此，在高维问题上运行CMA-ES的成本很高。Sep-CMA-"
"ES的扩展性更好，但牺牲了性能。这就是容器算法的用武之地。有了它，我们可以轻松构建一个使用$O((\\frac{N}{M})^2)$空间的CMA-"
"ES变体，其中$M$是块的数量。这种变体是普通CMA-ES和Sep-CMA-ES之间的平衡。"

#: ../../source/guide/advanced/4-container.md:15
msgid "Working with PyTree"
msgstr "处理 PyTree"

#: ../../source/guide/advanced/4-container.md:17
msgid ""
"Usually, algorithms expect the decision variables to be in the form of a "
"1D-vector. PyTrees are tree-like structures that are not directly "
"compatible with normal algorithms. So, there are two solutions out there:"
msgstr "一般来说，算法期望决策变量以一维形式呈现。但是Pytrees是树类结构不能直接与常见的算法兼容。所以这里有两种解决方法："

#: ../../source/guide/advanced/4-container.md:21
msgid "Flatten the PyTree to 1D-vector."
msgstr "将Pytree平展成一维向量。"

#: ../../source/guide/advanced/4-container.md:22
msgid "Use a specialized algorithm that work with PyTree directly."
msgstr "使用经过特殊化算法来直接处理Pytree。"

#: ../../source/guide/advanced/4-container.md:24
msgid ""
"Solution 1 is called `adapter` in EvoX, which is quite simple, but we are"
" not talking about this here. Solution 2 seems more complicated, but the "
"advantage is that the structural information is preserved, meaning the "
"algorithm could see the tree structure and apply some type of heuristic "
"here."
msgstr "在EvoX中方法1被命名为adapter并且非常简单，这里不再进行赘述。方法2更为复杂，但是保留原本的信息结构是他的一个优点，这意味着算法可以知道树的结构并且在此使用某种类型的启发式算法。"

#: ../../source/guide/advanced/4-container.md:30
#, fuzzy
msgid ""
"We offer Cooperative Coevolution (CC) framework for all algorithms. "
"Currently, there are two types of CC container in EvoX, "
"{class}`evox.algorithms.Coevolution` and "
"{class}`evox.algorithms.VectorizedCoevolution`. The difference is that "
"`VectorizedCoevolution` updates all sub-populations at the same time in "
"each iteration, but `Coevolution` follows the traditional approach that "
"updates a single sub-populations at each iteration. Thus "
"`VectorizedCoevolution` is faster, but `Coevolution` could be better in "
"terms of best fitness with a limited number of evaluations."
msgstr ""
"我们为所有的算法提供了协同演化（CC）框架。目前，再EvoX中有两种类型的CC容器，分别是{class}`evox.algorithms.Coevolution`"
" 和 "
"{class}`evox.algorithms.VectorizedCoevolution`。两者的不同在于`VectorizedCoevolution`在每次迭代的同时更新所有子代，而`Coevolution`沿用传统的方法在每迭代时更新单个子代。因此`VectorizedCoevolution`"
" 更快，但是`Coevolution`在有限数量的评估下最佳适应度方案可能会更好。"

#: ../../source/guide/advanced/index.md:1
msgid "Advanced Tutorial"
msgstr "进阶教程"

#: ../../source/guide/basics/1-start.ipynb:10002
msgid "Quick Start"
msgstr "快速开始"

#: ../../source/guide/basics/1-start.ipynb:10004
msgid "In this notebook, we will guide you through the basic steps of using EvoX."
msgstr ""

#: ../../source/guide/basics/1-start.ipynb:40002
msgid "Create an algorithm and a problem"
msgstr "创建一个算法和一个问题"

#: ../../source/guide/basics/1-start.ipynb:50002
msgid "To demostrate, we will create a PSO algorithm and an Ackley function."
msgstr "我们将创建一个PSO算法和一个Ackley函数来进行证明。"

#: ../../source/guide/basics/1-start.ipynb:50004
msgid ""
"For more detailed list, please refer to our API documentation. [List of "
"Algorithms](https://evox.readthedocs.io/en/latest/api/algorithms/index.html)"
" and [List of "
"Problems](https://evox.readthedocs.io/en/latest/api/problems/index.html)."
msgstr ""
"有关更详细的列表，请参阅我们的 API "
"文档。[算法列表](https://evox.readthedocs.io/en/latest/api/algorithms/index.html)"
" 和 [问题列表](https://evox.readthedocs.io/en/latest/api/problems/index.html)。"

#: ../../source/guide/basics/1-start.ipynb:70002
msgid ""
"Now we want to run the algorithm against the problem. To accomplish this,"
" we need to create a `workflow` which represents the overall process of "
"evolutionary computation."
msgstr "现在我们想要运行针对问题的算法。为了实现这一点，我们需要创建一个代表进化计算整体过程的`workflow`。"

#: ../../source/guide/basics/1-start.ipynb:90002
msgid ""
"Since we adopt the functional programming paradigm. We must explicitly "
"initialize and use the state of a module. To initialize, call `init` with"
" a pseudorandom number generators key (PRNGKey)."
msgstr "由于我们采用了函数式编程范式。我们必须显式地初始化并使用模块的状态。要进行初始化，使用伪随机数生成器的键（PRNGKey）调用`init`。"

#: ../../source/guide/basics/1-start.ipynb:110002
msgid ""
"The `state` represents the mutatable variables within the whole workflow,"
" including those inside the algorithm and the problem. For example, the "
"`population` in an algorithm is part of the `state`, because it will be "
"changing across iterations."
msgstr ""
"`state`代表整个工作流中的可变变量，包括算法和问题内部的变量。例如，算法中的`population`（种群）是 state "
"的一部分，因为它会在迭代过程中发生变化。"

#: ../../source/guide/basics/1-start.ipynb:120002
msgid "Now, call `step` on the workflow to execute one iteration."
msgstr "现在，调用工作流上的 `step` 来执行一个迭代。"

#: ../../source/guide/basics/1-start.ipynb:140002
msgid "To run multiple iterations, wrap it inside a for-loop."
msgstr "想要执行多次迭代，只要在这外面套一个for循环即可。"

#: ../../source/guide/basics/1-start.ipynb:160002
msgid ""
"Notice that we are passing `state` as an argument of `step` and it "
"returns a new `state`. This is exactly how the stateful computation works"
" in functional programming."
msgstr "请注意，我们将 `state` 作为 `step` 的一个参数传递，并且它返回一个新的 `state`。这正是函数式编程中有状态计算的工作方式。"

#: ../../source/guide/basics/1-start.ipynb:170002
msgid ""
"And you may also notice that the `step` doesn't give any feedback, like "
"the result of the optimization. This is because we are missing another "
"component in our workflow. Introducing `monitor`."
msgstr "你可能还会注意到，`step` 并没有提供任何反馈，比如优化的结果。这是因为我们的工作流中缺少另一个组件。这里介绍 `monitor`（监视器）。"

#: ../../source/guide/basics/1-start.ipynb:180002
msgid "Monitor"
msgstr "监控器"

#: ../../source/guide/basics/1-start.ipynb:180004
msgid ""
"Monitor is a standard way to monitor the intermediate values inside a "
"optimization process. Information like fitness or population can be "
"easily obtained by the monitor."
msgstr "监视器是监控优化过程中中间值的标准方法。像适应度或种群这样的信息可以通过监视器轻松获得。"

#: ../../source/guide/basics/1-start.ipynb:190002
msgid "Now, create a \"Standard single-objective monitor\""
msgstr "现在，创建一个“标准单目标监视器”"

#: ../../source/guide/basics/1-start.ipynb:210002
msgid "The monitor can be plugged into the workflow."
msgstr "监视器可以插入到工作流中。"

#: ../../source/guide/basics/1-start.ipynb:230002
msgid "Now, re-initialize the workflow, and executed it again."
msgstr "现在，重新初始化工作流，并再次执行它。"

#: ../../source/guide/basics/1-start.ipynb:250002
msgid ""
"This time, we can access the minimum fitness achieved through the "
"`monitor`."
msgstr "这次，我们可以通过 `monitor` 访问达到的最小适应度。"

#: ../../source/guide/basics/1-start.ipynb:270002
msgid ""
"Execute another 5 iterations, and the minimum fitness will change "
"accordingly."
msgstr "再执行5次迭代，最小适应度将相应改变。"

#: ../../source/guide/basics/1-start.ipynb:290002
msgid ""
"To record information related to the population as well, turn on "
"`record_pop` option in the workflow."
msgstr "要同时记录与种群相关的信息，请在工作流中打开 `record_pop` 选项。"

#: ../../source/guide/basics/1-start.ipynb:290004
msgid ""
"This will cause the population be sent to the monitor as well, and the "
"monitor can then determine the best solution on the fly."
msgstr "这将导致种群也被发送到监视器，监视器随后可以即时确定最佳解决方案。"

#: ../../source/guide/basics/1-start.ipynb:290006
msgid ""
"Please note that when the population size is very large, is option can "
"harm the overall performance."
msgstr "请注意，当种群规模非常大时，这个选项可能会影响整体性能。"

#: ../../source/guide/basics/1-start.ipynb:330002
msgid ""
"It show the best solution is (-0.02271652, -0.19201761), which is close "
"to the global minimum at (0,0). 🥳"
msgstr "它显示最佳解为 (-0.02271652, -0.19201761)，这接近于全局最小值 (0,0)。🥳"

#: ../../source/guide/basics/1-start.ipynb:330004
msgid ""
"Additionally, please note that the best fitness remains the same as last "
"time. This is because we are using the same `key` when initializing the "
"workflow as before. This deterministic behavior in EvoX allows others to "
"easily reproduce your results."
msgstr ""
"另外，请注意最佳适应度与上次相同。这是因为我们在初始化工作流程时使用了与之前相同的 "
"`key`。EvoX中的这种确定性行为使其他人可以轻松复现你的结果。"

#: ../../source/guide/basics/2-problems.ipynb:10002
msgid "Working with extended applications"
msgstr "处理扩展应用"

#: ../../source/guide/basics/2-problems.ipynb:10004
msgid "Working with extended applications in EvoX is easy."
msgstr "在EvoX中处理扩展应用很简单。"

#: ../../source/guide/basics/2-problems.ipynb:40002
msgid "Neuroevolution Tasks"
msgstr "神经演化任务"

#: ../../source/guide/basics/2-problems.ipynb:40004
msgid ""
"Here we will be focusing on neuroevolution tasks, where one need to "
"evolve a neural network that suits a certain tasks."
msgstr "在这里，我们将专注于神经进化任务，其中需要进化出适合特定任务的神经网络。"

#: ../../source/guide/basics/2-problems.ipynb:50002
msgid "Brax"
msgstr "Brax"

#: ../../source/guide/basics/2-problems.ipynb:50004
msgid ""
"To begin with we will be using Brax, a GPU accelerated physical engine "
"that is also written in JAX. Since Brax is also using JAX, running EvoX "
"with Brax is quite easy."
msgstr "首先，我们将使用Brax，这是一个用JAX编写的GPU加速物理引擎。由于Brax也使用JAX，因此将EvoX与Brax一起运行相当容易。"

#: ../../source/guide/basics/2-problems.ipynb:50007
msgid "We will be demostrating using the \"swimmer\" environment in Brax."
msgstr "我们将演示在Brax中使用“swimmer”环境。"

#: ../../source/guide/basics/2-problems.ipynb:60002
msgid ""
"First we will need to decide how we are going to evolve a neural network."
" In this case, we will be using a fixed-size ANN, and only evolve it's "
"weights."
msgstr "首先，我们需要决定如何进化神经网络。在这种情况下，我们将使用固定大小的人工神经网络（ANN），并仅进化其权重。"

#: ../../source/guide/basics/2-problems.ipynb:90002
msgid ""
"However, if we check the weights for this network, we will see that it's "
"group of parameter sets, and EC algorithms cannot directly work with data"
" in this format."
msgstr "然而，如果我们检查这个网络的权重，我们会发现它是一组参数集，而进化计算（EC）算法无法直接处理这种格式的数据。"

#: ../../source/guide/basics/2-problems.ipynb:90005
msgid ""
"Thankfully, EvoX provides some useful utilities to help us bridge the "
"gap, and in this case, we have `TreeAndVector` to help us convert a tree-"
"like struct into a vector and back."
msgstr "幸运的是，EvoX提供了一些有用的工具来帮助我们弥合这一差距，在这种情况下，我们有`TreeAndVector`来帮助我们将树状结构转换成向量，然后再转换回来。"

#: ../../source/guide/basics/2-problems.ipynb:110002
msgid "Now, `adapter` can help us convert the data back-and-forth."
msgstr "现在`adapter`可以帮助我们来回转换数据格式。"

#: ../../source/guide/basics/2-problems.ipynb:110004
msgid "`to_vector` can convert a tree into a vector."
msgstr "`to_vector` 可以将树转化成向量形式。"

#: ../../source/guide/basics/2-problems.ipynb:110005
msgid "`to_tree` can convert a vector back to a tree."
msgstr "`to_tree` 可以把向量转化回树的形式。"

#: ../../source/guide/basics/2-problems.ipynb:110007
msgid "There are also batched version conversion."
msgstr "还有批量版本的转换。"

#: ../../source/guide/basics/2-problems.ipynb:110009
msgid "`batched_to_vector` can convert a batch of trees into a batch of vectors."
msgstr "`batched_to_vector`可以将一批树状结构转换为一批向量。"

#: ../../source/guide/basics/2-problems.ipynb:110010
msgid "`batched_to_tree` can convert a batch of vectors into a batch of trees."
msgstr "`batched_to_tree` 可以将一批向量转换为一批树状结构。"

#: ../../source/guide/basics/2-problems.ipynb:130002
msgid "Now we can create an algorithm object."
msgstr "现在我们可以创建一个算法对象。"

#: ../../source/guide/basics/2-problems.ipynb:150002
msgid ""
"Now create brax-based problem. The `batch_size` defines how many "
"environment in a single batch,  and `cap_episode` controls when to "
"truncate the episode."
msgstr "现在创建基于Brax的问题。`batch_size` 定义了单个批次中有多少个环境，而 `cap_episode` 控制了何时截断一个情节。"

#: ../../source/guide/basics/2-problems.ipynb:150006
msgid ""
"In this case, we set `batch_size` to 4096, which is the same as our "
"population size. This means the whole population will be evaluated in a "
"single pass!"
msgstr "在这种情况下，我们将 `batch_size` 设置为4096，这与我们的种群大小相同。这意味着整个种群将在一次传递中被评估！"

#: ../../source/guide/basics/2-problems.ipynb:170002
msgid "Assemble our workflow and fire it!"
msgstr "组装我们的工作流程并启动它！"

#: ../../source/guide/basics/2-problems.ipynb:170004
#, fuzzy
msgid ""
"Notice the `sol_transforms` option. It's used to convert the candidate "
"solutions into the tree-like structure that representing a neural "
"network's weight."
msgstr "请注意 `pop_transform` 选项。它用于将种群转换成表示神经网络权重的树状结构。"

#: ../../source/guide/basics/3-distributed.md:1
msgid "Distribute the workflow"
msgstr "分发工作流程"

#: ../../source/guide/basics/3-distributed.md:3
msgid ""
"EvoX provides two distributed workflow implementation, one is based on "
"Ray, and the other one is based on jax.distribute."
msgstr "EvoX 提供了两种分布式工作流实现，一种基于 Ray，另一种基于 jax.distribute。"

#: ../../source/guide/basics/3-distributed.md:5
msgid "RayDistributedWorkflow"
msgstr "RayDistributedWorkflow"

#: ../../source/guide/basics/3-distributed.md:7
msgid ""
"RayDistributedWorkflow is built upon Ray. It can be used on any ray "
"cluster. The Ray cluster should be setup before running the EvoX program."
msgstr "RayDistributedWorkflow是基于Ray构建的。它可以在任何Ray集群上使用。在运行EvoX程序之前，应该先设置Ray集群。"

#: ../../source/guide/basics/3-distributed.md:9
msgid "Setup Ray cluster"
msgstr "设置Ray集群"

#: ../../source/guide/basics/3-distributed.md:11
#, fuzzy
msgid ""
"Please refer to [Ray's official "
"documentation](https://docs.ray.io/en/latest/cluster/getting-"
"started.html) for guide on setting up an Ray cluster."
msgstr ""
"请参考Ray的官方文档(https://docs.ray.io/en/latest/cluster/getting-"
"started.html)来获取关于设置Ray集群的指南。"

#: ../../source/guide/basics/3-distributed.md:13
msgid "Here is a simple way to setup the cluster locally."
msgstr "这里有一个简单的本地集群搭建方法。"

#: ../../source/guide/basics/3-distributed.md:15
msgid "On the head node"
msgstr "在头节点上"

#: ../../source/guide/basics/3-distributed.md:19
msgid "On worker nodes"
msgstr "在工作节点上"

#: ../../source/guide/basics/3-distributed.md:24
#, fuzzy
msgid ""
"If you only have 1 machine, but multiple devices, then there is nothing "
"needs to be done. Ray will setup itself in this case."
msgstr "如果你只有一台机器但是有多个设备，这种情况下，不需要进行别的设置，Ray会自行进行配置。"

#: ../../source/guide/basics/3-distributed.md:26
#: ../../source/guide/basics/3-distributed.md:72
#, fuzzy
msgid "Setup EvoX"
msgstr "设置 EvoX"

#: ../../source/guide/basics/3-distributed.md:28
msgid ""
"To scale the workflow using multiple machines through Ray, use the "
"{class}`RayDistributedWorkflow <evox.workflows.RayDistributedWorkflow>` "
"instead of StdWorkflow."
msgstr ""
"要通过Ray使用多台机器扩展工作流，请使用 {class}`RayDistributedWorkflow <evox."
"workflows.RayDistributedWorkflow>` 类替代标准工作流StdWorkflow。"

#: ../../source/guide/basics/3-distributed.md:30
msgid "First, import `workflows` from evox"
msgstr "首先，从evox中导入'workflows'"

#: ../../source/guide/basics/3-distributed.md:36
msgid "then create your algorithm, problem, monitor object as usual."
msgstr "接下来创建algorithm，problem，monitor对象。"

#: ../../source/guide/basics/3-distributed.md:44
msgid "Now use `RayDistributedWorkflow`"
msgstr "现在使用 `RayDistributedWorkflow`"

#: ../../source/guide/basics/3-distributed.md:57
msgid ""
"The `RayDistributedWorkflow` also uses the `workflow.step` function to "
"execute iterations. However, under the hood, it employs a distinct "
"approach that allows for the utilization of multiple devices across "
"different machines."
msgstr ""
"`RayDistributedWorkflow`同样运用 "
"`workflow.step`函数来执行迭代过程。然而，在底层实现上，它采用了一种独特的方法，能够跨多台机器利用多个设备。"

#: ../../source/guide/basics/3-distributed.md:60
#, python-format
msgid ""
"It is recommanded that one set the environment variable "
"`XLA_PYTHON_CLIENT_PREALLOCATE=false`. By default JAX will pre-allocate "
"80% of the device's memory. This variable disables the GPU memory "
"preallocation, otherwise running multiple JAX processes may cause OOM. "
"For more information, please refer to [JAX's "
"documentation](https://jax.readthedocs.io/en/latest/gpu_memory_allocation.html)"
" on this matter."
msgstr ""
"建议设置环境变量XLA_PYTHON_CLIENT_PREALLOCATE=false。默认情况下，JAX会预先分配设备内存的80%。此变量用于禁用GPU内存预分配，否则运行多个JAX进程可能会导致内存不足（OOM）。有关此事项的更多信息，请参考JAX的文档(https://jax.readthedocs.io/en/latest/gpu_memory_allocation.html)"
" 。"

#: ../../source/guide/basics/3-distributed.md:66
#, fuzzy
msgid "StdWorkflow"
msgstr "工作流"

#: ../../source/guide/basics/3-distributed.md:68
#, fuzzy
msgid ""
"StdWorkflow is short for \"Universal Workflow\", which aims to use pure "
"JAX to build a workflow that fits any requirement. Since `StdWorkflow` is"
" written in pure JAX, it has less overhead and don't need any additional "
"dependencies."
msgstr ""
"\"UniWorkflow\"是“Universal "
"Workflow”的缩写，其目的是使用纯JAX构建一个适应任何需求的工作流。由于UniWorkflow是用纯JAX编写的，它的开销较小，不需要任何额外的依赖。"

#: ../../source/guide/basics/3-distributed.md:74
#, fuzzy
msgid ""
"Use `StdWorkflow` to create an workflow, and use `enable_distributed` and"
" pass in the state to enable this feature."
msgstr "使用'UniWorkflow'创建一个工作流然后使用'enable_distributed'并且传入相应状态来启用此功能。"

#: ../../source/guide/basics/3-distributed.md:90
msgid ""
"Then, at the start of your program, before any JAX function is called, do"
" this:"
msgstr "在你的程序开始之前进行的任何JAX函数调用，需要做这些操作："

#: ../../source/guide/basics/3-distributed.md:96
msgid ""
"In this system, the `coordinator` serves as the primary or head node. The"
" total number of participating processes is indicated by `num_process`. "
"The process with `process_id=0` acts as the coordinator."
msgstr "在这个系统中，“coordinator”（协调器）充当主节点或头节点的角色。参与进程的总数由num_process指示。具有process_id=0的进程充当协调器。"

#: ../../source/guide/basics/3-distributed.md:98
msgid ""
"From more information, please refer to "
"[jax.distributed.initialize](https://jax.readthedocs.io/en/latest/_autosummary/jax.distributed.initialize.html)"
" and [Using JAX in multi-host and multi-process "
"environments](https://jax.readthedocs.io/en/latest/multi_process.html)."
msgstr "有关更多信息，请参考jax.distributed.initialize(https://jax.readthedocs.io/en/latest/_autosummary/jax.distributed.initialize.html)和在多主机和多进程环境中使用JAX的文档(https://jax.readthedocs.io/en/latest/multi_process.html)。"

#: ../../source/guide/basics/3-distributed.md:100
#, fuzzy
msgid "Run in a cluster"
msgstr "在一个集群中运行"

#: ../../source/guide/basics/3-distributed.md:102
msgid ""
"Unlike Ray, JAX's doesn't have the concept of cluster or scheduler. "
"Instead, it offers tools for enabling distributed interactions among "
"multiple JAX instances. JAX follows the SPMD (single program multiple "
"data) paradigm. To initiate a distributed program in JAX, you simply need"
" to run the same script on different machines. For instance, if your "
"program is named `main.py`, you should execute the following command on "
"all participating machines with different `process_id` argument in "
"`jax.distributed.initialize`:"
msgstr "不同于Ray，JAX没有集群或调度器的概念。相反，它提供了工具来实现多个JAX实例之间的分布式交互。JAX遵循SPMD（单程序多数据）范式。要在JAX中启动一个分布式程序，你只需在不同的机器上运行相同的脚本。例如，如果你的程序名为main.py，你应该在所有参与的机器上执行以下命令，并在jax.distributed.initialize中为不同的机器设置不同的process_id参数："

#: ../../source/guide/basics/3-distributed.md:110
msgid ""
"To have `process_id` in the argument, one can use `argparse` to parse the"
" argument from the commandline. For example:"
msgstr "为了在参数中包含process_id，可以使用argparse库从命令行解析参数。例如："

#: ../../source/guide/basics/3-distributed.md:125
#, fuzzy
msgid ""
"Then call `python main.py 0` on the first machine, `python main 1` on the"
" second machine and so on."
msgstr "然后在第一台机器上调用'python main.py 0'，在第二台机器上调用'python main.py 1'，依此类推。"

#: ../../source/guide/basics/index.md:1
msgid "Getting Started"
msgstr "开始"

#: ../../source/guide/install.md:1
msgid "Installation Guide"
msgstr "安装教程"

#: ../../source/guide/install.md:3
msgid "Install EvoX"
msgstr "安装EvoX"

#: ../../source/guide/install.md:5
msgid "EvoX is available at Pypi and can be installed via:"
msgstr "EvoX 可以在 PyPI 上找到，可以通过以下方式安装："

#: ../../source/guide/install.md:11
msgid "To install EvoX with optional dependencies:"
msgstr "要安装带有可选依赖项的 EvoX："

#: ../../source/guide/install.md:17
msgid ""
"available features are `gymnasium`, `neuroevolution`, `envpool`, "
"`distributed`, and `full` which concludes all features. For example, to "
"install EvoX with all features, do:"
msgstr ""
"EvoX 提供多种可选特性，包括 "
"`gymnasium`、`neuroevolution`、`envpool`、`distributed`和`full`（包含所有特性）。例如，要安装包含所有特性的"
" EvoX，您可以使用以下命令："

#: ../../source/guide/install.md:24
msgid "Install JAX with accelerator support"
msgstr "安装支持GPU加速的JAX"

#: ../../source/guide/install.md:26
msgid ""
"`EvoX` relies on `JAX` to provide hardware acceleration. The overall "
"architecture of these Python packages looks like this:"
msgstr "`EvoX`依赖于`JAX`来提供硬件加速的能力。这些Python包的整体架构如下："

#: ../../source/guide/install.md:43
msgid ""
"`JAX` itself is pure Python, and `jaxlib` provides the C/C++ code. To "
"utilize JAX's hardware acceleration ability, make sure to install the "
"correct `jaxlib` version."
msgstr ""
"`JAX`本身是纯 Python 库，而`jaxlib`则提供了支持加速器的 C/C++ "
"代码。要充分利用JAX的硬件加速能力，必须确保安装了正确的`jaxlib`版本。"

#: ../../source/guide/install.md:47
msgid ""
"For more information, e.g. other platforms, please check out JAX's "
"[official installation guide](https://github.com/google/jax/?tab=readme-"
"ov-file#installation)."
msgstr ""
"想要了解更多信息，比如在其他平台上安装的教程，请查阅JAX的[官方安装指南](https://github.com/google/jax/?tab"
"=readme-ov-file#installation)。"

#: ../../source/guide/install.md:50
msgid "CPU only"
msgstr "纯CPU版"

#: ../../source/guide/install.md:56
msgid "CUDA (NVIDIA GPU)"
msgstr "CUDA版 （NVIDIA GPU）"

#: ../../source/guide/install.md:58
msgid ""
"To enable CUDA acceleration, please ensure that the following components "
"are installed in a compatible manner:"
msgstr "为了能正确启用 CUDA 加速，请确保以下组件以能够兼容的方式安装："

#: ../../source/guide/install.md:85
#, fuzzy
msgid "If your using any virtualization technology, like WSL, docker."
msgstr "如果你正在使用任何虚拟化技术，例如 WSL 或 Docker。"

#: ../../source/guide/install.md:86
msgid ""
"**kernel space components**: should be installed on your host system. For"
" example, if you are using WSL with Windows, then the driver should be "
"installed on Windows, not inside WSL. If you are using container (e.g. "
"docker), then the driver should be installed on your host OS (outside "
"docker)."
msgstr ""
"**内核空间组件**：应安装在您的宿主机系统上。例如，如果您在 Windows 上使用 WSL，则应在 Windows 上安装驱动程序，而不是在 "
"WSL 内部安装。如果您使用容器（例如 Docker），则应在您的宿主机操作系统（Docker 外部）上安装驱动程序。"

#: ../../source/guide/install.md:89
msgid "**user space components**: need to be installed inside WSL or docker."
msgstr "**用户空间组件**：需要安装在 WSL 或 Docker 内部。"

#: ../../source/guide/install.md:92
msgid "Install NVIDIA's proprietary driver"
msgstr "安装 NVIDIA 的闭源驱动程序"

#: ../../source/guide/install.md:95
msgid "Windows WSL 2"
msgstr "Windows WSL 2"

#: ../../source/guide/install.md:97
msgid ""
"Download the [latest NVIDIA Windows GPU "
"Driver](https://www.nvidia.com/Download/index.aspx?lang=en-us), and "
"install it."
msgstr ""
"下载 [最新的NVIDIA Windows "
"GPU驱动](https://www.nvidia.com/Download/index.aspx?lang=en-us)，并安装."

#: ../../source/guide/install.md:100
msgid ""
"You must **NOT** install any NVIDIA GPU Linux driver within WSL 2. GPU "
"driver this a kernel space program, so it should be installed on the "
"Windows side."
msgstr ""
"请**不要**在 WSL 2 内部安装任何 NVIDIA GPU Linux 驱动程序。GPU 驱动程序属于内核空间程序，应安装在 Windows"
" 主机系统上。"

#: ../../source/guide/install.md:105
msgid ""
"NVIDIA has a detailed [CUDA on WSL User "
"Guide](https://docs.nvidia.com/cuda/wsl-user-guide/index.html)"
msgstr ""
"NVIDIA官方有一个详细的教程 [CUDA on WSL User Guide](https://docs.nvidia.com/cuda"
"/wsl-user-guide/index.html)"

#: ../../source/guide/install.md:108
msgid "GNU/Linux"
msgstr "GNU/Linux"

#: ../../source/guide/install.md:111
msgid ""
"If you are on GNU/Linux, I strongly recommend to install the driver via "
"the package manager of your Linux distribution. Please do **NOT** install"
" the driver from NVIDIA's website."
msgstr ""
"如果您使用 GNU/Linux 系统，我强烈建议您通过您的 Linux 发行版的包管理器（比如apt，pacman）来安装驱动程序，而不是从 "
"NVIDIA 的网站下载安装包。"

#: ../../source/guide/install.md:117
msgid ""
"Only NVIDIA's proprietary driver works with CUDA, open-source drivers "
"like Nouveau do not."
msgstr "仅有NVIDIA的闭源驱动支持CUDA，像Nouveau这样的开源驱动则不支持。"

#: ../../source/guide/install.md:120
msgid ""
"The detailed installation guide depends on your operating system, for "
"example"
msgstr "具体的安装方法取决于您的操作系统，例如"

#: ../../source/guide/install.md:122 ../../source/guide/install.md:153
msgid "ArchLinux"
msgstr "ArchLinux"

#: ../../source/guide/install.md:126 ../../source/guide/install.md:157
#, fuzzy
msgid "Ubuntu 22.04"
msgstr "Ubuntu 22.04"

#: ../../source/guide/install.md:130
msgid ""
"NixOS first enable unfree software, and then add the following to your "
"configuration."
msgstr "NixOS首先启用非自由软件，然后添加以下配置。"

#: ../../source/guide/install.md:136
msgid "After installing the driver, please reboot."
msgstr "安装完驱动后，请重启电脑。"

#: ../../source/guide/install.md:139
msgid "Cluster (e.g. slurm, k8s)"
msgstr "聚类（如slurm, k8s）"

#: ../../source/guide/install.md:141
#, fuzzy
msgid ""
"If the latest driver has already been installed in the cluster, please go"
" ahead and skip this section."
msgstr "如果集群中已经安装了最新的驱动，请跳过这个部分并继续。"

#: ../../source/guide/install.md:143
#, fuzzy
msgid ""
"Otherwise, please contact the administrator of the cluster to upgrade the"
" GPU driver version. It is important to note that the driver must be "
"installed on the host system, rendering any effort within the container "
"(e.g. docker, singularity) meaningless. Thus only the administrator can "
"solve this problem."
msgstr "如果没有，请联系集群的管理员来升级GPU驱动版本。需要注意的是，驱动必须安装在宿主系统上，在容器内进行的任何尝试都是无效的。因此只有管理员才能解决这个问题。"

#: ../../source/guide/install.md:148
msgid "Install CUDA libraries"
msgstr "安装CUDA库"

#: ../../source/guide/install.md:150
msgid ""
"CUDA libraries are user space libraries, so you don't need to reboot "
"after installation. Again, it depends on your operating system, for "
"example"
msgstr "CUDA 库是安装在用户空间的，所以在安装后您不需要重启。 具体的安装方式取决于您的操作系统，例如"

#: ../../source/guide/install.md:163
msgid "Now, you can check your do"
msgstr "现在您可以检查您做的"

#: ../../source/guide/install.md:167
#, fuzzy
msgid ""
"to see if your GPU is recognized by the driver. If you see something like"
" this, then you are good to go."
msgstr "查看您的GPU是否被驱动识别。如果您看到类似的信息，那么您可以开始了。"

#: ../../source/guide/install.md:191
msgid "Then check your jaxlib version by"
msgstr "之后通过其检查您的jaxlib版本"

#: ../../source/guide/install.md:197
msgid ""
"Please make sure you CUDA version is smaller or equal to the version of "
"`jaxlib-cuda`."
msgstr "请确保您的CUDA版本小于或等于`jaxlib-cuda`的版本。"

#: ../../source/guide/install.md:210
msgid ""
"For example, we have `0.4.18+cuda11.cudnn86` installed, and 11 < 12.2 "
"(displayed by `nvidia-smi`). So we are good to go."
msgstr ""
"例如，我们安装了0.4.18+cuda11.cudnn86版本，且nvidia-"
"smi显示的CUDA版本是11，小于12.2。因此，我们可以开始使用了。"

#: ../../source/guide/install.md:213
msgid ""
"Since installing `jax[cuda12]` will usually install the jaxlib compiled "
"with the latest CUDA version. Even if you have CUDA 12, your CUDA version"
" might still be lower than the version of that jaxlib requires. In this "
"case, try to install `jax[cuda11]`."
msgstr ""
"由于安装 jax[cuda12] 通常会安装到使用最新 CUDA 版本编译的 jaxlib，即使您有 CUDA 12，您的 CUDA "
"版本也可能低于 jaxlib 要求的版本（小版本号不够）。 在这种情况下，请尝试安装 jax[cuda11]。"

#: ../../source/guide/install.md:218
msgid "AMD GPU (ROCM)"
msgstr ""

#: ../../source/guide/install.md:220
msgid ""
"Despite being considered experimental, installing AMD GPUs for ROCm is "
"surprisingly straightforward thanks to their open-source drivers. "
"However, currently only a limited number of GPUs are supported, notably "
"the Radeon RX 7900XTX and Radeon PRO W7900 for consumer-grade GPUs. Note "
"that Windows is not currently supported."
msgstr ""

#: ../../source/guide/install.md:222
#, fuzzy
msgid "Install GPU driver"
msgstr "安装教程"

#: ../../source/guide/install.md:224
msgid ""
"Since the AMD driver is open-source, installation is simplified: simply "
"install mesa through your Linux distribution's package manager. In many "
"cases, the driver may already be pre-installed."
msgstr ""

#: ../../source/guide/install.md:226
msgid "To verify that the driver is installed, run the following command:"
msgstr ""

#: ../../source/guide/install.md:232
msgid "And you should see `amdgpu` in the output."
msgstr ""

#: ../../source/guide/install.md:234
#, fuzzy
msgid "Install ROCm"
msgstr "安装EvoX"

#: ../../source/guide/install.md:236
msgid ""
"The latest version of ROCm (v5.7.1 or later) may not be available in your"
" Linux distribution's package manager. Therefore, using a containerized "
"environment is the easiest way to get started."
msgstr ""

#: ../../source/guide/install.md:242
msgid ""
"Please visit [Docker Hub](https://hub.docker.com/r/rocm/jax) for further "
"instructions."
msgstr ""

#: ../../source/guide/install.md:244
msgid "Verify your installation"
msgstr "验证安装是否正确"

#: ../../source/guide/install.md:246
msgid "Open a Python terminal, and run the following:"
msgstr "打开 Python 终端，并运行以下命令："

#: ../../source/guide/install.md:254
msgid "Here are some possible output:"
msgstr "这里是几种可能的输出结果："

#: ../../source/guide/install.md
msgid "Correct"
msgstr "正确"

#: ../../source/guide/install.md
msgid "EvoX not installed"
msgstr "未安装EvoX"

#: ../../source/guide/install.md
msgid "Wrong jaxlib version"
msgstr "jaxlib版本错误"

#: ../../source/guide/install.md
msgid "Wrong driver/library"
msgstr "驱动或库版本错误"

#: ../../source/index.md:4
msgid "User Guide"
msgstr "用户指引"

#: ../../source/index.md:14
#, fuzzy
msgid "API Reference"
msgstr "API文档"

#: ../../source/index.md:26
#, fuzzy
msgid "Examples"
msgstr "示例"

#: ../../source/index.md:26 ../../source/miscellaneous/index.md:1
msgid "Miscellaneous"
msgstr ""

#: ../../source/index.md:26
msgid "Additional Resources"
msgstr "补充资源"

#: ../../source/index.md:1
msgid "Welcome to EvoX's documentation!"
msgstr "欢迎来到EvoX的文档！"

#: ../../source/index.md:35
#, fuzzy
msgid ""
"[[English Version]](https://evox.readthedocs.io/en/latest/)   "
"[[中文版本]](https://evox.readthedocs.io/zh/latest/)"
msgstr ""
"[[English Version]](https://evox.readthedocs.io/en/latest/)   "
"[[中文版本]](https://evox.readthedocs.io/zh/latest/)"

#: ../../source/index.md:37
msgid ""
"EvoX is a distributed GPU-accelerated framework for scalable evolutionary"
" computation."
msgstr "EvoX是一个可以对大规模演化计算进行分布式GPU加速的框架。"

#: ../../source/index.md:41
#, fuzzy
msgid "Key Features"
msgstr "关键特征"

#: ../../source/index.md:43
msgid "🚀 **Fast Performance**:"
msgstr "🚀 **超高性能**："

#: ../../source/index.md:44
msgid ""
"Experience **GPU-Accelerated** optimization, achieving speeds over 100x "
"faster than traditional methods."
msgstr "体验**GPU 加速**的优化，速度比传统方法快百倍以上。"

#: ../../source/index.md:45
msgid ""
"Leverage the power of {class}`Distributed Workflows "
"<evox.workflows.RayDistributedWorkflow>` for even more rapid "
"optimization."
msgstr ""
"利用 {class}`分布式工作流 <evox.workflows.RayDistributedWorkflow>` "
"的强大功能，实现更快速的优化。"

#: ../../source/index.md:47
msgid "🌐 **Versatile Optimization Suite**:"
msgstr "🌐 **多功能优化套件**:"

#: ../../source/index.md:48
msgid ""
"Cater to all your needs with both {doc}`Single-objective "
"<api/algorithms/so/index>` and {doc}`Multi-objective "
"<api/algorithms/mo/index>` optimization capabilities."
msgstr ""
"满足您所有需求，包括 {doc}`单目标 <api/algorithms/so/index>` 和 {doc}`多目标 "
"<api/algorithms/mo/index>`优化功能。"

#: ../../source/index.md:49
msgid ""
"Dive into a comprehensive library of {doc}`Benchmark Problems "
"<api/problems/numerical/index>`, ensuring robust testing and evaluation."
msgstr "深入了解全面的{doc}`基准测试问题库 <api/problems/numerical/"
"index>`，确保进行稳健的测试和评估。"

#: ../../source/index.md:50
msgid ""
"Explore the frontier of AI with extensive tools for {doc}`Neuroevolution "
"<api/problems/neuroevolution/index>` tasks."
msgstr ""
"探索人工智能前沿领域，利用广泛的工具进行 {doc}`神经演化 <api/problems/"
"neuroevolution/index>` 任务。"

#: ../../source/index.md:52
msgid "🛠️ **Designed for Simplicity**:"
msgstr "🛠️ **简易性设计**:"

#: ../../source/index.md:53
msgid ""
"Embrace the elegance of **Functional Programming**, simplifying complex "
"algorithmic compositions."
msgstr "拥抱优雅的**函数式编程**，化繁为简，轻松构建复杂算法。"

#: ../../source/index.md:54
msgid ""
"Benefit from **Hierarchical State Management**, ensuring modular and "
"clean programming."
msgstr "得益于**层次化状态管理**，体验模块化和清爽的编程体验。"

#: ../../source/index.md:57
#, fuzzy
msgid "<br></br>"
msgstr "<br></br>"

#: ../../source/index.md:64
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-desktop-download\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path d=\"M11.25 9.331V.75a.75.75 0 011.5 "
"0v8.58l1.949-2.11A.75.75 0 1115.8 8.237l-3.25 3.52a.75.75 0 01-1.102 "
"0l-3.25-3.52A.75.75 0 119.3 7.22l1.949 2.111z\"></path><path fill-"
"rule=\"evenodd\" d=\"M2.5 3.75a.25.25 0 01.25-.25h5.5a.75.75 0 "
"100-1.5h-5.5A1.75 1.75 0 001 3.75v11.5c0 .966.784 1.75 1.75 "
"1.75h6.204c-.171 1.375-.805 2.652-1.77 3.757A.75.75 0 007.75 "
"22h8.5a.75.75 0 "
"00.565-1.243c-.964-1.105-1.598-2.382-1.769-3.757h6.204A1.75 1.75 0 0023 "
"15.25V3.75A1.75 1.75 0 0021.25 2h-5.5a.75.75 0 000 1.5h5.5a.25.25 0 "
"01.25.25v11.5a.25.25 0 01-.25.25H2.75a.25.25 0 01-.25-.25V3.75zM10.463 "
"17c-.126 1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5h-3.074z\"></path></svg> "
"Installation Guide"
msgstr ""
"<path fill-rule=\"evenodd\" d=\"M3.5 8a5.5 5.5 0 118.596 4.547 9.005 "
"9.005 0 015.9 8.18.75.75 0 01-1.5.045 7.5 7.5 0 00-14.993 0 .75.75 0 "
"01-1.499-.044 9.005 9.005 0 015.9-8.181A5.494 5.494 0 013.5 8zM9 4a4 4 0 "
"100 8 4 4 0 000-8z\"><path d=\"M17.29 8c-.148 0-.292.01-.434.03a.75.75 0 "
"11-.212-1.484 4.53 4.53 0 013.38 8.097 6.69 6.69 0 013.956 6.107.75.75 0 "
"01-1.5 0 5.193 5.193 0 00-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03"
" 0 0017.29 8z\"><path fill-rule=\"evenodd\" d=\"M2.5 3.75a.25.25 0 "
"01.25-.25h5.5a.75.75 0 100-1.5h-5.5A1.75 1.75 0 001 3.75v11.5c0 .966.784 "
"1.75 1.75 1.75h6.204c-.171 1.375-.805 2.652-1.77 3.757A.75.75 0 007.75 "
"22h8.5a.75.75 0 "
"00.565-1.243c-.964-1.105-1.598-2.382-1.769-3.757h6.204A1.75 1.75 0 0023 "
"15.25V3.75A1.75 1.75 0 0021.25 2h-5.5a.75.75 0 000 1.5h5.5a.25.25 0 "
"01.25.25v11.5a.25.25 0 01-.25.25H2.75a.25.25 0 01-.25-.25V3.75zM10.463 "
"17c-.126 1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5h-3.074z\"> 安装教程"

#: ../../source/index.md:70
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"fill-rule=\"evenodd\" d=\"M3.5 8a5.5 5.5 0 118.596 4.547 9.005 9.005 0 "
"015.9 8.18.75.75 0 01-1.5.045 7.5 7.5 0 00-14.993 0 .75.75 0 "
"01-1.499-.044 9.005 9.005 0 015.9-8.181A5.494 5.494 0 013.5 8zM9 4a4 4 0 "
"100 8 4 4 0 000-8z\"></path><path d=\"M17.29 8c-.148 "
"0-.292.01-.434.03a.75.75 0 11-.212-1.484 4.53 4.53 0 013.38 8.097 6.69 "
"6.69 0 013.956 6.107.75.75 0 01-1.5 0 5.193 5.193 0 "
"00-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0017.29 "
"8z\"></path></svg> Getting Started"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"fill-rule=\"evenodd\" d=\"M3.5 8a5.5 5.5 0 118.596 4.547 9.005 9.005 0 "
"015.9 8.18.75.75 0 01-1.5.045 7.5 7.5 0 00-14.993 0 .75.75 0 "
"01-1.499-.044 9.005 9.005 0 015.9-8.181A5.494 5.494 0 013.5 8zM9 4a4 4 0 "
"100 8 4 4 0 000-8z\"></path><path d=\"M17.29 8c-.148 "
"0-.292.01-.434.03a.75.75 0 11-.212-1.484 4.53 4.53 0 013.38 8.097 6.69 "
"6.69 0 013.956 6.107.75.75 0 01-1.5 0 5.193 5.193 0 "
"00-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0017.29 "
"8z\"></path></svg> 新手教程"

#: ../../source/index.md:76
#, fuzzy
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M12.292 2.06a.75.75 0 "
"00-.584 0L.458 6.81a.75.75 0 000 1.38L4.25 9.793v3.803a2.901 2.901 0 "
"00-1.327.757c-.579.58-.923 1.41-.923 2.43v4.5c0 "
".248.128.486.335.624.06.04.117.073.22.124.124.062.297.138.52.213.448.149 "
"1.09.288 1.925.288s1.477-.14 1.925-.288c.223-.075.396-.15.52-.213a2.11 "
"2.11 0 00.21-.117A.762.762 0 008 "
"21.28v-4.5c0-1.018-.344-1.85-.923-2.428a2.9 2.9 0 "
"00-1.327-.758v-3.17l5.958 2.516a.75.75 0 00.584 0l5.208-2.2v4.003a2.552 "
"2.552 0 01-.079.085 4.057 4.057 0 01-.849.65c-.826.488-2.255 1.021-4.572 "
"1.021-.612 0-1.162-.037-1.654-.1a.75.75 0 00-.192 1.487c.56.072 1.173.113"
" 1.846.113 2.558 0 4.254-.592 5.334-1.23.538-.316.914-.64 1.163-.896a2.84"
" 2.84 0 00.392-.482h.001A.75.75 0 0019 15v-4.892l4.542-1.917a.75.75 0 "
"000-1.382l-11.25-4.75zM5 15c-.377 "
"0-.745.141-1.017.413-.265.265-.483.7-.483 1.368v4.022c.299.105.797.228 "
"1.5.228s1.201-.123 1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.431 "
"1.431 0 005 15zm7-3.564L2.678 7.5 12 3.564 21.322 7.5 12 "
"11.436z\"></path></svg> Advanced Guide"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M12.292 2.06a.75.75 0 "
"00-.584 0L.458 6.81a.75.75 0 000 1.38L4.25 9.793v3.803a2.901 2.901 0 "
"00-1.327.757c-.579.58-.923 1.41-.923 2.43v4.5c0 "
".248.128.486.335.624.06.04.117.073.22.124.124.062.297.138.52.213.448.149 "
"1.09.288 1.925.288s1.477-.14 1.925-.288c.223-.075.396-.15.52-.213a2.11 "
"2.11 0 00.21-.117A.762.762 0 008 "
"21.28v-4.5c0-1.018-.344-1.85-.923-2.428a2.9 2.9 0 "
"00-1.327-.758v-3.17l5.958 2.516a.75.75 0 00.584 0l5.208-2.2v4.003a2.552 "
"2.552 0 01-.079.085 4.057 4.057 0 01-.849.65c-.826.488-2.255 1.021-4.572 "
"1.021-.612 0-1.162-.037-1.654-.1a.75.75 0 00-.192 1.487c.56.072 1.173.113"
" 1.846.113 2.558 0 4.254-.592 5.334-1.23.538-.316.914-.64 1.163-.896a2.84"
" 2.84 0 00.392-.482h.001A.75.75 0 0019 15v-4.892l4.542-1.917a.75.75 0 "
"000-1.382l-11.25-4.75zM5 15c-.377 "
"0-.745.141-1.017.413-.265.265-.483.7-.483 1.368v4.022c.299.105.797.228 "
"1.5.228s1.201-.123 1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.431 "
"1.431 0 005 15zm7-3.564L2.678 7.5 12 3.564 21.322 7.5 12 "
"11.436z\"></path></svg> 高级指南"

#: ../../source/index.md:86
#, fuzzy
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M4 7a1 1 0 100-2 1 1 0 "
"000 2zm4.75-1.5a.75.75 0 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0"
" 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0 000 1.5h11.5a.75.75 0 "
"000-1.5H8.75zM5 12a1 1 0 11-2 0 1 1 0 012 0zm-1 7a1 1 0 100-2 1 1 0 000 "
"2z\"></path></svg> Algorithms"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M4 7a1 1 0 100-2 1 1 0 "
"000 2zm4.75-1.5a.75.75 0 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0"
" 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0 000 1.5h11.5a.75.75 0 "
"000-1.5H8.75zM5 12a1 1 0 11-2 0 1 1 0 012 0zm-1 7a1 1 0 100-2 1 1 0 000 "
"2z\"></path></svg> 算法"

#: ../../source/index.md:92
#, fuzzy
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M4 7a1 1 0 100-2 1 1 0 "
"000 2zm4.75-1.5a.75.75 0 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0"
" 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0 000 1.5h11.5a.75.75 0 "
"000-1.5H8.75zM5 12a1 1 0 11-2 0 1 1 0 012 0zm-1 7a1 1 0 100-2 1 1 0 000 "
"2z\"></path></svg> Problems"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M4 7a1 1 0 100-2 1 1 0 "
"000 2zm4.75-1.5a.75.75 0 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0"
" 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0 000 1.5h11.5a.75.75 0 "
"000-1.5H8.75zM5 12a1 1 0 11-2 0 1 1 0 012 0zm-1 7a1 1 0 100-2 1 1 0 000 "
"2z\"></path></svg> 问题"

#: ../../source/index.md:99
#, fuzzy
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M4 7a1 1 0 100-2 1 1 0 "
"000 2zm4.75-1.5a.75.75 0 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0"
" 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0 000 1.5h11.5a.75.75 0 "
"000-1.5H8.75zM5 12a1 1 0 11-2 0 1 1 0 012 0zm-1 7a1 1 0 100-2 1 1 0 000 "
"2z\"></path></svg> Metrics"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M4 7a1 1 0 100-2 1 1 0 "
"000 2zm4.75-1.5a.75.75 0 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0"
" 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0 000 1.5h11.5a.75.75 0 "
"000-1.5H8.75zM5 12a1 1 0 11-2 0 1 1 0 012 0zm-1 7a1 1 0 100-2 1 1 0 000 "
"2z\"></path></svg>指标"

#: ../../source/miscellaneous/high_vram_usage.md:1
msgid "High VRAM usage"
msgstr ""

#: ../../source/miscellaneous/high_vram_usage.md:3
#, python-format
msgid ""
"By default, JAX will allocate 75% of the GPU memory regardless of the "
"program you run. This preallocate is used to avoid memory fragmentation "
"and improve performance."
msgstr ""

#: ../../source/miscellaneous/high_vram_usage.md:6
msgid ""
"To disable this behavior, you can use the "
"`XLA_PYTHON_CLIENT_PREALLOCATE=false` environment variable."
msgstr ""

#: ../../source/miscellaneous/high_vram_usage.md:8
msgid ""
"For more information, please refer to the [JAX "
"documentation](https://jax.readthedocs.io/en/latest/gpu_memory_allocation.html)."
msgstr ""

#: ../../source/miscellaneous/selecting_gpu.md:1
msgid "Selecting GPU"
msgstr ""

#: ../../source/miscellaneous/selecting_gpu.md:3
msgid ""
"To run your program on a specific GPU, you can use the "
"`CUDA_VISIBLE_DEVICES` environment variable. For example, to run your "
"program on the second GPU, you can use:"
msgstr ""

#: ../../source/miscellaneous/selecting_gpu.md:9
msgid "To run your program on multiple GPUs, you can use:"
msgstr ""

#: ../../source/miscellaneous/selecting_gpu.md:15
msgid "To disable GPU usage, you can use:"
msgstr ""

#~ msgid "EvoX's API"
#~ msgstr "EvoX的API"

#~ msgid "**env_per_worker**"
#~ msgstr ""

#~ msgid "Number of gym environment per worker."
#~ msgstr ""

#~ msgid "**pop_size**"
#~ msgstr ""

#~ msgid ""
#~ "Population size, this argument together "
#~ "with num_workers will be used to "
#~ "determine the sharding strategy."
#~ msgstr ""

#~ msgid ""
#~ "[![Open in Colab](https://colab.research.google.com/assets"
#~ "/colab-badge.svg)](https://colab.research.google.com/github/EMI-"
#~ "Group/evox/blob/main/docs/source/guide/basics/1-start.ipynb)"
#~ msgstr ""

#~ msgid "Open in Colab"
#~ msgstr "在Colab中打开"

#~ msgid ""
#~ "[![Open in Colab](https://colab.research.google.com/assets"
#~ "/colab-badge.svg)](https://colab.research.google.com/github/EMI-"
#~ "Group/evox/blob/main/docs/source/guide/basics/2-problems.ipynb)"
#~ msgstr ""

#~ msgid "EvoX's guide!"
#~ msgstr ""

#~ msgid "API reference"
#~ msgstr ""

#~ msgid "Contents:"
#~ msgstr ""

#~ msgid "Indices and tables"
#~ msgstr ""

#~ msgid "{ref}`genindex`"
#~ msgstr ""

#~ msgid "{ref}`modindex`"
#~ msgstr ""

#~ msgid "{ref}`search`"
#~ msgstr "{ref}`search`"

#~ msgid ""
#~ "A Built-in plot function for "
#~ "visualizing the population of single-"
#~ "objective algorithm. Use plotly internally,"
#~ " so you need to install plotly "
#~ "to use this function."
#~ msgstr "内置的单目标算法种群可视化绘图函数。内部使用plotly库，因此要使用此功能，您需要先安装plotly。"

#~ msgid ""
#~ "If the problem is provided, we "
#~ "will plot the fitness landscape of "
#~ "the problem."
#~ msgstr "如果提供了问题实例，我们将绘制该问题的适应度landscape。"

#~ msgid ""
#~ "pop_transform and fitness_transform are "
#~ "applied at each node, while "
#~ "global_fitness_transform is applied at the "
#~ "main node once per step, so "
#~ "monitor should be passed as "
#~ "global_fitness_transform."
#~ msgstr "pop_transform和fitness_transform在每个节点上分别应用，而global_fitness_transform则在主节点上每一步执行一次。因此，monitor应当作为global_fitness_transform传递。"

#~ msgid "**fitness_transform:**"
#~ msgstr "**fitness_transform:**"

#~ msgid "**global_fitness_transform:**"
#~ msgstr "**global_fitness_transform:**"

#~ msgid "This transform is applied at the main node."
#~ msgstr "这个变换在主节点上应用。"

#~ msgid "**record_pop**"
#~ msgstr "**种群记录**"

#~ msgid "Whether to record the population if monitor is enabled."
#~ msgstr "如果启用了monitor，是否要记录种群数据。"

#~ msgid "**record_time**"
#~ msgstr "**时间记录**"

#~ msgid ""
#~ "Whether to record the time at the"
#~ " end of each generation. Due to "
#~ "its timing nature, record_time requires "
#~ "synchronized functional call. Default to "
#~ "False."
#~ msgstr "是否记录每代结束的时间。由于它的计时性质，record_time需要同步的函数调用。默认为False。"

#~ msgid "Universal Workflow"
#~ msgstr "通用工作流"

#~ msgid "**jit_monitor**"
#~ msgstr "**jit_monitor**"

#~ msgid "If the monitor can be jit compiled by JAX or not. Default to False."
#~ msgstr "监视器是否可以通过JAX进行jit编译。默认为False。"
