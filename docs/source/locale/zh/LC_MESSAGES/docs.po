# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1980, Bill Huang
# This file is distributed under the same license as the EvoX package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: EvoX\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-14 17:17+0800\n"
"PO-Revision-Date: 2024-11-05 08:25+0000\n"
"Last-Translator: BillHuang <bill.huang2001@gmail.com>\n"
"Language-Team: Chinese (Simplified Han script) <https://hosted.weblate.org/projects/evox/evox/zh_Hans/>\n"
"Language: zh\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.16.0\n"

#: ../../source/apidocs/evox/evox.md:1
msgid "{py:mod}`evox`"
msgstr "{py:mod}`evox`"

#: ../../source/apidocs/evox/evox.algorithms.md:10
#: ../../source/apidocs/evox/evox.md:10
#: ../../source/apidocs/evox/evox.operators.md:10
#: ../../source/apidocs/evox/evox.problems.md:10
msgid "Subpackages"
msgstr "子包"

#: ../../source/apidocs/evox/evox.algorithms.md:1
msgid "{py:mod}`evox.algorithms`"
msgstr "{py:mod}`evox.algorithms`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:31
#: ../../source/apidocs/evox/evox.algorithms.md:22
#: ../../source/apidocs/evox/evox.algorithms.mo.md:21
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:26
#: ../../source/apidocs/evox/evox.core.md:22
#: ../../source/apidocs/evox/evox.metrics.md:21
#: ../../source/apidocs/evox/evox.operators.crossover.md:21
#: ../../source/apidocs/evox/evox.operators.md:22
#: ../../source/apidocs/evox/evox.operators.mutation.md:19
#: ../../source/apidocs/evox/evox.operators.sampling.md:21
#: ../../source/apidocs/evox/evox.operators.selection.md:22
#: ../../source/apidocs/evox/evox.problems.numerical.md:21
#: ../../source/apidocs/evox/evox.utils.md:21
#: ../../source/apidocs/evox/evox.workflows.md:20
msgid "Package Contents"
msgstr "软件包内容"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:24
#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:26
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:33
#: ../../source/apidocs/evox/evox.algorithms.md:24
#: ../../source/apidocs/evox/evox.algorithms.mo.md:23
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:28
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:112
#: ../../source/apidocs/evox/evox.core.jit_util.md:46
#: ../../source/apidocs/evox/evox.core.md:24
#: ../../source/apidocs/evox/evox.core.module.md:98
#: ../../source/apidocs/evox/evox.metrics.md:23
#: ../../source/apidocs/evox/evox.operators.crossover.md:23
#: ../../source/apidocs/evox/evox.operators.md:24
#: ../../source/apidocs/evox/evox.operators.mutation.md:21
#: ../../source/apidocs/evox/evox.operators.sampling.md:23
#: ../../source/apidocs/evox/evox.operators.selection.md:24
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:56
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:40
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:24
#: ../../source/apidocs/evox/evox.problems.numerical.md:23
#: ../../source/apidocs/evox/evox.utils.control_flow.md:12
#: ../../source/apidocs/evox/evox.utils.md:23
#: ../../source/apidocs/evox/evox.workflows.md:22
msgid "Data"
msgstr "数据"

#: ../../source/apidocs/evox/evox.algorithms.md:30
msgid "{py:obj}`__all__ <evox.algorithms.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:52
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:24
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:24
#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:38
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:24
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:48
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:45
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:28
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:24
#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:24
#: ../../source/apidocs/evox/evox.algorithms.md:36
#: ../../source/apidocs/evox/evox.algorithms.mo.md:35
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:36
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:24
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:40
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:28
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:168
#: ../../source/apidocs/evox/evox.core.components.md:36
#: ../../source/apidocs/evox/evox.core.jit_util.md:58
#: ../../source/apidocs/evox/evox.core.md:36
#: ../../source/apidocs/evox/evox.core.module.md:162
#: ../../source/apidocs/evox/evox.metrics.gd.md:24
#: ../../source/apidocs/evox/evox.metrics.hv.md:24
#: ../../source/apidocs/evox/evox.metrics.igd.md:24
#: ../../source/apidocs/evox/evox.metrics.md:35
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:36
#: ../../source/apidocs/evox/evox.operators.crossover.md:35
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:24
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:24
#: ../../source/apidocs/evox/evox.operators.md:36
#: ../../source/apidocs/evox/evox.operators.mutation.md:33
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:24
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:24
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:28
#: ../../source/apidocs/evox/evox.operators.sampling.md:35
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:24
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:24
#: ../../source/apidocs/evox/evox.operators.selection.md:36
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:68
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:28
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:28
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:32
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:56
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:40
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:36
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:80
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:24
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:42
#: ../../source/apidocs/evox/evox.problems.numerical.md:35
#: ../../source/apidocs/evox/evox.utils.control_flow.md:24
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:76
#: ../../source/apidocs/evox/evox.utils.md:35
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:24
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:40
#: ../../source/apidocs/evox/evox.vis_tools.plot.md:44
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:24
#: ../../source/apidocs/evox/evox.workflows.md:34
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:26
msgid "API"
msgstr "API"

#: ../../source/apidocs/evox/evox.algorithms.md:42
msgid ""
"['DE', 'SHADE', 'CoDE', 'SaDE', 'ODE', 'JaDE', 'OpenES', 'XNES', "
"'SeparableNES', 'DES', 'SNES', 'ARS..."
msgstr ""
"['DE', 'SHADE', 'CoDE', 'SaDE', 'ODE', 'JaDE', 'OpenES', 'XNES', "
"'SeparableNES', 'DES', 'SNES', 'ARS..."

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:1
msgid "{py:mod}`evox.algorithms.de_variants`"
msgstr "{py:mod}`evox.algorithms.de_variants`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:10
#: ../../source/apidocs/evox/evox.core.md:10
#: ../../source/apidocs/evox/evox.metrics.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.md:10
#: ../../source/apidocs/evox/evox.operators.mutation.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.md:10
#: ../../source/apidocs/evox/evox.operators.selection.md:10
#: ../../source/apidocs/evox/evox.problems.md:20
#: ../../source/apidocs/evox/evox.problems.neuroevolution.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.md:10
#: ../../source/apidocs/evox/evox.utils.md:10
#: ../../source/apidocs/evox/evox.vis_tools.md:10
#: ../../source/apidocs/evox/evox.workflows.md:10
#, fuzzy
msgid "Submodules"
msgstr "模块类"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:32
msgid "{py:obj}`__all__ <evox.algorithms.de_variants.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.de_variants.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.md:44
msgid "['DE', 'CoDE', 'JaDE', 'ODE', 'SaDE', 'SHADE']"
msgstr "['DE', 'CoDE', 'JaDE', 'ODE', 'SaDE', 'SHADE']"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:1
msgid "{py:mod}`evox.algorithms.de_variants.code`"
msgstr "{py:mod}`evox.algorithms.de_variants.code`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:10
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:10
#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:10
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:10
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:10
#: ../../source/apidocs/evox/evox.core.components.md:10
#: ../../source/apidocs/evox/evox.core.jit_util.md:10
#: ../../source/apidocs/evox/evox.core.module.md:10
#: ../../source/apidocs/evox/evox.metrics.gd.md:10
#: ../../source/apidocs/evox/evox.metrics.hv.md:10
#: ../../source/apidocs/evox/evox.metrics.igd.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:10
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:10
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:10
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:10
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:10
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:10
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:10
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:10
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:10
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:10
#: ../../source/apidocs/evox/evox.utils.control_flow.md:10
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:10
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:10
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:10
#: ../../source/apidocs/evox/evox.vis_tools.plot.md:10
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:10
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:10
#, fuzzy
msgid "Module Contents"
msgstr "模块类"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:12
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:12
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:12
#: ../../source/apidocs/evox/evox.core.components.md:12
#: ../../source/apidocs/evox/evox.core.jit_util.md:12
#: ../../source/apidocs/evox/evox.core.module.md:12
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:12
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:12
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:12
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:12
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:12
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:12
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:12
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:12
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:12
#, fuzzy
msgid "Classes"
msgstr "核心类"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:18
msgid "{py:obj}`CoDE <evox.algorithms.de_variants.code.CoDE>`"
msgstr "{py:obj}`CoDE <evox.algorithms.de_variants.code.CoDE>`"

#: ../../../src/evox/algorithms/de_variants/code.py:20
#: ../../../src/evox/algorithms/de_variants/code.py:111
#, fuzzy
msgid "The implementation of CoDE algorithm."
msgstr "CoDE算法实现"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:30
msgid "{py:obj}`rand_1_bin <evox.algorithms.de_variants.code.rand_1_bin>`"
msgstr "{py:obj}`rand_1_bin <evox.algorithms.de_variants.code.rand_1_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:34
msgid "{py:obj}`rand_2_bin <evox.algorithms.de_variants.code.rand_2_bin>`"
msgstr "{py:obj}`rand_2_bin <evox.algorithms.de_variants.code.rand_2_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:38
msgid ""
"{py:obj}`current2rand_1 <evox.algorithms.de_variants.code.current2rand_1>`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:42
msgid ""
"{py:obj}`rand2best_2_bin <evox.algorithms.de_variants.code.rand2best_2_bin>`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:46
msgid ""
"{py:obj}`current2pbest_1_bin "
"<evox.algorithms.de_variants.code.current2pbest_1_bin>`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:58
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:54
msgid "[0, 0, 1, 0]"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:68
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:64
msgid "[0, 0, 2, 0]"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:78
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:84
msgid "[0, 0, 1, 2]"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:88
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:74
msgid "[0, 1, 2, 0]"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:98
msgid "[3, 2, 1, 0]"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:108
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:30
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:30
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:30
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:94
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:34
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:58
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:30
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:49
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:30
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:30
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:30
msgid "Bases: {py:obj}`evox.core.Algorithm`"
msgstr ""

#: ../../../src/evox/algorithms/de_variants/code.py:113
msgid ""
"Reference: Wang Y, Cai Z, Zhang Q. Differential evolution with composite "
"trial vector generation strategies and control parameters[J]. IEEE "
"transactions on evolutionary computation, 2011, 15(1): 55-66."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md:113
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:35
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:35
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:35
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:99
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:39
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:63
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:35
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:54
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:35
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:35
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:35
#: ../../source/apidocs/evox/evox.core.components.md:47
#: ../../source/apidocs/evox/evox.core.components.md:88
#: ../../source/apidocs/evox/evox.core.components.md:112
#: ../../source/apidocs/evox/evox.core.components.md:144
#: ../../source/apidocs/evox/evox.core.module.md:228
#: ../../source/apidocs/evox/evox.core.module.md:430
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:110
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:43
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:68
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:100
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:102
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:72
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:91
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:122
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:153
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:184
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:215
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:246
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:277
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:35
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:53
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:115
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:139
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:35
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:63
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:35
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:52
msgid "Initialization"
msgstr "初始化"

#: ../../../src/evox/algorithms/de_variants/code.py:117
#, fuzzy
msgid "Initialize the CoDE algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.code.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md
#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md
#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md
#: ../../source/apidocs/evox/evox.core._vmap_fix.md
#: ../../source/apidocs/evox/evox.core.components.md
#: ../../source/apidocs/evox/evox.core.jit_util.md
#: ../../source/apidocs/evox/evox.core.module.md
#: ../../source/apidocs/evox/evox.metrics.gd.md
#: ../../source/apidocs/evox/evox.metrics.hv.md
#: ../../source/apidocs/evox/evox.metrics.igd.md
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md
#: ../../source/apidocs/evox/evox.vis_tools.exv.md
#: ../../source/apidocs/evox/evox.vis_tools.plot.md
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md
msgid "Parameters"
msgstr "参数"

#: ../../../src/evox/algorithms/de_variants/code.py:119
#: ../../../src/evox/algorithms/de_variants/de.py:41
#: ../../../src/evox/algorithms/de_variants/jade.py:41
#: ../../../src/evox/algorithms/de_variants/ode.py:41
#: ../../../src/evox/algorithms/de_variants/sade.py:105
#: ../../../src/evox/algorithms/de_variants/shade.py:41
#: ../../../src/evox/algorithms/es_variants/ars.py:41
#: ../../../src/evox/algorithms/es_variants/asebo.py:41
#: ../../../src/evox/algorithms/es_variants/des.py:41
#: ../../../src/evox/algorithms/es_variants/esmc.py:41
#: ../../../src/evox/algorithms/es_variants/guided_es.py:41
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:41
#: ../../../src/evox/algorithms/es_variants/open_es.py:41
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:41
#: ../../../src/evox/algorithms/es_variants/snes.py:41
#: ../../../src/evox/algorithms/mo/moead.py:60
#: ../../../src/evox/algorithms/mo/nsga2.py:41
#: ../../../src/evox/algorithms/mo/rvea.py:41
#: ../../../src/evox/algorithms/pso_variants/clpso.py:41
#: ../../../src/evox/algorithms/pso_variants/cso.py:41
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:41
#: ../../../src/evox/algorithms/pso_variants/pso.py:41
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:41
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:41
#, fuzzy
msgid "The size of the population."
msgstr "种群大小。"

#: ../../../src/evox/algorithms/de_variants/code.py:120
#: ../../../src/evox/algorithms/de_variants/de.py:42
#: ../../../src/evox/algorithms/de_variants/jade.py:42
#: ../../../src/evox/algorithms/de_variants/sade.py:106
#: ../../../src/evox/algorithms/de_variants/shade.py:42
msgid "The lower bounds of the search space. Must be a 1D tensor."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/code.py:121
#: ../../../src/evox/algorithms/de_variants/de.py:43
#: ../../../src/evox/algorithms/de_variants/jade.py:43
#: ../../../src/evox/algorithms/de_variants/sade.py:107
#: ../../../src/evox/algorithms/de_variants/shade.py:43
msgid "The upper bounds of the search space. Must be a 1D tensor."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/code.py:122
#, fuzzy
msgid "The number of differential padding vectors to use. Defaults to 5."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/de_variants/code.py:123
msgid ""
"A tensor of control parameter pairs for the algorithm. Defaults to a "
"predefined tensor."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/code.py:124
msgid ""
"A boolean indicating whether to replace individuals in the population. "
"Defaults to False."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/code.py:125
#: ../../../src/evox/algorithms/de_variants/de.py:50
#: ../../../src/evox/algorithms/de_variants/ode.py:50
msgid "The device to use for tensor computations. Defaults to None."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/code.py:124
#, fuzzy
msgid "Perform one iteration of the CoDE algorithm."
msgstr "执行CoDE算法的一次迭代。"

#: ../../../src/evox/algorithms/de_variants/code.py:126
msgid "This step is composed of the following steps:"
msgstr ""

#: ../../../src/evox/algorithms/de_variants/code.py:127
msgid "Generate trial vectors using the differential sum."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/code.py:128
msgid "Apply crossover to generate a new vector."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/code.py:129
msgid "Apply mutation to generate a new vector."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/code.py:130
#, fuzzy
msgid "Update the population and fitness values."
msgstr "给出用于评估的候选种群。"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:1
msgid "{py:mod}`evox.algorithms.de_variants.de`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.de.md:18
msgid "{py:obj}`DE <evox.algorithms.de_variants.de.DE>`"
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:20
#: ../../../src/evox/algorithms/de_variants/de.py:33
msgid "Differential Evolution (DE) algorithm for optimization."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:35
msgid ""
"Class "
"Methods/home/bill/Source/evox/src/evox/algorithms/de_variants/de.py:35: "
"(INFO/1) Duplicate implicit target name: \"class methods\"."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:37
msgid ""
"`__init__`: Initializes the DE algorithm with the given parameters, "
"including population size, bounds, mutation strategy, and other "
"hyperparameters."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:38
#: ../../../src/evox/algorithms/de_variants/jade.py:38
#: ../../../src/evox/algorithms/de_variants/ode.py:38
msgid ""
"`init_step`: Performs the initial evaluation of the population's fitness and"
" proceeds to the first optimization step."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:39
msgid ""
"`step`: Executes a single optimization step of the DE algorithm, involving "
"mutation, crossover, and selection processes."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:41
#: ../../../src/evox/algorithms/de_variants/jade.py:41
#: ../../../src/evox/algorithms/de_variants/ode.py:41
msgid ""
"Note that the `evaluate` method is not defined in this class. It is expected"
" to be provided by the `Problem` class or another external component."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:39
#, fuzzy
msgid "Initialize the DE algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/de_variants/de.py:44
#: ../../../src/evox/algorithms/de_variants/ode.py:44
#, fuzzy
msgid ""
"The base vector type used in mutation. Either \"best\" or \"rand\". Defaults"
" to \"rand\"."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/de_variants/de.py:45
#: ../../../src/evox/algorithms/de_variants/jade.py:44
#: ../../../src/evox/algorithms/de_variants/ode.py:45
msgid ""
"The number of difference vectors used in mutation. Must be at least 1 and "
"less than half of the population size. Defaults to 1."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:46
msgid ""
"The differential weight(s) (F) applied to difference vectors. Can be a float"
" or a tensor. Defaults to 0.5."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:47
msgid "The crossover probability (CR). Defaults to 0.9."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:48
#: ../../../src/evox/algorithms/de_variants/jade.py:45
#, fuzzy
msgid ""
"The mean for initializing the population with a normal distribution. "
"Defaults to None."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/de_variants/de.py:49
#: ../../../src/evox/algorithms/de_variants/jade.py:46
msgid ""
"The standard deviation for initializing the population with a normal "
"distribution. Defaults to None."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:46
#: ../../../src/evox/algorithms/de_variants/jade.py:46
#: ../../../src/evox/algorithms/de_variants/ode.py:46
msgid ""
"Perform the initial evaluation of the population's fitness and proceed to "
"the first optimization step."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:48
#: ../../../src/evox/algorithms/de_variants/jade.py:48
#: ../../../src/evox/algorithms/de_variants/ode.py:48
msgid ""
"This method evaluates the fitness of the initial population and then calls "
"the `step` method to perform the first optimization iteration."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:54
#, fuzzy
msgid "Execute a single optimization step of the DE algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/de_variants/de.py:56
#: ../../../src/evox/algorithms/de_variants/jade.py:56
#: ../../../src/evox/algorithms/de_variants/ode.py:56
#: ../../../src/evox/algorithms/de_variants/sade.py:128
#: ../../../src/evox/algorithms/de_variants/shade.py:48
msgid "This involves the following sub-steps:"
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:57
#: ../../../src/evox/algorithms/de_variants/ode.py:57
msgid ""
"Mutation: Generate mutant vectors based on the specified base vector "
"strategy (`best` or `rand`) and the number of difference vectors."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:58
#: ../../../src/evox/algorithms/de_variants/ode.py:58
msgid ""
"Crossover: Perform crossover between the current population and the mutant "
"vectors based on the crossover probability."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:59
#: ../../../src/evox/algorithms/de_variants/jade.py:59
#: ../../../src/evox/algorithms/de_variants/ode.py:59
msgid ""
"Selection: Evaluate the fitness of the new population and select the better "
"individuals between the current and new populations."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/de.py:61
#: ../../../src/evox/algorithms/de_variants/ode.py:62
msgid ""
"The method ensures that all new population vectors are clamped within the "
"specified bounds."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:1
msgid "{py:mod}`evox.algorithms.de_variants.jade`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md:18
msgid "{py:obj}`JaDE <evox.algorithms.de_variants.jade.JaDE>`"
msgstr ""

#: ../../../src/evox/algorithms/de_variants/jade.py:20
#: ../../../src/evox/algorithms/de_variants/jade.py:33
msgid "Adaptive Differential Evolution (JaDE) algorithm for optimization."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/jade.py:35
msgid ""
"Class "
"Methods/home/bill/Source/evox/src/evox/algorithms/de_variants/jade.py:35: "
"(INFO/1) Duplicate implicit target name: \"class methods\"."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/jade.py:37
msgid ""
"`__init__`: Initializes the JaDE algorithm with the given parameters, "
"including population size, bounds, mutation strategy, and other "
"hyperparameters."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/jade.py:39
msgid ""
"`step`: Executes a single optimization step of the JaDE algorithm, involving"
" mutation, crossover, selection, and adaptation of strategy parameters."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/jade.py:39
msgid "Initialize the JaDE algorithm with the given parameters."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/jade.py:47
#: ../../../src/evox/algorithms/de_variants/sade.py:110
#: ../../../src/evox/algorithms/de_variants/shade.py:45
msgid ""
"The device to use for tensor computations (e.g., \"cpu\" or \"cuda\"). "
"Defaults to None."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/jade.py:48
msgid ""
"The learning rate for updating the adaptive parameters F_u and CR_u. "
"Defaults to 0.1."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/jade.py:54
#, fuzzy
msgid "Execute a single optimization step of the JaDE algorithm."
msgstr "创建一个基础算法的列表。"

#: ../../../src/evox/algorithms/de_variants/jade.py:57
msgid ""
"Mutation: Generate mutant vectors by combining difference vectors and "
"adapting the mutation factor F."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/jade.py:58
msgid ""
"Crossover: Perform crossover between the current population and the mutant "
"vectors based on the crossover probability CR."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/jade.py:60
msgid ""
"Adaptation: Update the adaptive parameters F_u and CR_u based on the "
"successful mutations."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/jade.py:62
#, fuzzy
msgid "Select p-best vectors from the population for mutation."
msgstr "给出用于评估的候选种群。"

#: ../../../src/evox/algorithms/de_variants/jade.py:64
msgid ""
"Fraction of the population to consider as top-p best. Must be between 0 and "
"1."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.jade.md
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md
#: ../../source/apidocs/evox/evox.core._vmap_fix.md
#: ../../source/apidocs/evox/evox.core.components.md
#: ../../source/apidocs/evox/evox.core.jit_util.md
#: ../../source/apidocs/evox/evox.core.module.md
#: ../../source/apidocs/evox/evox.metrics.gd.md
#: ../../source/apidocs/evox/evox.metrics.hv.md
#: ../../source/apidocs/evox/evox.metrics.igd.md
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md
#: ../../source/apidocs/evox/evox.vis_tools.plot.md
msgid "Returns"
msgstr "返回值"

#: ../../../src/evox/algorithms/de_variants/jade.py:65
msgid "A tensor containing selected p-best vectors."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:1
msgid "{py:mod}`evox.algorithms.de_variants.ode`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.ode.md:18
msgid "{py:obj}`ODE <evox.algorithms.de_variants.ode.ODE>`"
msgstr ""

#: ../../../src/evox/algorithms/de_variants/ode.py:20
#: ../../../src/evox/algorithms/de_variants/ode.py:33
msgid ""
"Opposition-based Differential Evolution (ODE) algorithm for optimization."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/ode.py:35
msgid ""
"Class "
"Methods/home/bill/Source/evox/src/evox/algorithms/de_variants/ode.py:35: "
"(INFO/1) Duplicate implicit target name: \"class methods\"."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/ode.py:37
msgid ""
"`__init__`: Initializes the ODE algorithm with the given parameters, "
"including population size, bounds, mutation strategy, and other "
"hyperparameters."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/ode.py:39
msgid ""
"`step`: Executes a single optimization step of the ODE algorithm, involving "
"mutation, crossover, selection, and opposition-based mechanisms."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/ode.py:39
msgid ""
"Initialize the Opposition-based Differential Evolution (ODE) algorithm with "
"the given parameters."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/ode.py:42
#: ../../../src/evox/algorithms/pso_variants/clpso.py:42
#: ../../../src/evox/algorithms/pso_variants/cso.py:42
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:41
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:42
#: ../../../src/evox/algorithms/pso_variants/pso.py:45
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:42
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:42
msgid "The lower bounds of the particle positions. Must be a 1D tensor."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/ode.py:43
#: ../../../src/evox/algorithms/pso_variants/clpso.py:43
#: ../../../src/evox/algorithms/pso_variants/cso.py:43
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:42
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:43
#: ../../../src/evox/algorithms/pso_variants/pso.py:46
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:43
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:43
msgid "The upper bounds of the particle positions. Must be a 1D tensor."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/ode.py:46
msgid ""
"The differential weight(s) (F) applied to difference vectors. Can be a float"
" or a tensor of shape [num_difference_vectors]. Defaults to 0.5."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/ode.py:47
msgid "The crossover probability (CR). Must be in (0, 1]. Defaults to 0.9."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/ode.py:48
msgid ""
"The mean for initializing the population with a normal distribution. Must be"
" provided with stdev if used. Defaults to None."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/ode.py:49
msgid ""
"The standard deviation for initializing the population with a normal "
"distribution. Must be provided with mean if used. Defaults to None."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/ode.py:54
#, fuzzy
msgid "Execute a single optimization step of the ODE algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/de_variants/ode.py:60
msgid ""
"Opposition-Based Mechanism: Generate opposition-based population, evaluate "
"their fitness, and perform selection to potentially replace current "
"individuals with their opposites if they are better."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:1
msgid "{py:mod}`evox.algorithms.de_variants.sade`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:18
msgid "{py:obj}`SaDE <evox.algorithms.de_variants.sade.SaDE>`"
msgstr ""

#: ../../../src/evox/algorithms/de_variants/sade.py:20
#: ../../../src/evox/algorithms/de_variants/sade.py:97
#, fuzzy
msgid "The implementation of SaDE algorithm."
msgstr "算法的新状态"

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:30
msgid "{py:obj}`rand_1_bin <evox.algorithms.de_variants.sade.rand_1_bin>`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:34
msgid "{py:obj}`rand_2_bin <evox.algorithms.de_variants.sade.rand_2_bin>`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:38
msgid ""
"{py:obj}`rand2best_2_bin <evox.algorithms.de_variants.sade.rand2best_2_bin>`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.sade.md:42
msgid ""
"{py:obj}`current2rand_1 <evox.algorithms.de_variants.sade.current2rand_1>`"
msgstr ""

#: ../../../src/evox/algorithms/de_variants/sade.py:99
msgid ""
"Reference: Qin A K, Huang V L, Suganthan P N. Differential evolution "
"algorithm with strategy adaptation for global numerical optimization[J]. "
"IEEE transactions on Evolutionary Computation, 2008, 13(2): 398-417."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/sade.py:103
#, fuzzy
msgid "Initialize the SaDE algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/de_variants/sade.py:108
#: ../../../src/evox/algorithms/de_variants/shade.py:44
#, fuzzy
msgid "The number of differential padding vectors to use. Defaults to 9."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/de_variants/sade.py:109
#, fuzzy
msgid "The size of memory. Defaults to 50."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/de_variants/sade.py:126
#, fuzzy
msgid "Execute a single optimization step of the SaDE algorithm."
msgstr "创建一个基础算法的列表。"

#: ../../../src/evox/algorithms/de_variants/sade.py:129
msgid "Generate new population using differential evolution."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/sade.py:130
#, fuzzy
msgid "Evaluate the fitness of the new population."
msgstr "评估给定候选解的适应度。"

#: ../../../src/evox/algorithms/de_variants/sade.py:131
msgid "Update the best individual and best fitness."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/sade.py:132
msgid "Update the success and failure memory."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/sade.py:133
msgid "Update the CR memory."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:1
msgid "{py:mod}`evox.algorithms.de_variants.shade`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.de_variants.shade.md:18
msgid "{py:obj}`SHADE <evox.algorithms.de_variants.shade.SHADE>`"
msgstr ""

#: ../../../src/evox/algorithms/de_variants/shade.py:20
#: ../../../src/evox/algorithms/de_variants/shade.py:33
#, fuzzy
msgid "The implementation of SHADE algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/de_variants/shade.py:35
msgid ""
"Reference: Tanabe R, Fukunaga A. Success-history based parameter adaptation "
"for differential evolution[C]//2013 IEEE congress on evolutionary "
"computation. IEEE, 2013: 71-78."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/shade.py:39
#, fuzzy
msgid "Initialize the SHADE algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/de_variants/shade.py:46
#, fuzzy
msgid "Perform a single step of the SHADE algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/de_variants/shade.py:49
msgid "Generate trial vectors using the SHADE algorithm."
msgstr ""

#: ../../../src/evox/algorithms/de_variants/shade.py:50
#, fuzzy
msgid "Evaluate the fitness of the trial vectors."
msgstr "评估给定候选解的适应度。"

#: ../../../src/evox/algorithms/de_variants/shade.py:51
#, fuzzy
msgid "Update the population."
msgstr "种群。"

#: ../../../src/evox/algorithms/de_variants/shade.py:52
msgid "Update the memory."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:1
msgid "{py:mod}`evox.algorithms.es_variants`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:39
msgid "{py:obj}`__all__ <evox.algorithms.es_variants.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.md:51
msgid ""
"['OpenES', 'XNES', 'SeparableNES', 'DES', 'SNES', 'ARS', 'ASEBO', "
"'PersistentES', 'NoiseReuseES', 'G..."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:1
msgid "{py:mod}`evox.algorithms.es_variants.adam_step`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:12
#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:24
#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:12
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:12
#: ../../source/apidocs/evox/evox.core.jit_util.md:22
#: ../../source/apidocs/evox/evox.core.module.md:30
#: ../../source/apidocs/evox/evox.metrics.gd.md:12
#: ../../source/apidocs/evox/evox.metrics.hv.md:12
#: ../../source/apidocs/evox/evox.metrics.igd.md:12
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:12
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:12
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:12
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:12
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:12
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:12
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:12
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:12
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:24
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:12
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:24
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:24
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:48
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:12
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:24
#: ../../source/apidocs/evox/evox.vis_tools.plot.md:12
#, fuzzy
msgid "Functions"
msgstr "测试函数"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.adam_step.md:18
msgid ""
"{py:obj}`adam_single_tensor "
"<evox.algorithms.es_variants.adam_step.adam_single_tensor>`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:1
msgid "{py:mod}`evox.algorithms.es_variants.ars`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.ars.md:18
msgid "{py:obj}`ARS <evox.algorithms.es_variants.ars.ARS>`"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/ars.py:20
#: ../../../src/evox/algorithms/es_variants/ars.py:33
#, fuzzy
msgid "The implementation of the ARS algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/ars.py:35
msgid ""
"Reference: Simple random search provides a competitive approach to "
"reinforcement learning (https://arxiv.org/pdf/1803.07055.pdf)"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/ars.py:38
#: ../../../src/evox/algorithms/es_variants/asebo.py:39
#: ../../../src/evox/algorithms/es_variants/des.py:39
#: ../../../src/evox/algorithms/es_variants/esmc.py:39
#: ../../../src/evox/algorithms/es_variants/guided_es.py:39
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:39
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:39
#: ../../../src/evox/algorithms/es_variants/snes.py:39
msgid ""
"This code has been inspired by or utilizes the algorithmic implementation "
"from evosax. More information about evosax can be found at the following "
"URL: GitHub Link: https://github.com/RobertTLange/evosax"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/ars.py:39
#: ../../../src/evox/algorithms/es_variants/asebo.py:39
#, fuzzy
msgid "Initialize the ARS algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/ars.py:42
#: ../../../src/evox/algorithms/es_variants/asebo.py:42
#: ../../../src/evox/algorithms/es_variants/des.py:42
#: ../../../src/evox/algorithms/es_variants/esmc.py:42
#: ../../../src/evox/algorithms/es_variants/guided_es.py:42
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:42
#: ../../../src/evox/algorithms/es_variants/open_es.py:42
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:42
#: ../../../src/evox/algorithms/es_variants/snes.py:42
msgid "The initial center of the population. Must be a 1D tensor."
msgstr ""

#: ../../../src/evox/algorithms/es_variants/ars.py:43
#: ../../../src/evox/algorithms/es_variants/esmc.py:43
#, fuzzy
msgid "The ratio of elite population. Defaults to 0.1."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/ars.py:44
#: ../../../src/evox/algorithms/es_variants/asebo.py:44
#: ../../../src/evox/algorithms/es_variants/esmc.py:44
#: ../../../src/evox/algorithms/es_variants/guided_es.py:44
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:44
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:44
#, fuzzy
msgid "The learning rate for the optimizer. Defaults to 0.05."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/algorithms/es_variants/ars.py:45
#: ../../../src/evox/algorithms/es_variants/asebo.py:47
#: ../../../src/evox/algorithms/es_variants/guided_es.py:45
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:45
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:45
#, fuzzy
msgid "The standard deviation of the noise. Defaults to 0.03."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/ars.py:46
#: ../../../src/evox/algorithms/es_variants/asebo.py:43
#: ../../../src/evox/algorithms/es_variants/esmc.py:47
#: ../../../src/evox/algorithms/es_variants/guided_es.py:43
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:43
#: ../../../src/evox/algorithms/es_variants/open_es.py:45
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:43
#: ../../../src/evox/algorithms/es_variants/snes.py:43
msgid ""
"The optimizer to use. Defaults to None. Currently, only \"adam\" or None is "
"supported."
msgstr ""

#: ../../../src/evox/algorithms/es_variants/ars.py:47
#: ../../../src/evox/algorithms/es_variants/asebo.py:51
#: ../../../src/evox/algorithms/es_variants/cma_es.py:45
#: ../../../src/evox/algorithms/es_variants/des.py:45
#: ../../../src/evox/algorithms/es_variants/esmc.py:48
#: ../../../src/evox/algorithms/es_variants/guided_es.py:49
#: ../../../src/evox/algorithms/es_variants/nes.py:53
#: ../../../src/evox/algorithms/es_variants/nes.py:75
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:50
#: ../../../src/evox/algorithms/es_variants/open_es.py:47
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:50
#: ../../../src/evox/algorithms/es_variants/snes.py:48
#: ../../../src/evox/algorithms/pso_variants/clpso.py:47
#: ../../../src/evox/algorithms/pso_variants/cso.py:47
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:53
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:50
#: ../../../src/evox/algorithms/pso_variants/pso.py:47
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:47
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:47
msgid "The device to use for the tensors. Defaults to None."
msgstr ""

#: ../../../src/evox/algorithms/es_variants/ars.py:46
#, fuzzy
msgid "Perform a single step of the ARS algorithm."
msgstr "算法的新状态"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:1
msgid "{py:mod}`evox.algorithms.es_variants.asebo`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.asebo.md:18
msgid "{py:obj}`ASEBO <evox.algorithms.es_variants.asebo.ASEBO>`"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/asebo.py:20
#: ../../../src/evox/algorithms/es_variants/asebo.py:33
#, fuzzy
msgid "The implementation of the ASEBO algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/asebo.py:35
msgid ""
"Reference: From Complexity to Simplicity: Adaptive ES-Active Subspaces for "
"Blackbox Optimization (https://arxiv.org/abs/1903.04268)"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/asebo.py:45
#, fuzzy
msgid "The decay factor for the learning rate. Defaults to 1.0."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:46
#, fuzzy
msgid "The minimum value for the learning rate. Defaults to 0.001."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:48
#: ../../../src/evox/algorithms/es_variants/esmc.py:45
#: ../../../src/evox/algorithms/es_variants/guided_es.py:46
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:46
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:46
#, fuzzy
msgid "The decay factor for the standard deviation. Defaults to 1.0."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:49
#: ../../../src/evox/algorithms/es_variants/esmc.py:46
#: ../../../src/evox/algorithms/es_variants/guided_es.py:47
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:47
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:47
#, fuzzy
msgid "The minimum value for the standard deviation. Defaults to 0.01."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:50
#: ../../../src/evox/algorithms/es_variants/guided_es.py:48
#, fuzzy
msgid "The dimension of the subspace. Defaults to None."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/algorithms/es_variants/asebo.py:46
#, fuzzy
msgid "The main step of the ASEBO algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/asebo.py:48
msgid ""
"This function first computes the subspace spanned by the gradient of the "
"fitness function and then projects the gradient onto the subspace. It then "
"computes the step direction using the projected gradient and updates the "
"center and standard deviation of the search distribution."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.cma_es`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.cma_es.md:18
msgid "{py:obj}`CMAES <evox.algorithms.es_variants.cma_es.CMAES>`"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/cma_es.py:20
#: ../../../src/evox/algorithms/es_variants/cma_es.py:33
#, fuzzy
msgid ""
"The CMA-ES algorithm as described in \"The CMA Evolution Strategy: A "
"Tutorial\" from https://arxiv.org/abs/1604.00772."
msgstr ""
"这个实现遵循了《CMA 演化策略：教程》（The CMA Evolution Strategy: A "
"Tutorial），详情可见：https://arxiv.org/pdf/1604.00772.pdf。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:39
msgid "Initialize the CMA-ES algorithm with the given parameters."
msgstr ""

#: ../../../src/evox/algorithms/es_variants/cma_es.py:41
#, fuzzy
msgid "The size of the population with the notation \\lambda."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:42
msgid "The initial mean of the population. Must be a 1D tensor."
msgstr ""

#: ../../../src/evox/algorithms/es_variants/cma_es.py:43
msgid "The overall standard deviation, i.e., the step size of the algorithm."
msgstr ""

#: ../../../src/evox/algorithms/es_variants/cma_es.py:44
msgid ""
"The recombination weights of the population. Defaults to None and is "
"calculated automatically with recommended values."
msgstr ""

#: ../../../src/evox/algorithms/es_variants/cma_es.py:46
#, fuzzy
msgid "The main step of the CMA-ES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/cma_es.py:48
msgid ""
"In this step, the algorithm generates a new population, evaluates it, and "
"updates the mean, covariance matrix, and step size correspondingly."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:1
msgid "{py:mod}`evox.algorithms.es_variants.des`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.des.md:18
msgid "{py:obj}`DES <evox.algorithms.es_variants.des.DES>`"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/des.py:20
#: ../../../src/evox/algorithms/es_variants/des.py:33
#: ../../../src/evox/algorithms/es_variants/esmc.py:20
#: ../../../src/evox/algorithms/es_variants/esmc.py:33
#, fuzzy
msgid "The implementation of the DES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/des.py:35
msgid ""
"Reference: Discovering Evolution Strategies via Meta-Black-Box Optimization "
"(https://arxiv.org/abs/2211.11260)"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/des.py:39
#, fuzzy
msgid "Initialize the DES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/des.py:43
#, fuzzy
msgid "The temperature parameter for the softmax. Defaults to 12.5."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/algorithms/es_variants/des.py:44
#, fuzzy
msgid "The initial standard deviation of the noise. Defaults to 0.1."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/des.py:46
msgid ""
"Step the DES algorithm by sampling the population, evaluating the fitness, "
"and updating the center."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:1
msgid "{py:mod}`evox.algorithms.es_variants.esmc`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.esmc.md:18
msgid "{py:obj}`ESMC <evox.algorithms.es_variants.esmc.ESMC>`"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/esmc.py:35
msgid ""
"Reference: Learn2Hop: Learned Optimization on Rough Landscapes "
"(https://proceedings.mlr.press/v139/merchant21a.html)"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/esmc.py:39
#, fuzzy
msgid "Initialize the ESMC algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/esmc.py:46
#, fuzzy
msgid "One iteration of the ESMC algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/esmc.py:48
msgid ""
"This function will sample a population, evaluate their fitness, and then "
"update the center and standard deviation of the algorithm using the sampled "
"population."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.guided_es`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.guided_es.md:18
msgid "{py:obj}`GuidedES <evox.algorithms.es_variants.guided_es.GuidedES>`"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/guided_es.py:20
#: ../../../src/evox/algorithms/es_variants/guided_es.py:33
#, fuzzy
msgid "The implementation of the Guided-ES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/guided_es.py:35
msgid ""
"Reference: Guided evolutionary strategies: Augmenting random search with "
"surrogate gradients (https://arxiv.org/abs/1806.10230)"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/guided_es.py:39
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:39
#, fuzzy
msgid "Initialize the Guided-ES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/guided_es.py:46
#, fuzzy
msgid "Run one step of the Guided-ES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/guided_es.py:48
#: ../../../src/evox/algorithms/es_variants/snes.py:48
msgid ""
"The function will sample a population, evaluate their fitness, and then "
"update the center and standard deviation of the algorithm using the sampled "
"population."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:1
msgid "{py:mod}`evox.algorithms.es_variants.nes`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:18
msgid "{py:obj}`XNES <evox.algorithms.es_variants.nes.XNES>`"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/nes.py:20
#: ../../../src/evox/algorithms/es_variants/nes.py:37
#, fuzzy
msgid "The implementation of the xNES algorithm."
msgstr "算法的新状态"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.nes.md:22
msgid "{py:obj}`SeparableNES <evox.algorithms.es_variants.nes.SeparableNES>`"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/nes.py:24
#: ../../../src/evox/algorithms/es_variants/nes.py:61
#, fuzzy
msgid "The implementation of the Separable NES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/nes.py:39
msgid ""
"Reference: Exponential Natural Evolution Strategies "
"(https://dl.acm.org/doi/abs/10.1145/1830483.1830557)"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/nes.py:43
#, fuzzy
msgid "Initialize the xNES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/nes.py:45
#: ../../../src/evox/algorithms/es_variants/nes.py:69
msgid "The initial mean vector of the population. Must be a 1D tensor."
msgstr ""

#: ../../../src/evox/algorithms/es_variants/nes.py:46
msgid "The initial covariance matrix of the population. Must be a 2D tensor."
msgstr ""

#: ../../../src/evox/algorithms/es_variants/nes.py:47
#: ../../../src/evox/algorithms/es_variants/nes.py:71
#, fuzzy
msgid "The size of the population. Defaults to None."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/algorithms/es_variants/nes.py:48
#: ../../../src/evox/algorithms/es_variants/nes.py:72
#, fuzzy
msgid "The recombination weights of the population. Defaults to None."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/algorithms/es_variants/nes.py:49
#: ../../../src/evox/algorithms/es_variants/nes.py:73
#, fuzzy
msgid "The learning rate for the mean vector. Defaults to None."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/nes.py:50
#: ../../../src/evox/algorithms/es_variants/nes.py:74
#, fuzzy
msgid "The learning rate for the variance vector. Defaults to None."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/algorithms/es_variants/nes.py:51
#, fuzzy
msgid "The learning rate for the B matrix. Defaults to None."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/algorithms/es_variants/nes.py:52
#, fuzzy
msgid ""
"Whether to use the covariance matrix as a Cholesky factorization result. "
"Defaults to False."
msgstr "是否是多目标优化。默认为False。"

#: ../../../src/evox/algorithms/es_variants/nes.py:50
#, fuzzy
msgid "Run one step of the xNES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/nes.py:52
#: ../../../src/evox/algorithms/es_variants/nes.py:76
msgid ""
"The function will sample a population, evaluate their fitness, and then "
"update the center and covariance of the algorithm using the sampled "
"population."
msgstr ""

#: ../../../src/evox/algorithms/es_variants/nes.py:63
#: ../../../src/evox/algorithms/es_variants/snes.py:35
msgid ""
"Reference: Natural Evolution Strategies "
"(https://www.jmlr.org/papers/volume15/wierstra14a/wierstra14a.pdf)"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/nes.py:67
#, fuzzy
msgid "Initialize the Separable NES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/nes.py:70
msgid ""
"The initial standard deviation for each dimension. Must be a 1D tensor."
msgstr ""

#: ../../../src/evox/algorithms/es_variants/nes.py:74
#, fuzzy
msgid "Run one step of the Separable NES algorithm."
msgstr "算法的新状态"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.noise_reuse_es`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.noise_reuse_es.md:18
msgid ""
"{py:obj}`NoiseReuseES "
"<evox.algorithms.es_variants.noise_reuse_es.NoiseReuseES>`"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:20
#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:33
#, fuzzy
msgid "The implementation of the Noise-Reuse-ES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:35
msgid ""
"Reference: Noise-Reuse in Online Evolution Strategies "
"(https://arxiv.org/pdf/2304.12180.pdf)"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:48
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:48
#, fuzzy
msgid "The inner problem length. Defaults to 100."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:49
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:49
#, fuzzy
msgid "The number of inner problems. Defaults to 10."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:46
#, fuzzy
msgid "Take a single step of the NoiseReuseES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/noise_reuse_es.py:48
msgid ""
"This function follows the algorithm described in the reference paper. It "
"first generates a set of perturbations for the current population. Then, it "
"evaluates the fitness of the population with the perturbations. Afterwards, "
"it calculates the gradient of the policy parameters using the perturbations "
"and the fitness. Finally, it updates the policy parameters using the "
"gradient and the learning rate."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.open_es`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.open_es.md:18
msgid "{py:obj}`OpenES <evox.algorithms.es_variants.open_es.OpenES>`"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/open_es.py:20
#: ../../../src/evox/algorithms/es_variants/open_es.py:33
#, fuzzy
msgid ""
"The OpenES algorithm as described in \"Evolution Strategies as a Scalable "
"Alternative to Reinforcement Learning\" from "
"https://arxiv.org/abs/1703.03864."
msgstr ""
"实现论文 \"Evolution Strategies as a Scalable Alternative to Reinforcement "
"Learning\" 中描述的算法，链接为https://arxiv.org/abs/1703.03864"

#: ../../../src/evox/algorithms/es_variants/open_es.py:39
#, fuzzy
msgid "Initialize the OpenES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/open_es.py:43
msgid "The learning rate for the optimizer."
msgstr ""

#: ../../../src/evox/algorithms/es_variants/open_es.py:44
msgid "The standard deviation of the noise."
msgstr ""

#: ../../../src/evox/algorithms/es_variants/open_es.py:46
#, fuzzy
msgid "Whether to use mirrored sampling. Defaults to True."
msgstr "是否对整个步骤函数进行 `jit` 编译。默认值为 `True`"

#: ../../../src/evox/algorithms/es_variants/open_es.py:46
msgid ""
"Step the OpenES algorithm by evaluating the fitness of the current "
"population and updating the center."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:1
msgid "{py:mod}`evox.algorithms.es_variants.persistent_es`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.persistent_es.md:18
msgid ""
"{py:obj}`PersistentES "
"<evox.algorithms.es_variants.persistent_es.PersistentES>`"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/persistent_es.py:20
#: ../../../src/evox/algorithms/es_variants/persistent_es.py:33
#, fuzzy
msgid "The implementation of the Persistent ES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/persistent_es.py:35
msgid ""
"Reference: Unbiased Gradient Estimation in Unrolled Computation Graphs with "
"Persistent Evolution Strategies "
"(http://proceedings.mlr.press/v139/vicol21a.html)"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/persistent_es.py:39
#, fuzzy
msgid "Initialize the Persistent-ES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:1
msgid "{py:mod}`evox.algorithms.es_variants.snes`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.snes.md:18
msgid "{py:obj}`SNES <evox.algorithms.es_variants.snes.SNES>`"
msgstr ""

#: ../../../src/evox/algorithms/es_variants/snes.py:20
#: ../../../src/evox/algorithms/es_variants/snes.py:33
#, fuzzy
msgid "The implementation of the SNES algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/es_variants/snes.py:39
#, fuzzy
msgid "Initialize the SNES algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/es_variants/snes.py:44
#, fuzzy
msgid "The learning rate for the mean. Defaults to 1.0."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/algorithms/es_variants/snes.py:45
#, fuzzy
msgid "The standard deviation of the noise. Defaults to 1.0."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/snes.py:46
#, fuzzy
msgid "The temperature of the softmax in computing weights. Defaults to 12.5."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/es_variants/snes.py:47
#, fuzzy
msgid "The type of weights to use. Defaults to \"temp\"."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/algorithms/es_variants/snes.py:46
#, fuzzy
msgid "Run one step of the SNES algorithm."
msgstr "算法的新状态"

#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:1
msgid "{py:mod}`evox.algorithms.es_variants.sort_utils`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.es_variants.sort_utils.md:18
msgid ""
"{py:obj}`sort_by_key <evox.algorithms.es_variants.sort_utils.sort_by_key>`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.mo.md:1
msgid "{py:mod}`evox.algorithms.mo`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.mo.md:29
msgid "{py:obj}`__all__ <evox.algorithms.mo.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.mo.md:41
msgid "['RVEA', 'NSGA2', 'MOEAD']"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:1
msgid "{py:mod}`evox.algorithms.mo.moead`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:18
msgid "{py:obj}`MOEAD <evox.algorithms.mo.moead.MOEAD>`"
msgstr ""

#: ../../../src/evox/algorithms/mo/moead.py:20
#: ../../../src/evox/algorithms/mo/moead.py:52
msgid "Implementation of the Original MOEA/D algorithm."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:30
msgid "{py:obj}`pbi <evox.algorithms.mo.moead.pbi>`"
msgstr ""

#: ../../../src/evox/algorithms/mo/moead.py:54
#: ../../../src/evox/algorithms/mo/nsga2.py:38
#: ../../../src/evox/algorithms/mo/rvea.py:37
#, fuzzy
msgid "References"
msgstr "API文档"

#: ../../../src/evox/algorithms/mo/moead.py:55
msgid ""
"\"MOEA/D: A Multiobjective Evolutionary Algorithm Based on Decomposition,\" "
"IEEE Transactions on Evolutionary Computation. `Link "
"<https://ieeexplore.ieee.org/document/4358754>`_"
msgstr ""

#: ../../../src/evox/algorithms/mo/moead.py:59
#: ../../../src/evox/metrics/gd.py:39 ../../../src/evox/metrics/igd.py:40
#: ../../../src/evox/operators/selection/non_dominate.py:113
#: ../../../src/evox/operators/selection/rvea_selection.py:56
#: ../../../src/evox/utils/jit_fix_operator.py:182
#, fuzzy
msgid "Note"
msgstr "Notes"

#: ../../../src/evox/algorithms/mo/moead.py:59
msgid ""
"This implementation is based on the original paper and may not be the most "
"efficient implementation. It can not be traced by JIT."
msgstr ""

#: ../../../src/evox/algorithms/mo/moead.py:58
#, fuzzy
msgid "Initializes the MOEA/D algorithm."
msgstr "并行MOEA/D算法"

#: ../../../src/evox/algorithms/mo/moead.py:61
#: ../../../src/evox/algorithms/mo/nsga2.py:42
#: ../../../src/evox/algorithms/mo/rvea.py:42
msgid "The number of objective functions in the optimization problem."
msgstr ""

#: ../../../src/evox/algorithms/mo/moead.py:62
#: ../../../src/evox/algorithms/mo/nsga2.py:43
msgid "The lower bounds for the decision variables (1D tensor)."
msgstr ""

#: ../../../src/evox/algorithms/mo/moead.py:63
#: ../../../src/evox/algorithms/mo/nsga2.py:44
msgid "The upper bounds for the decision variables (1D tensor)."
msgstr ""

#: ../../../src/evox/algorithms/mo/moead.py:64
#: ../../../src/evox/algorithms/mo/nsga2.py:45
#: ../../../src/evox/algorithms/mo/rvea.py:48
msgid "The selection operation for evolutionary strategy (optional)."
msgstr ""

#: ../../../src/evox/algorithms/mo/moead.py:65
#: ../../../src/evox/algorithms/mo/nsga2.py:46
msgid ""
"The mutation operation, defaults to polynomial_mutation if not provided "
"(optional)."
msgstr ""

#: ../../../src/evox/algorithms/mo/moead.py:66
msgid ""
"The crossover operation, defaults to simulated_binary_half if not provided "
"(optional)."
msgstr ""

#: ../../../src/evox/algorithms/mo/moead.py:67
#: ../../../src/evox/algorithms/mo/nsga2.py:48
msgid ""
"The device on which computations should run (optional). Defaults to "
"PyTorch's default device."
msgstr ""

#: ../../../src/evox/algorithms/mo/moead.py:65
#: ../../../src/evox/algorithms/mo/nsga2.py:46
#: ../../../src/evox/algorithms/mo/rvea.py:46
msgid "Perform the initialization step of the workflow."
msgstr ""

#: ../../../src/evox/algorithms/mo/moead.py:67
#: ../../../src/evox/algorithms/mo/nsga2.py:48
#: ../../../src/evox/algorithms/mo/rvea.py:48
#: ../../../src/evox/workflows/std_workflow.py:107
msgid ""
"Calls the `init_step` of the algorithm if overwritten; otherwise, its `step`"
" method will be invoked."
msgstr ""

#: ../../../src/evox/algorithms/mo/moead.py:73
msgid "Perform a single optimization step of the workflow."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:1
msgid "{py:mod}`evox.algorithms.mo.nsga2`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:18
msgid "{py:obj}`NSGA2 <evox.algorithms.mo.nsga2.NSGA2>`"
msgstr ""

#: ../../../src/evox/algorithms/mo/nsga2.py:20
#: ../../../src/evox/algorithms/mo/nsga2.py:33
msgid ""
"An implementation of the Non-dominated Sorting Genetic Algorithm II (NSGA-"
"II) for multi-objective optimization problems."
msgstr ""

#: ../../../src/evox/algorithms/mo/nsga2.py:35
msgid ""
"This class provides a framework for solving multi-objective optimization "
"problems using a non-dominated sorting genetic algorithm, which is widely "
"used for Pareto-based optimization."
msgstr ""

#: ../../../src/evox/algorithms/mo/nsga2.py:39
msgid ""
"\"A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II,\" IEEE "
"Transactions on Evolutionary Computation. `Link "
"<https://ieeexplore.ieee.org/document/996017>`_"
msgstr ""

#: ../../../src/evox/algorithms/mo/nsga2.py:39
#, fuzzy
msgid "Initializes the NSGA-II algorithm."
msgstr "NSGA-II算法"

#: ../../../src/evox/algorithms/mo/nsga2.py:47
msgid ""
"The crossover operation, defaults to simulated_binary if not provided "
"(optional)."
msgstr ""

#: ../../../src/evox/algorithms/mo/nsga2.py:54
msgid "Perform the optimization step of the workflow."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:1
msgid "{py:mod}`evox.algorithms.mo.rvea`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:18
msgid "{py:obj}`RVEA <evox.algorithms.mo.rvea.RVEA>`"
msgstr ""

#: ../../../src/evox/algorithms/mo/rvea.py:20
#: ../../../src/evox/algorithms/mo/rvea.py:33
msgid ""
"An implementation of the Reference Vector Guided Evolutionary Algorithm "
"(RVEA) for multi-objective optimization problems."
msgstr ""

#: ../../../src/evox/algorithms/mo/rvea.py:35
msgid ""
"This class is designed to solve multi-objective optimization problems using "
"a reference vector guided evolutionary algorithm."
msgstr ""

#: ../../../src/evox/algorithms/mo/rvea.py:38
msgid ""
"\"A Reference Vector Guided Evolutionary Algorithm for Many-Objective "
"Optimization,\" IEEE. `Link <https://ieeexplore.ieee.org/document/7386636>`"
msgstr ""

#: ../../../src/evox/algorithms/mo/rvea.py:40
msgid ""
"\"GPU-accelerated Evolutionary Multiobjective Optimization Using Tensorized "
"RVEA\" ACM. `Link <https://dl.acm.org/doi/abs/10.1145/3638529.3654223>`"
msgstr ""

#: ../../../src/evox/algorithms/mo/rvea.py:39
#, fuzzy
msgid "Initialize the RVEA algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/mo/rvea.py:43
#: ../../../src/evox/operators/mutation/pm_mutation.py:34
msgid "The lower bounds for the decision variables."
msgstr ""

#: ../../../src/evox/algorithms/mo/rvea.py:44
#: ../../../src/evox/operators/mutation/pm_mutation.py:35
msgid "The upper bounds for the decision variables."
msgstr ""

#: ../../../src/evox/algorithms/mo/rvea.py:45
msgid ""
"A parameter for controlling the rate of change of penalty. Defaults to 2."
msgstr ""

#: ../../../src/evox/algorithms/mo/rvea.py:46
msgid "The frequency of reference vector adaptation. Defaults to 0.1."
msgstr ""

#: ../../../src/evox/algorithms/mo/rvea.py:47
#, fuzzy
msgid "The maximum number of generations. Defaults to 100."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/mo/rvea.py:49
msgid "The mutation operation (optional)."
msgstr ""

#: ../../../src/evox/algorithms/mo/rvea.py:50
msgid "The crossover operation (optional)."
msgstr ""

#: ../../../src/evox/algorithms/mo/rvea.py:51
msgid "The device on which computations should run (optional)."
msgstr ""

#: ../../../src/evox/algorithms/mo/rvea.py:102
#, fuzzy
msgid "Perform a single optimization step."
msgstr "🌐 **多功能优化套件**:"

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:1
msgid "{py:mod}`evox.algorithms.pso_variants`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:34
msgid "{py:obj}`__all__ <evox.algorithms.pso_variants.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.md:46
msgid "['CLPSO', 'CSO', 'DMSPSOEL', 'FSPSO', 'PSO', 'SLPSOGS', 'SLPSOUS']"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.clpso`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.clpso.md:18
msgid "{py:obj}`CLPSO <evox.algorithms.pso_variants.clpso.CLPSO>`"
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/clpso.py:20
#: ../../../src/evox/algorithms/pso_variants/clpso.py:33
#: ../../../src/evox/algorithms/pso_variants/cso.py:20
#: ../../../src/evox/algorithms/pso_variants/cso.py:33
#, fuzzy
msgid "The basic CSO algorithm."
msgstr "算法。"

#: ../../../src/evox/algorithms/pso_variants/clpso.py:35
msgid ""
"Class "
"Methods/home/bill/Source/evox/src/evox/algorithms/pso_variants/clpso.py:35: "
"(INFO/1) Duplicate implicit target name: \"class methods\"."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/clpso.py:37
msgid ""
"`__init__`: Initializes the CLPSO algorithm with given static parameters "
"including lower and upper bounds for particle positions."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/clpso.py:38
msgid ""
"`setup`: Initializes the CLPSO algorithm and sets up initial population, "
"velocity, and buffers for tracking best local and global positions and "
"fitness values."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/clpso.py:39
msgid ""
"`step`: Performs a single optimization step using CLPSO, updating local best"
" positions and fitness values, and adjusting velocity and positions based on"
" inertia, cognitive, and social components."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/clpso.py:41
#: ../../../src/evox/algorithms/pso_variants/cso.py:41
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:42
#: ../../../src/evox/algorithms/pso_variants/pso.py:40
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:41
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:41
msgid ""
"Note that the `evaluate` method is not defined in this class, it is a proxy "
"function of `Problem.evaluate` set by workflow; therefore, it cannot be used"
" in class methods other than `step`."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/clpso.py:39
msgid "Initialize the CLPSO algorithm with the given static parameters."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/clpso.py:44
msgid "The inertia weight (w). Defaults to 0.5."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/clpso.py:45
msgid "The cognitive weight (c). Defaults to 1.5."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/clpso.py:46
msgid "The social weight (P_c). Defaults to 0.05."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/clpso.py:46
msgid "Perform a single optimization step using CLPSO."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/clpso.py:48
#: ../../../src/evox/algorithms/pso_variants/pso.py:48
msgid ""
"This function evaluates the fitness of the current population, updates the "
"local best positions and fitness values, and adjusts the velocity and "
"positions of particles based on inertia, cognitive, and social components. "
"It ensures that the updated positions and velocities are clamped within the "
"specified bounds."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/clpso.py:54
#: ../../../src/evox/algorithms/pso_variants/pso.py:54
msgid ""
"The local best positions and fitness values are updated if the current "
"fitness is better than the recorded local best. The global best position and"
" fitness are determined using helper functions."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/clpso.py:58
#: ../../../src/evox/algorithms/pso_variants/pso.py:58
msgid ""
"The velocity is updated based on the weighted sum of the previous velocity, "
"the cognitive component (personal best), and the social component (global "
"best). The population positions are then updated using the new velocities."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.cso`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.cso.md:18
msgid "{py:obj}`CSO <evox.algorithms.pso_variants.cso.CSO>`"
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/cso.py:35
msgid ""
"Class "
"Methods/home/bill/Source/evox/src/evox/algorithms/pso_variants/cso.py:35: "
"(INFO/1) Duplicate implicit target name: \"class methods\"."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/cso.py:37
msgid "`__init__`: Initializes the CSO algorithm with given parameters."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/cso.py:38
msgid ""
"`setup`: Initializes the CSO algorithm with given lower and upper bounds for"
" particle positions, and sets up initial population, velocity, and buffers "
"for tracking best local and global positions and fitness values."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/cso.py:39
msgid ""
"`step`: Performs a single optimization step using CSO, updating local best "
"positions and fitness values, and adjusting velocity and positions based on "
"inertia, cognitive, and social components."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/cso.py:39
#, fuzzy
msgid "Initialize the CSO algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:44
msgid "The inertia weight. Defaults to 0.0."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/cso.py:45
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:47
#, fuzzy
msgid "The mean of the normal distribution. Defaults to None."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/algorithms/pso_variants/cso.py:46
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:48
msgid "The standard deviation of the normal distribution. Defaults to None."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/cso.py:46
msgid "Perform a single optimization step using CSO."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/cso.py:48
msgid ""
"This function updates the position and velocity of each particle in the "
"population using the CSO algorithm. The CSO algorithm is an optimization "
"algorithm that uses a combination of both the PSO and the DE algorithms to "
"search for the optimal solution."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.dms_pso_el`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.dms_pso_el.md:18
msgid "{py:obj}`DMSPSOEL <evox.algorithms.pso_variants.dms_pso_el.DMSPSOEL>`"
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:20
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:33
#, fuzzy
msgid "The DMSPSOEL algorithm."
msgstr "算法。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:35
msgid ""
"Class "
"Methods/home/bill/Source/evox/src/evox/algorithms/pso_variants/dms_pso_el.py:35:"
" (INFO/1) Duplicate implicit target name: \"class methods\"."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:37
msgid "`__init__`: Initializes the DMSPSOEL algorithm with given parameters."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:38
msgid ""
"`setup`: Initializes the DMSPSOEL algorithm with given lower and upper "
"bounds for particle positions, and sets up initial population, velocity, and"
" buffers for tracking best local and global positions and fitness values."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:39
msgid ""
"`step`: Performs a single optimization step using DMSPSOEL, updating local "
"best positions and fitness values, and adjusting velocity and positions "
"based on inertia, cognitive, and social components."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:39
msgid "Initialize the DMSPSOEL algorithm with the given parameters."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:43
msgid "The size of the dynamic sub-swarm. Defaults to 10."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:44
msgid "The number of dynamic sub-swarms. Defaults to 5."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:45
msgid "The size of the following sub-swarm. Defaults to 10."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:46
msgid "The number of iterations for regrouping. Defaults to 50."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:47
#, fuzzy
msgid "The maximum number of iterations. Defaults to 100."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:48
msgid "The inertia weight. Defaults to 0.7."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:49
msgid "The cognitive weight. Defaults to 1.5."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:50
msgid "The social weight. Defaults to 1.5."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:51
#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:52
msgid "The social weight. Defaults to 1.0."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:46
#, fuzzy
msgid "Perform a single step of the DMSPSOEL algorithm."
msgstr "算法的新状态"

#: ../../../src/evox/algorithms/pso_variants/dms_pso_el.py:48
msgid ""
"This function updates the population, velocity, personal best location, and "
"personal best fitness based on the current fitness values. It also updates "
"the local and global best positions and fitness values based on the dynamic "
"sub-swarm and following sub-swarm. Finally, it updates the iteration count."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.fs_pso`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.fs_pso.md:18
msgid "{py:obj}`FSPSO <evox.algorithms.pso_variants.fs_pso.FSPSO>`"
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:20
#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:33
#, fuzzy
msgid "The Feature Selection PSO algorithm."
msgstr "这个算法的状态。"

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:39
msgid "Initialize the FSPSO algorithm with the given parameters."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:44
#: ../../../src/evox/algorithms/pso_variants/pso.py:42
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:44
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:44
msgid "The inertia weight. Defaults to 0.6."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:45
#: ../../../src/evox/algorithms/pso_variants/pso.py:43
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:45
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:45
msgid "The cognitive weight. Defaults to 2.5."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:46
#: ../../../src/evox/algorithms/pso_variants/pso.py:44
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:46
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:46
msgid "The social weight. Defaults to 0.8."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:49
msgid "The mutation rate. Defaults to 0.01."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/fs_pso.py:46
msgid "Perform a normal optimization step using FSPSO."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.pso`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.pso.md:18
msgid "{py:obj}`PSO <evox.algorithms.pso_variants.pso.PSO>`"
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/pso.py:20
#: ../../../src/evox/algorithms/pso_variants/pso.py:33
msgid "The basic Particle Swarm Optimization (PSO) algorithm."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/pso.py:35
msgid ""
"Class "
"Methods/home/bill/Source/evox/src/evox/algorithms/pso_variants/pso.py:35: "
"(INFO/1) Duplicate implicit target name: \"class methods\"."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/pso.py:37
msgid ""
"`__init__`: Initializes the PSO algorithm with given parameters (population "
"size, lower and upper bounds, inertia weight, cognitive weight, and social "
"weight)."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/pso.py:38
msgid ""
"`step`: Performs a single optimization step using Particle Swarm "
"Optimization (PSO), updating local best positions and fitness values, and "
"adjusting velocity and positions based on inertia, cognitive, and social "
"components."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/pso.py:39
#, fuzzy
msgid "Initialize the PSO algorithm with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/algorithms/pso_variants/pso.py:46
msgid "Perform a normal optimization step using PSO."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/pso.py:54
msgid "Perform the first step of the PSO optimization."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/pso.py:56
msgid "See `step` for more details."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.sl_pso_gs`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_gs.md:18
msgid "{py:obj}`SLPSOGS <evox.algorithms.pso_variants.sl_pso_gs.SLPSOGS>`"
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:20
#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:33
msgid ""
"The basic Particle Swarm Optimization Social Learning PSO Using Gaussian "
"Sampling for Demonstrator Choice (SLPSOGS) algorithm."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:35
msgid ""
"Class "
"Methods/home/bill/Source/evox/src/evox/algorithms/pso_variants/sl_pso_gs.py:35:"
" (INFO/1) Duplicate implicit target name: \"class methods\"."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:37
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:37
msgid ""
"`__init__`: Initializes the SLPSOGS algorithm with given parameters "
"(population size, inertia weight, cognitive weight, and social weight)."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:38
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:38
msgid ""
"`setup`: Initializes the SLPSOGS algorithm with given lower and upper bounds"
" for particle positions, and sets up initial population, velocity, and "
"buffers for tracking best local and global positions and fitness values."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:39
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:39
msgid ""
"`step`: Performs a single optimization step using Particle Swarm "
"Optimization (SLPSOGS), updating local best positions and fitness values, "
"and adjusting velocity and positions based on inertia, cognitive, and social"
" components."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:39
msgid "Initialize the SLPSOGS algorithm with the given parameters."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/sl_pso_gs.py:46
msgid "Perform a normal optimization step using SLPSOGS."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.sl_pso_us`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.sl_pso_us.md:18
msgid "{py:obj}`SLPSOUS <evox.algorithms.pso_variants.sl_pso_us.SLPSOUS>`"
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:20
#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:33
msgid ""
"The basic Particle Swarm Optimization Social Learning PSO Using Uniform "
"Sampling for Demonstrator Choice (SLPSOUS) algorithm."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:35
msgid ""
"Class "
"Methods/home/bill/Source/evox/src/evox/algorithms/pso_variants/sl_pso_us.py:35:"
" (INFO/1) Duplicate implicit target name: \"class methods\"."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:39
msgid "Initialize the SLPSOUS algorithm with the given parameters."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/sl_pso_us.py:46
msgid "Perform a normal optimization step using SLPSOUS."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:1
msgid "{py:mod}`evox.algorithms.pso_variants.utils`"
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:18
msgid "{py:obj}`min_by <evox.algorithms.pso_variants.utils.min_by>`"
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/utils.py:20
#: ../../../src/evox/algorithms/pso_variants/utils.py:34
msgid "Find the value with the minimum key."
msgstr ""

#: ../../source/apidocs/evox/evox.algorithms.pso_variants.utils.md:22
msgid ""
"{py:obj}`random_select_from_mask "
"<evox.algorithms.pso_variants.utils.random_select_from_mask>`"
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/utils.py:24
#: ../../../src/evox/algorithms/pso_variants/utils.py:41
msgid "Randomly select `s` elements from a 1D mask using uniform noise."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/utils.py:36
msgid "A tensor or list of tensors."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/utils.py:37
msgid "A tensor or list of tensors corresponding to the values."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/utils.py:39
msgid "The value with the minimum key and the corresponding key."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/utils.py:43
msgid "A tensor used as the random seed."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/utils.py:44
msgid "A tensor of shape (N,) containing {0, 1}."
msgstr ""

#: ../../../src/evox/algorithms/pso_variants/utils.py:45
#, fuzzy
msgid "The number of elements to select."
msgstr "目标数量"

#: ../../../src/evox/algorithms/pso_variants/utils.py:47
msgid "A new mask tensor with exactly s elements set to 1."
msgstr ""

#: ../../source/apidocs/evox/evox.core.md:1
msgid "{py:mod}`evox.core`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.md:30
msgid "{py:obj}`__all__ <evox.core.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.md:42
msgid ""
"['_vmap_fix', 'debug_print', 'Parameter', 'Mutable', 'ModuleBase', "
"'use_state', 'trace_impl', 'vmap_..."
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:1
msgid "{py:mod}`evox.core._vmap_fix`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:18
msgid "{py:obj}`_set_func_id <evox.core._vmap_fix._set_func_id>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:22
msgid ""
"{py:obj}`unwrap_batch_tensor <evox.core._vmap_fix.unwrap_batch_tensor>`"
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:24
#: ../../../src/evox/core/_vmap_fix.py:181
msgid ""
"Unwraps a batched tensor into its original tensor and the batch "
"dimensions/sizes."
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:26
msgid "{py:obj}`wrap_batch_tensor <evox.core._vmap_fix.wrap_batch_tensor>`"
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:28
#: ../../../src/evox/core/_vmap_fix.py:188
msgid ""
"Wraps a original tensor into its batched form with given batch dimensions."
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:30
msgid "{py:obj}`_get_batched_size <evox.core._vmap_fix._get_batched_size>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:34
msgid ""
"{py:obj}`get_vmap_batch_sizes <evox.core._vmap_fix.get_vmap_batch_sizes>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:38
msgid ""
"{py:obj}`vmap_increment_nesting "
"<evox.core._vmap_fix.vmap_increment_nesting>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:42
msgid "{py:obj}`_flat_vmap <evox.core._vmap_fix._flat_vmap>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:46
msgid "{py:obj}`batched_random <evox.core._vmap_fix.batched_random>`"
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:48
#: ../../../src/evox/core/_vmap_fix.py:234
msgid "Generate a batched tensor of random values."
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:50
msgid ""
"{py:obj}`batched_random_like <evox.core._vmap_fix.batched_random_like>`"
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:52
#: ../../../src/evox/core/_vmap_fix.py:241
msgid ""
"Generate a batched tensor of random values with the same shape as the given "
"tensor."
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:54
msgid "{py:obj}`_batch_size <evox.core._vmap_fix._batch_size>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:58
msgid "{py:obj}`_batch_rand <evox.core._vmap_fix._batch_rand>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:62
msgid "{py:obj}`_batch_randn <evox.core._vmap_fix._batch_randn>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:66
msgid "{py:obj}`_batch_randint <evox.core._vmap_fix._batch_randint>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:70
msgid "{py:obj}`_batch_randperm <evox.core._vmap_fix._batch_randperm>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:74
msgid "{py:obj}`_batch_rand_like <evox.core._vmap_fix._batch_rand_like>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:78
msgid "{py:obj}`_batch_randn_like <evox.core._vmap_fix._batch_randn_like>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:82
msgid ""
"{py:obj}`_batch_randint_like <evox.core._vmap_fix._batch_randint_like>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:86
msgid "{py:obj}`_batch_getitem <evox.core._vmap_fix._batch_getitem>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:90
msgid "{py:obj}`_batch_setitem <evox.core._vmap_fix._batch_setitem>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:94
msgid "{py:obj}`use_batch_fixing <evox.core._vmap_fix.use_batch_fixing>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:98
msgid "{py:obj}`align_vmap_tensor <evox.core._vmap_fix.align_vmap_tensor>`"
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:100
#: ../../../src/evox/core/_vmap_fix.py:436
msgid ""
"Aligns a tensor with the batching dimensions of a current batched tensor."
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:102
msgid "{py:obj}`_debug_print <evox.core._vmap_fix._debug_print>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:106
msgid "{py:obj}`debug_print <evox.core._vmap_fix.debug_print>`"
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:108
#: ../../../src/evox/core/_vmap_fix.py:450
msgid ""
"Prints a formatted string with one positional tensor used for debugging "
"inside JIT traced functions on-the-fly."
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:118
msgid "{py:obj}`_vmap_batch_sizes <evox.core._vmap_fix._vmap_batch_sizes>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:122
msgid "{py:obj}`_original_size <evox.core._vmap_fix._original_size>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:126
msgid "{py:obj}`_original_rand <evox.core._vmap_fix._original_rand>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:130
msgid "{py:obj}`_original_randn <evox.core._vmap_fix._original_randn>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:134
msgid "{py:obj}`_original_randint <evox.core._vmap_fix._original_randint>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:138
msgid "{py:obj}`_original_randperm <evox.core._vmap_fix._original_randperm>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:142
msgid ""
"{py:obj}`_original_rand_like <evox.core._vmap_fix._original_rand_like>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:146
msgid ""
"{py:obj}`_original_randn_like <evox.core._vmap_fix._original_randn_like>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:150
msgid ""
"{py:obj}`_original_randint_like "
"<evox.core._vmap_fix._original_randint_like>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:154
msgid "{py:obj}`_original_get_item <evox.core._vmap_fix._original_get_item>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:158
msgid "{py:obj}`_original_set_item <evox.core._vmap_fix._original_set_item>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:162
msgid "{py:obj}`_batch_fixing <evox.core._vmap_fix._batch_fixing>`"
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:183
msgid "The batched tensor to be unwrapped."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:185
msgid ""
"A tuple of the original tensor, the batch dimensions, and the batch sizes."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:190
msgid "The original tensor to be wrapped."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:191
#, fuzzy
msgid "The batch dimension(s)."
msgstr "批处理大小。"

#: ../../../src/evox/core/_vmap_fix.py:193
#, fuzzy
msgid "The batched tensor."
msgstr "批处理大小。"

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:203
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:419
#: ../../source/apidocs/evox/evox.core.module.md:361
#: ../../source/apidocs/evox/evox.core.module.md:372
msgid "'ContextVar(...)'"
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:236
msgid ""
"Given a random function (e.g. "
"[`torch.randn`](https://pytorch.org/docs/stable/generated/torch.randn.html),"
" [`torch.rand`](https://pytorch.org/docs/stable/generated/torch.rand.html), "
"etc.) and its size arguments, this function generates a batched tensor of "
"random values by applying the given function to the size extended with the "
"current vmap batch size."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:241
#: ../../../src/evox/core/_vmap_fix.py:248
msgid "A function that generates a tensor of random values."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:242
msgid "The size arguments to the given function."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:243
#: ../../../src/evox/core/_vmap_fix.py:250
msgid "The keyword arguments to the given function."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:245
#: ../../../src/evox/core/_vmap_fix.py:252
msgid "The batched tensor of random values."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:247
msgid ""
"Usage:/home/bill/Source/evox/src/evox/core/_vmap_fix.py:247: (INFO/1) "
"Duplicate implicit target name: \"usage:\"."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:243
msgid ""
"Given a random function (e.g. "
"[`torch.randn_like`](https://pytorch.org/docs/stable/generated/torch.randn_like.html),"
" "
"[`torch.rand_like`](https://pytorch.org/docs/stable/generated/torch.rand_like.html),"
" etc.) and a tensor, this function generates a batched tensor of random "
"values by applying the given function to the tensor extended with the "
"current vmap batch size."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:249
msgid "The tensor to generate random values like."
msgstr ""

#: ../../source/apidocs/evox/evox.core._vmap_fix.md:248
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:258
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:268
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:278
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:288
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:298
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:308
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:318
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:328
#: ../../source/apidocs/evox/evox.core._vmap_fix.md:338
#: ../../source/apidocs/evox/evox.core.module.md:522
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:95
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:87
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:57
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:52
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:63
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:74
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:85
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:96
#, fuzzy
msgid "None"
msgstr "Notes"

#: ../../../src/evox/core/_vmap_fix.py:438
msgid ""
"This function adjusts the input tensor `value` to match the batch dimensions"
" of `current_value`, which is assumed to be a batched tensor. If `value` is "
"already a batched tensor or `current_value` is not a batched tensor, it "
"returns `value` unchanged."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:443
msgid ""
"The tensor to be aligned. If not a torch.Tensor, it is returned unchanged."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:445
msgid ""
"The reference batched tensor. If None or not a batched tensor, value is "
"returned unchanged."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:449
msgid ""
"The input value aligned with the batch dimensions of current_value, if "
"applicable."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:452
msgid ""
"When vectorized-mapping, it unwraps the batched tensor to print the "
"underlying values. Otherwise, the function behaves like "
"`format.format(*args, **kwargs)`."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:454
msgid "A string format."
msgstr ""

#: ../../../src/evox/core/_vmap_fix.py:455
#, fuzzy
msgid "The positional tensor."
msgstr "状态。"

#: ../../../src/evox/core/_vmap_fix.py:456
#, fuzzy
msgid "The unchanged tensor."
msgstr "缩放因子"

#: ../../source/apidocs/evox/evox.core.components.md:1
msgid "{py:mod}`evox.core.components`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.components.md:18
msgid "{py:obj}`Algorithm <evox.core.components.Algorithm>`"
msgstr ""

#: ../../../src/evox/core/components.py:20
#: ../../../src/evox/core/components.py:45
msgid "Base class for all algorithms"
msgstr "所有算法的基类"

#: ../../source/apidocs/evox/evox.core.components.md:22
msgid "{py:obj}`Problem <evox.core.components.Problem>`"
msgstr ""

#: ../../../src/evox/core/components.py:24
#: ../../../src/evox/core/components.py:86
#, fuzzy
msgid "Base class for all problems"
msgstr "所有算法的基类"

#: ../../source/apidocs/evox/evox.core.components.md:26
msgid "{py:obj}`Workflow <evox.core.components.Workflow>`"
msgstr ""

#: ../../../src/evox/core/components.py:28
#: ../../../src/evox/core/components.py:110
#, fuzzy
msgid "The base class for workflow."
msgstr "所有EvoX模块的基础类。"

#: ../../source/apidocs/evox/evox.core.components.md:30
msgid "{py:obj}`Monitor <evox.core.components.Monitor>`"
msgstr ""

#: ../../../src/evox/core/components.py:32
#: ../../../src/evox/core/components.py:142
#, fuzzy
msgid "The monitor base class."
msgstr "问题类"

#: ../../source/apidocs/evox/evox.core.components.md:42
#: ../../source/apidocs/evox/evox.core.components.md:83
#: ../../source/apidocs/evox/evox.core.components.md:107
#: ../../source/apidocs/evox/evox.core.components.md:139
msgid "Bases: {py:obj}`evox.core.module.ModuleBase`, {py:obj}`abc.ABC`"
msgstr ""

#: ../../../src/evox/core/components.py:47
msgid ""
"Notice/home/bill/Source/evox/src/evox/core/components.py:47: (INFO/1) "
"Duplicate implicit target name: \"notice\"."
msgstr ""

#: ../../../src/evox/core/components.py:48
msgid ""
"If a subclass have defined `trace_impl` of `step`, its corresponding "
"`init_step` must be overwritten even though nothing special is to be "
"included due to Python's object-oriented limitations."
msgstr ""

#: ../../../src/evox/core/components.py:116
#: ../../../src/evox/core/components.py:148
#: ../../../src/evox/core/module.py:47 ../../../src/evox/core/module.py:51
#: ../../../src/evox/core/module.py:92 ../../../src/evox/core/module.py:232
#, fuzzy
msgid "Initialize the ModuleBase."
msgstr "初始化这个模块和所有的子模块"

#: ../../../src/evox/core/components.py:118
#: ../../../src/evox/core/components.py:150
#: ../../../src/evox/core/module.py:49 ../../../src/evox/core/module.py:53
#: ../../../src/evox/core/module.py:94 ../../../src/evox/core/module.py:234
msgid "Variable length argument list, passed to the parent class initializer."
msgstr ""

#: ../../../src/evox/core/components.py:119
#: ../../../src/evox/core/components.py:151
#: ../../../src/evox/core/module.py:50 ../../../src/evox/core/module.py:54
#: ../../../src/evox/core/module.py:95 ../../../src/evox/core/module.py:235
msgid "Arbitrary keyword arguments, passed to the parent class initializer."
msgstr ""

#: ../../../src/evox/core/components.py:121
#: ../../../src/evox/core/components.py:153
#: ../../../src/evox/core/module.py:52 ../../../src/evox/core/module.py:56
#: ../../../src/evox/core/module.py:97 ../../../src/evox/core/module.py:237
msgid ""
"Attributes:     __static_names__ (list): A list to store static member "
"names."
msgstr ""

#: ../../../src/evox/core/components.py:58
#, fuzzy
msgid "Execute the algorithm procedure for one step."
msgstr "告诉算法更多的信息"

#: ../../../src/evox/core/components.py:66
msgid ""
"Initialize the algorithm and execute the algorithm procedure for the first "
"step."
msgstr ""

#: ../../../src/evox/core/components.py:75
msgid ""
"Evaluate the fitness at given points. This function is a proxy function of "
"`Problem.evaluate` set by workflow. By default, this functions raises "
"`NotImplementedError`."
msgstr ""

#: ../../../src/evox/core/components.py:79
#: ../../../src/evox/core/components.py:101
msgid "The population."
msgstr "种群。"

#: ../../../src/evox/core/components.py:81
#: ../../../src/evox/core/components.py:103
#, fuzzy
msgid "The fitness."
msgstr "适应度值"

#: ../../../src/evox/core/components.py:99
msgid "Evaluate the fitness at given points"
msgstr "在给定点评估适应度"

#: ../../../src/evox/core/components.py:105
msgid ""
"Notice/home/bill/Source/evox/src/evox/core/components.py:105: (INFO/1) "
"Duplicate implicit target name: \"notice\"."
msgstr ""

#: ../../../src/evox/core/components.py:106
msgid ""
"If this function contains external evaluations that cannot be JIT by "
"`torch.jit`, please wrap it with `torch.jit.ignore`."
msgstr ""

#: ../../../src/evox/core/components.py:123
#: ../../../src/evox/workflows/std_workflow.py:105
msgid "Perform the first optimization step of the workflow."
msgstr ""

#: ../../../src/evox/core/components.py:131
msgid "The basic function to step a workflow."
msgstr ""

#: ../../../src/evox/core/components.py:144
msgid ""
"Monitors are used to monitor the evolutionary process. They contains a set "
"of callbacks, which will be called at specific points during the execution "
"of the workflow. Monitor itself lives outside the main workflow, so jit is "
"not required."
msgstr ""

#: ../../../src/evox/core/components.py:149
msgid ""
"To implements a monitor, implement your own callbacks and override the hooks"
" method. The hooks method should return a list of strings, which are the "
"names of the callbacks. Currently the supported callbacks are:"
msgstr ""

#: ../../../src/evox/core/components.py:153
msgid "`post_ask`, `pre_eval`, `post_eval`, and `pre_tell`."
msgstr ""

#: ../../../src/evox/core/components.py:155
msgid "Set the static variables according to `config`."
msgstr ""

#: ../../../src/evox/core/components.py:157
#, fuzzy
msgid "The configuration."
msgstr "种群。"

#: ../../../src/evox/core/components.py:159
#: ../../../src/evox/core/module.py:247
#, fuzzy
msgid "This module."
msgstr "这个模块的状态。"

#: ../../../src/evox/core/components.py:163
msgid "The hook function to be executed before the solution transformation."
msgstr ""

#: ../../../src/evox/core/components.py:165
msgid ""
"The population (candidate solutions) before the solution transformation."
msgstr ""

#: ../../../src/evox/core/components.py:171
msgid "The hook function to be executed after the solution transformation."
msgstr ""

#: ../../../src/evox/core/components.py:173
msgid ""
"The population (candidate solutions) after the solution transformation."
msgstr ""

#: ../../../src/evox/core/components.py:179
msgid "The hook function to be executed before the fitness transformation."
msgstr ""

#: ../../../src/evox/core/components.py:181
msgid "The fitnesses before the fitness transformation."
msgstr ""

#: ../../../src/evox/core/components.py:187
msgid "The hook function to be executed after the fitness transformation."
msgstr ""

#: ../../../src/evox/core/components.py:189
msgid "The fitnesses after the fitness transformation."
msgstr ""

#: ../../source/apidocs/evox/evox.core.jit_util.md:1
msgid "{py:mod}`evox.core.jit_util`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.jit_util.md:18
msgid "{py:obj}`MappedUseStateFunc <evox.core.jit_util.MappedUseStateFunc>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.jit_util.md:28
msgid "{py:obj}`vmap <evox.core.jit_util.vmap>`"
msgstr ""

#: ../../../src/evox/core/jit_util.py:30 ../../../src/evox/core/jit_util.py:97
msgid ""
"Vectorized map the given function to its mapped version, see "
"[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html) for "
"more information."
msgstr ""

#: ../../source/apidocs/evox/evox.core.jit_util.md:32
msgid "{py:obj}`_clone_inputs <evox.core.jit_util._clone_inputs>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.jit_util.md:36
msgid ""
"{py:obj}`_form_positional_inputs "
"<evox.core.jit_util._form_positional_inputs>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.jit_util.md:40
msgid "{py:obj}`jit <evox.core.jit_util.jit>`"
msgstr ""

#: ../../../src/evox/core/jit_util.py:42
#: ../../../src/evox/core/jit_util.py:118
msgid ""
"Just-In-Time (JIT) compile the given `func` via "
"[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" (`trace=True`) or "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
" (`trace=False`)."
msgstr ""

#: ../../source/apidocs/evox/evox.core.jit_util.md:52
msgid "{py:obj}`T <evox.core.jit_util.T>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.jit_util.md:64
#: ../../source/apidocs/evox/evox.core.module.md:515
msgid "Bases: {py:obj}`typing.Protocol`"
msgstr ""

#: ../../../src/evox/core/jit_util.py:71
#, fuzzy
msgid "Initialize the state of the mapped function."
msgstr "为问题初始化设置。"

#: ../../../src/evox/core/jit_util.py:73
msgid ""
"The batch size of the state. If None, the batch size of the state is "
"indicated by VMAP_DIM_CONST. Defaults to None."
msgstr ""

#: ../../../src/evox/core/jit_util.py:74
msgid ""
"Whether to torch.expand or torch.repeat the state tensors to the given batch"
" size."
msgstr ""

#: ../../../src/evox/core/jit_util.py:76
msgid ""
"The initialized state, with the same keys as the state of the original "
"function."
msgstr ""

#: ../../source/apidocs/evox/evox.core.jit_util.md:87
#: ../../source/apidocs/evox/evox.core.module.md:192
#: ../../source/apidocs/evox/evox.core.module.md:601
#: ../../source/apidocs/evox/evox.core.module.md:635
msgid "'TypeVar(...)'"
msgstr ""

#: ../../../src/evox/core/jit_util.py:99
msgid "The function to be mapped. See torch.vmap."
msgstr ""

#: ../../../src/evox/core/jit_util.py:100
msgid "The inputs' batch dimensions. See torch.vmap. Defaults to 0."
msgstr ""

#: ../../../src/evox/core/jit_util.py:101
msgid "The outputs' batch dimensions. See torch.vmap. Defaults to 0."
msgstr ""

#: ../../../src/evox/core/jit_util.py:102
msgid ""
"Whether to trace the mapped function with torch.jit.trace or simply use "
"torch.vmap. NOTICE: if trace=False`, all of the following inputs related to "
"tracing will be ignored."
msgstr ""

#: ../../../src/evox/core/jit_util.py:103
msgid ""
"The ndim of the expected inputs of the batched function; thus, it must be at"
" least 1. Giving a single integer means same ndim for all inputs. Defaults "
"to 1."
msgstr ""

#: ../../../src/evox/core/jit_util.py:104
#, fuzzy
msgid "The . Defaults to None."
msgstr "数据集名称。"

#: ../../../src/evox/core/jit_util.py:105
msgid "description. Defaults to None."
msgstr ""

#: ../../../src/evox/core/jit_util.py:106
#: ../../../src/evox/core/jit_util.py:132
msgid ""
"Strictly check the inputs or not. See torch.jit.trace. Defaults to False."
msgstr ""

#: ../../../src/evox/core/jit_util.py:107
#: ../../../src/evox/core/jit_util.py:133
msgid ""
"Check the traced function or not. See torch.jit.trace. Defaults to False."
msgstr ""

#: ../../../src/evox/core/jit_util.py:108
msgid ""
"The optional batched current state for a use_state wrapped function. If "
"None, a new batched state will be returned for each call of "
"init_state(None). Ignored when func is not wrapped by use_state. Defaults to"
" None."
msgstr ""

#: ../../../src/evox/core/jit_util.py:109
msgid ""
"When tracing, the example inputs may be broadcasted with additional "
"dimension(s) of size VMAP_DIM_CONST. Defaults to 13."
msgstr ""

#: ../../source/apidocs/evox/evox.core.jit_util.md
#: ../../source/apidocs/evox/evox.core.module.md
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md
#, fuzzy
msgid "Raises"
msgstr "SNES"

#: ../../../src/evox/core/jit_util.py:111
msgid "If the function argument types are not supported"
msgstr ""

#: ../../../src/evox/core/jit_util.py:113
msgid ""
"The “batched” (vectorized mapped) version of func. If the given func is "
"wrapped by use_state, the returned function will have a "
"init_state(batch_size: int) -> batched_state or init_state(None) -> "
"batched_state."
msgstr ""

#: ../../../src/evox/core/jit_util.py:120
#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260004
msgid ""
"This function wrapper effectively deals with nested JIT and vector map "
"(`vmap`) expressions like `jit(func1)` -> `vmap` -> `jit(func2)`, preventing"
" possible errors."
msgstr ""

#: ../../../src/evox/core/jit_util.py:123
msgid ""
"Notice/home/bill/Source/evox/src/evox/core/jit_util.py:123: (INFO/1) "
"Duplicate implicit target name: \"notice\"."
msgstr ""

#: ../../../src/evox/core/jit_util.py:128
msgid "The target function to be JIT"
msgstr ""

#: ../../../src/evox/core/jit_util.py:129
msgid ""
"Whether using torch.jit.trace or torch.jit.script to JIT. Defaults to False."
msgstr ""

#: ../../../src/evox/core/jit_util.py:130
#, fuzzy
msgid "Whether JIT lazily or immediately. Defaults to False."
msgstr "是否是多目标优化。默认为False。"

#: ../../../src/evox/core/jit_util.py:131
msgid ""
"When lazy=False, the example inputs must be provided immediately, otherwise "
"ignored. Can be only positional arguments (a tuple), only keyword arguments "
"(a dict), or a tuple of positional arguments and keyword arguments (a tuple "
"of tuple and dict). Defaults to None."
msgstr ""

#: ../../../src/evox/core/jit_util.py:134
#, fuzzy
msgid "Whether func is a generator or not. Defaults to False."
msgstr "是否是多目标优化。默认为False。"

#: ../../../src/evox/core/jit_util.py:135
msgid ""
"Whether to use torch.jit.trace directly (no_cache=True) or run the function "
"to make it cache internals when lazy=False. Defaults to False. Has no effect"
" when trace=False. This value must be set to False if the function contains "
"a instant call to torch.jit.trace which will be used inside a "
"torch.jit.script so that the JIT traced result shall be cached."
msgstr ""

#: ../../../src/evox/core/jit_util.py:136
msgid ""
"Whether to return the dummy output of func as the second output or not. "
"Defaults to False. Has no effect when trace=False or lazy=True or "
"no_cache=True."
msgstr ""

#: ../../../src/evox/core/jit_util.py:137
msgid ""
"The manual seed to be set before each running of the function. Defaults to "
"None. Has no effect when trace=False. None means no manual seed will be set."
" Notice that any value other than None changes the GLOBAL random seed."
msgstr ""

#: ../../../src/evox/core/jit_util.py:139
msgid "The JIT version of func"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:1
msgid "{py:mod}`evox.core.module`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:18
msgid "{py:obj}`ModuleBase <evox.core.module.ModuleBase>`"
msgstr ""

#: ../../../src/evox/core/module.py:20 ../../../src/evox/core/module.py:226
#, fuzzy
msgid "The base module for all algorithms and problems in the library."
msgstr "EvoX中的自定义算法和问题"

#: ../../source/apidocs/evox/evox.core.module.md:22
msgid "{py:obj}`_WrapClassBase <evox.core.module._WrapClassBase>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:26
msgid "{py:obj}`UseStateFunc <evox.core.module.UseStateFunc>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:36
msgid "{py:obj}`_if_none <evox.core.module._if_none>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:40
msgid "{py:obj}`_is_magic <evox.core.module._is_magic>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:44
msgid "{py:obj}`Parameter <evox.core.module.Parameter>`"
msgstr ""

#: ../../../src/evox/core/module.py:46 ../../../src/evox/core/module.py:202
msgid "Wraps a value as parameter with `requires_grad=False`."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:48
msgid "{py:obj}`Mutable <evox.core.module.Mutable>`"
msgstr ""

#: ../../../src/evox/core/module.py:50 ../../../src/evox/core/module.py:209
msgid "Wraps a value as a mutable tensor."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:52
msgid ""
"{py:obj}`assign_load_state_dict <evox.core.module.assign_load_state_dict>`"
msgstr ""

#: ../../../src/evox/core/module.py:54 ../../../src/evox/core/module.py:216
msgid ""
"Copy parameters and buffers from state_dict into this module and its "
"descendants."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:56
msgid "{py:obj}`use_state_context <evox.core.module.use_state_context>`"
msgstr ""

#: ../../../src/evox/core/module.py:58 ../../../src/evox/core/module.py:382
msgid "A context manager to set the value of `using_state` temporarily."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:60
msgid ""
"{py:obj}`trace_caching_state_context "
"<evox.core.module.trace_caching_state_context>`"
msgstr ""

#: ../../../src/evox/core/module.py:62 ../../../src/evox/core/module.py:389
msgid ""
"A context manager to set the value of `trace_caching_state` temporarily."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:64
msgid "{py:obj}`is_using_state <evox.core.module.is_using_state>`"
msgstr ""

#: ../../../src/evox/core/module.py:66 ../../../src/evox/core/module.py:396
msgid "Get the current state of the `using_state`."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:68
msgid ""
"{py:obj}`is_trace_caching_state <evox.core.module.is_trace_caching_state>`"
msgstr ""

#: ../../../src/evox/core/module.py:70 ../../../src/evox/core/module.py:403
msgid "Get the current state of the `trace_caching_state`."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:72
msgid ""
"{py:obj}`tracing_or_using_state <evox.core.module.tracing_or_using_state>`"
msgstr ""

#: ../../../src/evox/core/module.py:74 ../../../src/evox/core/module.py:410
msgid ""
"Check if we are currently JIT tracing (inside a `torch.jit.trace`), in a "
"`use_state_context`, or in a `trace_caching_state`."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:76
msgid "{py:obj}`_get_vars <evox.core.module._get_vars>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:80
msgid "{py:obj}`use_state <evox.core.module.use_state>`"
msgstr ""

#: ../../../src/evox/core/module.py:82 ../../../src/evox/core/module.py:574
msgid ""
"Transform the given stateful function (which in-place alters `nn.Module`s) "
"to a pure-functional version that receives an additional `state` parameter "
"(of type `Dict[str, torch.Tensor]`) and returns the altered state "
"additionally."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:84
msgid "{py:obj}`trace_impl <evox.core.module.trace_impl>`"
msgstr ""

#: ../../../src/evox/core/module.py:86 ../../../src/evox/core/module.py:611
msgid ""
"A helper function used to annotate that the wrapped method shall be treated "
"as a trace-JIT-time proxy of the given `target` method."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:88
msgid "{py:obj}`vmap_impl <evox.core.module.vmap_impl>`"
msgstr ""

#: ../../../src/evox/core/module.py:90 ../../../src/evox/core/module.py:628
msgid ""
"A helper function used to annotate that the wrapped method shall be treated "
"as a vmap-JIT-time proxy of the given `target` method."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:92
msgid "{py:obj}`jit_class <evox.core.module.jit_class>`"
msgstr ""

#: ../../../src/evox/core/module.py:94 ../../../src/evox/core/module.py:655
msgid ""
"A helper function used to JIT script (`torch.jit.script`) or trace "
"(`torch.jit.trace_module`) all member methods of class `cls`."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:104
msgid ""
"{py:obj}`_WRAPPING_MODULE_NAME <evox.core.module._WRAPPING_MODULE_NAME>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:108
msgid "{py:obj}`ParameterT <evox.core.module.ParameterT>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:112
msgid "{py:obj}`_using_state <evox.core.module._using_state>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:116
msgid "{py:obj}`_trace_caching_state <evox.core.module._trace_caching_state>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:120
msgid "{py:obj}`_SUBMODULE_PREFIX <evox.core.module._SUBMODULE_PREFIX>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:124
msgid "{py:obj}`_USE_STATE_NAME <evox.core.module._USE_STATE_NAME>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:128
msgid "{py:obj}`_STATE_ARG_NAME <evox.core.module._STATE_ARG_NAME>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:132
msgid "{py:obj}`_EMPTY_NAME <evox.core.module._EMPTY_NAME>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:136
msgid ""
"{py:obj}`_TORCHSCRIPT_MODIFIER <evox.core.module._TORCHSCRIPT_MODIFIER>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:140
msgid "{py:obj}`_TRACE_WRAP_NAME <evox.core.module._TRACE_WRAP_NAME>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:144
msgid "{py:obj}`T <evox.core.module.T>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:148
msgid "{py:obj}`_VMAP_WRAP_NAME <evox.core.module._VMAP_WRAP_NAME>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:152
msgid "{py:obj}`ClassT <evox.core.module.ClassT>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:156
msgid "{py:obj}`_BASE_NAME <evox.core.module._BASE_NAME>`"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:168
msgid "'__wrapping_module__'"
msgstr ""

#: ../../../src/evox/core/module.py:204
#, fuzzy
msgid "The parameter value."
msgstr "参数"

#: ../../../src/evox/core/module.py:205
#, fuzzy
msgid "The dtype of the parameter. Defaults to None."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/core/module.py:206
#, fuzzy
msgid "The device of the parameter. Defaults to None."
msgstr "要使用的数据集分割。默认为 \"train\"。"

#: ../../../src/evox/core/module.py:207
#, fuzzy
msgid "Whether the parameter requires gradient. Defaults to False."
msgstr "是否是多目标优化。默认为False。"

#: ../../../src/evox/core/module.py:209
#, fuzzy
msgid "The parameter."
msgstr "参数"

#: ../../../src/evox/core/module.py:211
msgid "The value to be wrapped."
msgstr ""

#: ../../../src/evox/core/module.py:212
#, fuzzy
msgid "The dtype of the tensor. Defaults to None."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/core/module.py:213
#, fuzzy
msgid "The device of the tensor. Defaults to None."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/core/module.py:215
msgid "The wrapped tensor."
msgstr ""

#: ../../../src/evox/core/module.py:218
msgid ""
"This method is used to mimic the behavior of `ModuleBase.load_state_dict` so"
" that a regular `nn.Module` can be used with `vmap`."
msgstr ""

#: ../../../src/evox/core/module.py:220
msgid ""
"Usage:/home/bill/Source/evox/src/evox/core/module.py:220: (INFO/1) Duplicate"
" implicit target name: \"usage:\"."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:223
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:32
msgid "Bases: {py:obj}`torch.nn.Module`"
msgstr ""

#: ../../../src/evox/core/module.py:228
msgid ""
"Notice/home/bill/Source/evox/src/evox/core/module.py:228: (INFO/1) Duplicate"
" implicit target name: \"notice\"."
msgstr ""

#: ../../../src/evox/core/module.py:229
msgid "This module is an object-oriented one that can contain mutable values."
msgstr ""

#: ../../../src/evox/core/module.py:230
msgid ""
"Functional programming model is supported via `self.state_dict(...)` and "
"`self.load_state_dict(...)`."
msgstr ""

#: ../../../src/evox/core/module.py:231
msgid ""
"The module initialization for non-static members are recommended to be "
"written in the overwritten method of `setup` (or any other member method) "
"rather than `__init__`."
msgstr ""

#: ../../../src/evox/core/module.py:232
msgid ""
"Basically, predefined submodule(s) which will be ADDED to this module and "
"accessed later in member method(s) should be treated as \"non-static "
"members\", while any other member(s) should be treated as \"static "
"members\"."
msgstr ""

#: ../../../src/evox/core/module.py:234
msgid ""
"Usage/home/bill/Source/evox/src/evox/core/module.py:234: (INFO/1) Duplicate "
"implicit target name: \"usage\"."
msgstr ""

#: ../../../src/evox/core/module.py:235
msgid "Static methods to be JIT shall be defined as is, e.g.,"
msgstr ""

#: ../../../src/evox/core/module.py:241
msgid ""
"If a class member function with python dynamic control flows like `if` were "
"to be JIT, a separated static method with `jit(..., trace=False)` or "
"`torch.jit.script_if_tracing` shall be used:"
msgstr ""

#: ../../../src/evox/core/module.py:261
msgid ""
"`ModuleBase` is usually used with `jit_class` to automatically JIT all non-"
"magic member methods:"
msgstr ""

#: ../../../src/evox/core/module.py:244
msgid ""
"Setup the module. Module initialization lines should be written in the "
"overwritten method of `setup` rather than `__init__`."
msgstr ""

#: ../../../src/evox/core/module.py:249
msgid ""
"Notice/home/bill/Source/evox/src/evox/core/module.py:249: (INFO/1) Duplicate"
" implicit target name: \"notice\"."
msgstr ""

#: ../../../src/evox/core/module.py:250
msgid ""
"The static initialization can still be written in the `__init__` while the "
"mutable initialization cannot. Therefore, multiple calls of `setup` for "
"multiple initializations are possible."
msgstr ""

#: ../../../src/evox/core/module.py:252
msgid ""
"Prepares the control flow state of the module by collecting and merging the "
"state and non-local variables from the specified target functions."
msgstr ""

#: ../../../src/evox/core/module.py:254
msgid ""
"This function is used alongside with `after_control_flow()` to enable your "
"control flow operations (`utils.control_flow.*`) deal with side-effects "
"correctly. If the control flow operations have NO side-effects, you can "
"safely ignore this function and `after_control_flow()`."
msgstr ""

#: ../../../src/evox/core/module.py:256
msgid "Functions whose non-local variables are to be collected."
msgstr ""

#: ../../../src/evox/core/module.py:257
msgid "See torch.nn.Module.state_dict(..., keep_vars). Defaults to True."
msgstr ""

#: ../../../src/evox/core/module.py:259
msgid ""
"A tuple containing the merged state dictionary, a list of state keys, and a "
"list of non-local variable names."
msgstr ""

#: ../../../src/evox/core/module.py:261
msgid ""
"If not all target functions are local, global, or this class member "
"functions"
msgstr ""

#: ../../../src/evox/core/module.py:263
#: ../../../src/evox/problems/neuroevolution/brax.py:128
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:86
msgid "Warning"
msgstr ""

#: ../../../src/evox/core/module.py:264
msgid ""
"The non-local variables collected here can ONLY be used as read-only ones. "
"In-place modifications to these variables may not raise any error and "
"silently produce incorrect results."
msgstr ""

#: ../../../src/evox/core/module.py:266
msgid ""
"Usage/home/bill/Source/evox/src/evox/core/module.py:266: (INFO/1) Duplicate "
"implicit target name: \"usage\"."
msgstr ""

#: ../../../src/evox/core/module.py:260
msgid ""
"Restores the module state to the one before `prepare_control_flow` from the "
"given `state` and returns the non-local variables collected in "
"`prepare_control_flow`."
msgstr ""

#: ../../../src/evox/core/module.py:262
msgid ""
"This function is used alongside with `prepare_control_flow()` to enable your"
" control flow operations (`utils.control_flow.*`) deal with side-effects "
"correctly. If the control flow operations have NO side-effects, you can "
"safely ignore this function and `prepare_control_flow()`."
msgstr ""

#: ../../../src/evox/core/module.py:264
msgid "The state dictionary to restore the module state from."
msgstr ""

#: ../../../src/evox/core/module.py:265
msgid "The keys of the state dictionary that represent the module state."
msgstr ""

#: ../../../src/evox/core/module.py:266
msgid ""
"The keys of the state dictionary that represent the non-local variables."
msgstr ""

#: ../../../src/evox/core/module.py:268
msgid "The non-local variables dictionary collected in prepare_control_flow."
msgstr ""

#: ../../../src/evox/core/module.py:270
msgid ""
"Usage/home/bill/Source/evox/src/evox/core/module.py:270: (INFO/1) Duplicate "
"implicit target name: \"usage\"."
msgstr ""

#: ../../../src/evox/core/module.py:271
msgid "See `prepare_control_flow()`."
msgstr ""

#: ../../../src/evox/core/module.py:268
msgid ""
"Copy parameters and buffers from state_dict into this module and its "
"descendants. Overwrites "
"[`torch.nn.Module.load_state_dict`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.load_state_dict)."
msgstr ""

#: ../../../src/evox/core/module.py:271
msgid ""
"A dict containing parameters and buffers used to update this module. See "
"torch.nn.Module.load_state_dict."
msgstr ""

#: ../../../src/evox/core/module.py:272
msgid ""
"Use the original torch.nn.Module.load_state_dict to copy the state_dict to "
"current state (copy=True) or use this implementation that assigns the values"
" of this module to the ones in the state_dict (copy=False). Defaults to "
"False."
msgstr ""

#: ../../../src/evox/core/module.py:273
msgid ""
"The original arguments of torch.nn.Module.load_state_dict. Ignored if "
"copy=False."
msgstr ""

#: ../../../src/evox/core/module.py:275
msgid ""
"If copy=True, returns the return of torch.nn.Module.load_state_dict; "
"otherwise, no return."
msgstr ""

#: ../../../src/evox/core/module.py:276
#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"Define a mutable value in this module that can be accessed via `self.[name]`"
" and modified in-place."
msgstr ""

#: ../../../src/evox/core/module.py:278
#, fuzzy
msgid "The mutable value's name."
msgstr "数据集名称。"

#: ../../../src/evox/core/module.py:279
msgid "The mutable value, can be a tuple, list, dictionary of a torch.Tensor."
msgstr ""

#: ../../../src/evox/core/module.py:281
msgid "If the mutable value's type is not supported yet."
msgstr ""

#: ../../../src/evox/core/module.py:282
msgid "If the name is invalid."
msgstr ""

#: ../../../src/evox/core/module.py:328
msgid "Get the mutable value(s) stored in this list-like module."
msgstr ""

#: ../../../src/evox/core/module.py:330 ../../../src/evox/core/module.py:339
msgid "The key used to index mutable value(s)."
msgstr ""

#: ../../../src/evox/core/module.py:332
msgid "If key is out of range."
msgstr ""

#: ../../../src/evox/core/module.py:333
msgid "If key is of wrong type."
msgstr ""

#: ../../../src/evox/core/module.py:335
msgid "The indexed mutable value(s)."
msgstr ""

#: ../../../src/evox/core/module.py:336
msgid "Set the mutable value(s) stored in this list-like module."
msgstr ""

#: ../../../src/evox/core/module.py:338
msgid "The new mutable value(s)."
msgstr ""

#: ../../../src/evox/core/module.py:384
msgid ""
"When entering the context, the value of `using_state` is set to "
"`new_use_state` and a token is obtained. When exiting the context, the value"
" of `using_state` is reset to its previous value."
msgstr ""

#: ../../../src/evox/core/module.py:387
#, fuzzy
msgid "The new value of using_state. Defaults to True."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/core/module.py:389
msgid ""
"Examples:/home/bill/Source/evox/src/evox/core/module.py:389: (INFO/1) "
"Duplicate implicit target name: \"examples:\"."
msgstr ""

#: ../../../src/evox/core/module.py:391
msgid ""
"When entering the context, the value of `trace_caching_state` is set to "
"`new_trace_caching_state` and a token is obtained. When exiting the context,"
" the value of `trace_caching_state` is reset to its previous value."
msgstr ""

#: ../../../src/evox/core/module.py:394
#, fuzzy
msgid "The new value of trace_caching_state. Defaults to True."
msgstr "状态之中对应适应度的变量的变量名。默认是“fitness”。"

#: ../../../src/evox/core/module.py:396
msgid ""
"Examples:/home/bill/Source/evox/src/evox/core/module.py:396: (INFO/1) "
"Duplicate implicit target name: \"examples:\"."
msgstr ""

#: ../../../src/evox/core/module.py:398
#, fuzzy
msgid "The current state of the using_state."
msgstr "算法的新状态"

#: ../../../src/evox/core/module.py:405
msgid "The current state of the trace_caching_state."
msgstr ""

#: ../../../src/evox/core/module.py:412
msgid "True if either condition is true, False otherwise."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:417
msgid "'__submodule_'"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:495
msgid "'__use_state__'"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:505
msgid "'state'"
msgstr ""

#: ../../../src/evox/core/module.py:533
msgid ""
"Get the cloned state of the closures of the function when it is wrapped by "
"`use_state`."
msgstr ""

#: ../../../src/evox/core/module.py:535
#, fuzzy
msgid "Whether to clone the original state or not. Defaults to True."
msgstr "是否对整个步骤函数进行 `jit` 编译。默认值为 `True`"

#: ../../../src/evox/core/module.py:537
#, fuzzy
msgid "The cloned state of the closures."
msgstr "算法的新状态"

#: ../../../src/evox/core/module.py:541
msgid "Set the closures of the function to the given state."
msgstr ""

#: ../../../src/evox/core/module.py:543
msgid ""
"The new state to set to. If state=None, the new state would be the original "
"state when the function is wrapped by use_state. Defaults to None."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:557
msgid "'___empty___'"
msgstr ""

#: ../../../src/evox/core/module.py:576
msgid "The stateful function to be transformed or its generator function."
msgstr ""

#: ../../../src/evox/core/module.py:577
msgid ""
"Whether func is a function or a function generator (e.g. a lambda that "
"returns the stateful function). Defaults to True."
msgstr ""

#: ../../../src/evox/core/module.py:579
msgid ""
"The transformed pure-functional version of func. It contains a init_state() "
"-> state attribute that returns the copy of the current state that func uses"
" and can be used as example inputs of the additional state parameter. It "
"also contains a set_state(state) attribute to set the global state to the "
"given one (of course not JIT-compatible)."
msgstr ""

#: ../../../src/evox/core/module.py:581
msgid ""
"Notice/home/bill/Source/evox/src/evox/core/module.py:581: (INFO/1) Duplicate"
" implicit target name: \"notice\"."
msgstr ""

#: ../../../src/evox/core/module.py:582
msgid ""
"Since PyTorch cannot JIT or vectorized-map a function with empty dictionary,"
" list, or tuple as its input, this function transforms the given function to"
" a function WITHOUT the additional `state` parameter (of type `Dict[str, "
"torch.Tensor]`) and does NOT return the altered state additionally."
msgstr ""

#: ../../../src/evox/core/module.py:584
msgid ""
"Usage:/home/bill/Source/evox/src/evox/core/module.py:584: (INFO/1) Duplicate"
" implicit target name: \"usage:\"."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:581
msgid "'_torchscript_modifier'"
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:591
msgid "'__trace_wrapped__'"
msgstr ""

#: ../../../src/evox/core/module.py:613 ../../../src/evox/core/module.py:630
msgid "Can ONLY be used inside a `jit_class` for a member method."
msgstr ""

#: ../../../src/evox/core/module.py:615 ../../../src/evox/core/module.py:632
msgid "The target method invoked when not tracing JIT."
msgstr ""

#: ../../../src/evox/core/module.py:617 ../../../src/evox/core/module.py:634
msgid "The wrapping function to annotate the member method."
msgstr ""

#: ../../../src/evox/core/module.py:619
msgid ""
"Notice/home/bill/Source/evox/src/evox/core/module.py:619: (INFO/1) Duplicate"
" implicit target name: \"notice\"."
msgstr ""

#: ../../../src/evox/core/module.py:620 ../../../src/evox/core/module.py:637
msgid ""
"The target function and the annotated function MUST have same input/output "
"signatures (e.g. number of arguments and types); otherwise, the resulting "
"behavior is UNDEFINED."
msgstr ""

#: ../../../src/evox/core/module.py:621 ../../../src/evox/core/module.py:638
msgid ""
"If the annotated function are to be `vmap`, it cannot contain any in-place "
"operations to `self` since such operations are not well-defined and cannot "
"be compiled."
msgstr ""

#: ../../../src/evox/core/module.py:623
msgid ""
"Usage:/home/bill/Source/evox/src/evox/core/module.py:623: (INFO/1) Duplicate"
" implicit target name: \"usage:\"."
msgstr ""

#: ../../../src/evox/core/module.py:624 ../../../src/evox/core/module.py:641
#, fuzzy
msgid "See `use_state`."
msgstr "状态。"

#: ../../source/apidocs/evox/evox.core.module.md:618
msgid "'__vmap_wrapped__'"
msgstr ""

#: ../../../src/evox/core/module.py:636
msgid ""
"Notice/home/bill/Source/evox/src/evox/core/module.py:636: (INFO/1) Duplicate"
" implicit target name: \"notice\"."
msgstr ""

#: ../../../src/evox/core/module.py:640
msgid ""
"Usage:/home/bill/Source/evox/src/evox/core/module.py:640: (INFO/1) Duplicate"
" implicit target name: \"usage:\"."
msgstr ""

#: ../../source/apidocs/evox/evox.core.module.md:645
msgid "'base'"
msgstr ""

#: ../../../src/evox/core/module.py:657
msgid "The original class whose member methods are to be lazy JIT."
msgstr ""

#: ../../../src/evox/core/module.py:658
#, fuzzy
msgid "Whether to trace the module or to script the module. Default to False."
msgstr "是否在工作流开始时清除监视器历史记录。默认值为 `True`。"

#: ../../../src/evox/core/module.py:660
msgid "Returns:     The wrapped class."
msgstr ""

#: ../../../src/evox/core/module.py:663
msgid ""
"Notice/home/bill/Source/evox/src/evox/core/module.py:663: (INFO/1) Duplicate"
" implicit target name: \"notice\"."
msgstr ""

#: ../../../src/evox/core/module.py:664
msgid ""
"In many cases, it is not necessary to wrap your custom algorithms or "
"problems with `jit_class`, the workflow(s) will do the trick for you."
msgstr ""

#: ../../../src/evox/core/module.py:665
msgid ""
"With `trace=True`, all the member functions are effectively modified to "
"return `self` additionally since side-effects cannot be traced. If you want "
"to preserve the side effects, please set `trace=False` and use the "
"`use_state` function to wrap the member method to generate pure-functional"
msgstr ""

#: ../../../src/evox/core/module.py:666
#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220012
msgid ""
"Similarly, all module-wide operations like `self.to(...)` can only returns "
"the unwrapped module, which may not be desired. Since most of them are in-"
"place operations, a simple `module.to(...)` can be used instead of `module ="
" module.to(...)`."
msgstr ""

#: ../../../src/evox/core/module.py:668
msgid ""
"Usage:/home/bill/Source/evox/src/evox/core/module.py:668: (INFO/1) Duplicate"
" implicit target name: \"usage:\"."
msgstr ""

#: ../../source/apidocs/evox/evox.metrics.md:1
msgid "{py:mod}`evox.metrics`"
msgstr ""

#: ../../source/apidocs/evox/evox.metrics.md:29
msgid "{py:obj}`__all__ <evox.metrics.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.metrics.md:41
msgid "['gd', 'hv', 'igd']"
msgstr ""

#: ../../source/apidocs/evox/evox.metrics.gd.md:1
msgid "{py:mod}`evox.metrics.gd`"
msgstr ""

#: ../../source/apidocs/evox/evox.metrics.gd.md:18
msgid "{py:obj}`gd <evox.metrics.gd.gd>`"
msgstr ""

#: ../../../src/evox/metrics/gd.py:20 ../../../src/evox/metrics/gd.py:30
msgid ""
"Calculate the Generational Distance (GD) metric between a set of solutions "
"and the Pareto front."
msgstr ""

#: ../../../src/evox/metrics/gd.py:32 ../../../src/evox/metrics/igd.py:32
msgid ""
"A tensor of shape (n, m), where n is the number of solutions and m is the "
"number of objectives. Represents the set of solutions to be evaluated."
msgstr ""

#: ../../../src/evox/metrics/gd.py:34 ../../../src/evox/metrics/igd.py:34
msgid ""
"A tensor of shape (k, m), where k is the number of points on the Pareto "
"front and m is the number of objectives. Represents the true Pareto front."
msgstr ""

#: ../../../src/evox/metrics/gd.py:37
msgid ""
"The GD score, a scalar representing the average distance of the solutions to"
" the Pareto front."
msgstr ""

#: ../../../src/evox/metrics/gd.py:40
msgid ""
"The GD score is lower when the approximation is closer to the Pareto front."
msgstr ""

#: ../../source/apidocs/evox/evox.metrics.hv.md:1
msgid "{py:mod}`evox.metrics.hv`"
msgstr ""

#: ../../source/apidocs/evox/evox.metrics.hv.md:18
msgid "{py:obj}`hv <evox.metrics.hv.hv>`"
msgstr ""

#: ../../../src/evox/metrics/hv.py:20 ../../../src/evox/metrics/hv.py:30
msgid "Monte Carlo Hypervolume Calculation using bounding cube method."
msgstr ""

#: ../../../src/evox/metrics/hv.py:32
msgid "Objective points of shape (n_points, n_objs)."
msgstr ""

#: ../../../src/evox/metrics/hv.py:33
msgid "Reference point of shape (n_objs, )."
msgstr ""

#: ../../../src/evox/metrics/hv.py:34
msgid "Number of Monte Carlo samples."
msgstr ""

#: ../../../src/evox/metrics/hv.py:35
#, fuzzy
msgid "Estimated hypervolume."
msgstr "超体积"

#: ../../source/apidocs/evox/evox.metrics.igd.md:1
msgid "{py:mod}`evox.metrics.igd`"
msgstr ""

#: ../../source/apidocs/evox/evox.metrics.igd.md:18
msgid "{py:obj}`igd <evox.metrics.igd.igd>`"
msgstr ""

#: ../../../src/evox/metrics/igd.py:20 ../../../src/evox/metrics/igd.py:30
msgid ""
"Calculate the Inverted Generational Distance (IGD) metric between a set of "
"solutions and the Pareto front."
msgstr ""

#: ../../../src/evox/metrics/igd.py:36
msgid ""
"The power parameter used in the calculation (default is 1). This defines the"
" distance metric (L^p norm)."
msgstr ""

#: ../../../src/evox/metrics/igd.py:38
msgid ""
"The IGD score, a scalar representing the average distance of the solutions "
"to the Pareto front."
msgstr ""

#: ../../../src/evox/metrics/igd.py:41
msgid ""
"The IGD score is lower when the approximation is closer to the Pareto front."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.md:1
msgid "{py:mod}`evox.operators`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.md:30
msgid "{py:obj}`__all__ <evox.operators.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.md:42
msgid ""
"['NonDominatedSort', 'crowding_distance', 'non_dominate_rank', "
"'non_dominated_sort_script']"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.crossover.md:1
msgid "{py:mod}`evox.operators.crossover`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.crossover.md:29
msgid "{py:obj}`__all__ <evox.operators.crossover.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.crossover.md:41
msgid ""
"['DE_differential_sum', 'DE_exponential_crossover', 'DE_binary_crossover', "
"'DE_arithmetic_recombinat..."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:1
msgid "{py:mod}`evox.operators.crossover.differential_evolution`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:18
msgid ""
"{py:obj}`DE_differential_sum "
"<evox.operators.crossover.differential_evolution.DE_differential_sum>`"
msgstr ""

#: ../../../src/evox/operators/crossover/differential_evolution.py:20
#: ../../../src/evox/operators/crossover/differential_evolution.py:42
msgid "Computes the difference vectors' sum in differential evolution."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:22
msgid ""
"{py:obj}`DE_binary_crossover "
"<evox.operators.crossover.differential_evolution.DE_binary_crossover>`"
msgstr ""

#: ../../../src/evox/operators/crossover/differential_evolution.py:24
#: ../../../src/evox/operators/crossover/differential_evolution.py:49
msgid "Performs binary crossover in differential evolution."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:26
msgid ""
"{py:obj}`DE_exponential_crossover "
"<evox.operators.crossover.differential_evolution.DE_exponential_crossover>`"
msgstr ""

#: ../../../src/evox/operators/crossover/differential_evolution.py:28
#: ../../../src/evox/operators/crossover/differential_evolution.py:56
msgid "Performs exponential crossover in differential evolution."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:30
msgid ""
"{py:obj}`DE_arithmetic_recombination "
"<evox.operators.crossover.differential_evolution.DE_arithmetic_recombination>`"
msgstr ""

#: ../../../src/evox/operators/crossover/differential_evolution.py:32
#: ../../../src/evox/operators/crossover/differential_evolution.py:63
msgid "Performs arithmetic recombination in differential evolution."
msgstr ""

#: ../../../src/evox/operators/crossover/differential_evolution.py:44
msgid "The number of padding difference vectors."
msgstr ""

#: ../../../src/evox/operators/crossover/differential_evolution.py:45
msgid "The number of difference vectors used in mutation."
msgstr ""

#: ../../../src/evox/operators/crossover/differential_evolution.py:46
msgid "The index of current individual."
msgstr ""

#: ../../../src/evox/operators/crossover/differential_evolution.py:47
#, fuzzy
msgid "The population tensor."
msgstr "状态。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:49
msgid "The difference sum and the index of first difference vector."
msgstr ""

#: ../../../src/evox/operators/crossover/differential_evolution.py:51
#: ../../../src/evox/operators/crossover/differential_evolution.py:58
#: ../../../src/evox/operators/crossover/differential_evolution.py:65
#, fuzzy
msgid "The mutated vector for each individual in the population."
msgstr "评估给定候选解的适应度。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:52
#: ../../../src/evox/operators/crossover/differential_evolution.py:59
#: ../../../src/evox/operators/crossover/differential_evolution.py:66
msgid "The current vector for each individual in the population."
msgstr ""

#: ../../../src/evox/operators/crossover/differential_evolution.py:53
#: ../../../src/evox/operators/crossover/differential_evolution.py:60
#, fuzzy
msgid "The crossover probability for each individual."
msgstr "用于评估每个个体的幕数量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:55
#: ../../../src/evox/operators/crossover/differential_evolution.py:62
msgid "The trial vector after crossover for each individual."
msgstr ""

#: ../../../src/evox/operators/crossover/differential_evolution.py:67
msgid "The coefficient for each individual."
msgstr ""

#: ../../../src/evox/operators/crossover/differential_evolution.py:69
msgid "The trial vector after recombination for each individual."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:1
msgid "{py:mod}`evox.operators.crossover.sbx`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:18
msgid ""
"{py:obj}`simulated_binary <evox.operators.crossover.sbx.simulated_binary>`"
msgstr ""

#: ../../../src/evox/operators/crossover/sbx.py:20
#: ../../../src/evox/operators/crossover/sbx.py:30
msgid "Simulated binary crossover (SBX)"
msgstr ""

#: ../../../src/evox/operators/crossover/sbx.py:32
#: ../../../src/evox/operators/crossover/sbx_half.py:32
msgid "Parent solutions in a 2D tensor (size: n x d)."
msgstr ""

#: ../../../src/evox/operators/crossover/sbx.py:33
#: ../../../src/evox/operators/crossover/sbx_half.py:33
#, fuzzy
msgid "Probability of doing crossover."
msgstr "交叉概率"

#: ../../../src/evox/operators/crossover/sbx.py:34
#: ../../../src/evox/operators/crossover/sbx_half.py:34
msgid "Distribution index of SBX."
msgstr ""

#: ../../../src/evox/operators/crossover/sbx.py:36
#: ../../../src/evox/operators/crossover/sbx_half.py:36
msgid "Offspring solutions after crossover."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:1
msgid "{py:mod}`evox.operators.crossover.sbx_half`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:18
msgid ""
"{py:obj}`simulated_binary_half "
"<evox.operators.crossover.sbx_half.simulated_binary_half>`"
msgstr ""

#: ../../../src/evox/operators/crossover/sbx_half.py:20
#: ../../../src/evox/operators/crossover/sbx_half.py:30
msgid ""
"Generate half of the offspring solutions after simulated binary crossover "
"(SBX)."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.mutation.md:1
msgid "{py:mod}`evox.operators.mutation`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.mutation.md:27
msgid "{py:obj}`__all__ <evox.operators.mutation.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.mutation.md:39
msgid "['polynomial_mutation']"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:1
msgid "{py:mod}`evox.operators.mutation.pm_mutation`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:18
msgid ""
"{py:obj}`polynomial_mutation "
"<evox.operators.mutation.pm_mutation.polynomial_mutation>`"
msgstr ""

#: ../../../src/evox/operators/mutation/pm_mutation.py:20
#: ../../../src/evox/operators/mutation/pm_mutation.py:30
msgid "Polynomial mutation. Inspired by PlatEMO."
msgstr ""

#: ../../../src/evox/operators/mutation/pm_mutation.py:33
#, fuzzy
msgid "The input population (size: n x d)."
msgstr "种群。"

#: ../../../src/evox/operators/mutation/pm_mutation.py:36
#, fuzzy
msgid "Probability of mutation."
msgstr "交叉概率"

#: ../../../src/evox/operators/mutation/pm_mutation.py:37
msgid "The distribution index for polynomial mutation."
msgstr ""

#: ../../../src/evox/operators/mutation/pm_mutation.py:39
msgid "The mutated population. (size: n x d)"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.sampling.md:1
msgid "{py:mod}`evox.operators.sampling`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.sampling.md:29
msgid "{py:obj}`__all__ <evox.operators.sampling.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.sampling.md:41
msgid ""
"['grid_sampling', 'latin_hypercube_sampling', "
"'latin_hypercube_sampling_standard', 'uniform_sampling..."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:1
msgid "{py:mod}`evox.operators.sampling.gird`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:18
msgid "{py:obj}`grid_sampling <evox.operators.sampling.gird.grid_sampling>`"
msgstr ""

#: ../../../src/evox/operators/sampling/gird.py:20
#: ../../../src/evox/operators/sampling/gird.py:30
msgid "Grid sampling. Inspired by PlatEMO."
msgstr ""

#: ../../../src/evox/operators/sampling/gird.py:33
msgid "Number of grid points along each axis."
msgstr ""

#: ../../../src/evox/operators/sampling/gird.py:34
msgid "Dimensionality of the grid (number of axes)."
msgstr ""

#: ../../../src/evox/operators/sampling/gird.py:36
msgid "Grid points, and the number of samples."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:1
msgid "{py:mod}`evox.operators.sampling.latin_hypercube`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:18
msgid ""
"{py:obj}`latin_hypercube_sampling_standard "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling_standard>`"
msgstr ""

#: ../../../src/evox/operators/sampling/latin_hypercube.py:20
#: ../../../src/evox/operators/sampling/latin_hypercube.py:34
msgid "Generate Latin Hypercube samples in the unit hypercube."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:22
msgid ""
"{py:obj}`latin_hypercube_sampling "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling>`"
msgstr ""

#: ../../../src/evox/operators/sampling/latin_hypercube.py:24
#: ../../../src/evox/operators/sampling/latin_hypercube.py:41
msgid ""
"Generate Latin Hypercube samples in the given hypercube defined by `lb` and "
"`ub`."
msgstr ""

#: ../../../src/evox/operators/sampling/latin_hypercube.py:36
#: ../../../src/evox/operators/sampling/latin_hypercube.py:43
#, fuzzy
msgid "The number of sample points to generate."
msgstr "需要初始化的拷贝的数量"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:37
#: ../../../src/evox/operators/sampling/latin_hypercube.py:44
#, fuzzy
msgid "The dimensionality of the samples."
msgstr "这个问题的完整的维度。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:38
msgid "The device on which to generate the samples."
msgstr ""

#: ../../../src/evox/operators/sampling/latin_hypercube.py:39
#: ../../../src/evox/operators/sampling/latin_hypercube.py:47
#, fuzzy
msgid "Whether to scramble the order of the samples. Defaults to True."
msgstr "是否在工作流开始时清除监视器历史记录。默认值为 `True`。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:41
msgid ""
"A tensor of shape (n, d), where each row represents a sample point and each "
"column represents a dimension."
msgstr ""

#: ../../../src/evox/operators/sampling/latin_hypercube.py:45
msgid ""
"The lower bounds of the hypercube. Must be a 1D tensor with same shape, "
"dtype, and device as ub."
msgstr ""

#: ../../../src/evox/operators/sampling/latin_hypercube.py:46
msgid ""
"The upper bounds of the hypercube. Must be a 1D tensor with same shape, "
"dtype, and device as lb."
msgstr ""

#: ../../../src/evox/operators/sampling/latin_hypercube.py:49
msgid ""
"A tensor of shape (n, d), where each row represents a sample point and each "
"column represents a dimension whose device is the same as lb and ub."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:1
msgid "{py:mod}`evox.operators.sampling.uniform`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:18
msgid ""
"{py:obj}`uniform_sampling "
"<evox.operators.sampling.uniform.uniform_sampling>`"
msgstr ""

#: ../../../src/evox/operators/sampling/uniform.py:20
#: ../../../src/evox/operators/sampling/uniform.py:30
msgid ""
"Uniform sampling using Das and Dennis's method, Deb and Jain's method. "
"Inspired by PlatEMO's NBI algorithm."
msgstr ""

#: ../../../src/evox/operators/sampling/uniform.py:33
#, fuzzy
msgid "Number of points to generate."
msgstr "需要初始化的拷贝的数量"

#: ../../../src/evox/operators/sampling/uniform.py:34
#, fuzzy
msgid "Dimensionality of the grid."
msgstr "这个问题的完整的维度。"

#: ../../../src/evox/operators/sampling/uniform.py:36
msgid "The generated points, and the number of samples."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.md:1
msgid "{py:mod}`evox.operators.selection`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.md:30
msgid "{py:obj}`__all__ <evox.operators.selection.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.md:42
msgid ""
"['NonDominatedSort', 'crowding_distance', 'nd_environmental_selection', "
"'non_dominate_rank', 'non_do..."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:1
msgid "{py:mod}`evox.operators.selection.find_pbest`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:18
msgid ""
"{py:obj}`select_rand_pbest "
"<evox.operators.selection.find_pbest.select_rand_pbest>`"
msgstr ""

#: ../../../src/evox/operators/selection/find_pbest.py:20
#: ../../../src/evox/operators/selection/find_pbest.py:30
#, fuzzy
msgid ""
"Selects a random personal-best vector from the population for each "
"individual."
msgstr "给出用于评估的候选种群。"

#: ../../../src/evox/operators/selection/find_pbest.py:32
msgid ""
"The proportion of the population to consider as best. Must be between 0 and "
"1."
msgstr ""

#: ../../../src/evox/operators/selection/find_pbest.py:33
msgid "The population tensor of shape (pop_size, dim)."
msgstr ""

#: ../../../src/evox/operators/selection/find_pbest.py:34
msgid "The fitness tensor of shape (pop_size,)."
msgstr ""

#: ../../../src/evox/operators/selection/find_pbest.py:36
msgid ""
"A tensor containing the selected personal-best vector for each individual."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:1
msgid "{py:mod}`evox.operators.selection.non_dominate`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:18
msgid ""
"{py:obj}`NonDominatedSort "
"<evox.operators.selection.non_dominate.NonDominatedSort>`"
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:20
#: ../../../src/evox/operators/selection/non_dominate.py:108
msgid ""
"A module for performing non-dominated sorting, implementing caching and "
"support for PyTorch's full map-reduce method."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:30
msgid ""
"{py:obj}`dominate_relation "
"<evox.operators.selection.non_dominate.dominate_relation>`"
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:32
#: ../../../src/evox/operators/selection/non_dominate.py:74
msgid ""
"Return the domination relation matrix A, where A_{ij} is True if x_i "
"dominates y_j."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:34
msgid ""
"{py:obj}`update_dc_and_rank "
"<evox.operators.selection.non_dominate.update_dc_and_rank>`"
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:36
#: ../../../src/evox/operators/selection/non_dominate.py:81
msgid "Update the dominate count and ranks for the current Pareto front."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:38
msgid ""
"{py:obj}`non_dominated_sort_script "
"<evox.operators.selection.non_dominate.non_dominated_sort_script>`"
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:40
#: ../../../src/evox/operators/selection/non_dominate.py:88
msgid "Perform non-dominated sort using PyTorch in torch.script mode."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:42
msgid ""
"{py:obj}`crowding_distance "
"<evox.operators.selection.non_dominate.crowding_distance>`"
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:44
#: ../../../src/evox/operators/selection/non_dominate.py:145
msgid ""
"Compute the crowding distance for a set of solutions in multi-objective "
"optimization."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:46
msgid ""
"{py:obj}`non_dominate_rank "
"<evox.operators.selection.non_dominate.non_dominate_rank>`"
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:48
#: ../../../src/evox/operators/selection/non_dominate.py:152
msgid ""
"Compute the non-domination rank for a set of solutions in multi-objective "
"optimization."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:50
msgid ""
"{py:obj}`nd_environmental_selection "
"<evox.operators.selection.non_dominate.nd_environmental_selection>`"
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:52
#: ../../../src/evox/operators/selection/non_dominate.py:159
msgid ""
"Perform environmental selection based on non-domination rank and crowding "
"distance."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:62
msgid ""
"{py:obj}`_NDS_cache <evox.operators.selection.non_dominate._NDS_cache>`"
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:76
msgid ""
"An array with shape (n1, m) where n1 is the population size and m is the "
"number of objectives."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:77
msgid ""
"An array with shape (n2, m) where n2 is the population size and m is the "
"number of objectives."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:79
msgid "The domination relation matrix of x and y."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:83
msgid "The domination relation matrix between individuals."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:84
msgid "The count of how many individuals dominate each individual."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:85
msgid "A tensor indicating which individuals are in the current Pareto front."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:86
msgid "A tensor storing the rank of each individual."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:87
msgid "The current Pareto front rank."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:89
msgid ""
"rank: Updated rank tensor.  dominate_count: Updated dominate count tensor."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:90
msgid "**rank**: Updated rank tensor."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:91
msgid "**dominate_count**: Updated dominate count tensor."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:90
#: ../../../src/evox/operators/selection/non_dominate.py:131
#: ../../../src/evox/operators/selection/non_dominate.py:139
msgid ""
"An array with shape (n, m) where n is the population size and m is the "
"number of objectives."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:92
#: ../../../src/evox/operators/selection/non_dominate.py:133
#: ../../../src/evox/operators/selection/non_dominate.py:141
msgid "A one-dimensional tensor representing the ranking, starting from 0."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:105
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:30
msgid "Bases: {py:obj}`evox.core.ModuleBase`"
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:110
msgid ""
"This class provides an efficient implementation of non-dominated sorting "
"using both direct computation and a traceable map-reduce method for large-"
"scale multi-objective optimization problems."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:114
msgid ""
"This class is designed to automatically identify script and trace modes, "
"with a particular focus on supporting `vmap`. In script mode, use "
"`non_dominated_sort_script`, and in trace mode, use "
"`trace_non_dominated_sort`."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:114
msgid ""
"Initialize the NonDominatedSort module, setting up caching for efficient "
"reuse."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:129
msgid ""
"Perform non-dominated sorting using PyTorch's scripting mechanism for "
"efficient computation."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:137
msgid ""
"Perform non-dominated sorting using PyTorch's tracing mechanism for "
"efficient computation."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:147
msgid ""
"The crowding distance is a measure of the diversity of solutions within a "
"Pareto front."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:149
#: ../../../src/evox/operators/selection/non_dominate.py:156
#: ../../../src/evox/operators/selection/non_dominate.py:162
msgid ""
"A 2D tensor where each row represents a solution, and each column represents"
" an objective."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:150
msgid "A 1D boolean tensor indicating which solutions should be considered."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:152
msgid "A 1D tensor containing the crowding distance for each solution."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:154
msgid ""
"The non-domination rank is a measure of the Pareto optimality of each "
"solution."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:158
msgid "A 1D tensor containing the non-domination rank for each solution."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:161
msgid ""
"A 2D tensor where each row represents a solution, and each column represents"
" a decision variable."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:163
#, fuzzy
msgid "The number of solutions to select."
msgstr "子种群的个数。"

#: ../../../src/evox/operators/selection/non_dominate.py:165
msgid ""
"A tuple of four tensors:x: The selected solutions.  f: The corresponding "
"objective values.  rank: The non-domination rank of the selected solutions."
"  crowding_dis: The crowding distance of the selected solutions."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:166
msgid "A tuple of four tensors:"
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:167
#, fuzzy
msgid "**x**: The selected solutions."
msgstr "获取当前的最优解。"

#: ../../../src/evox/operators/selection/non_dominate.py:168
msgid "**f**: The corresponding objective values."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:169
msgid "**rank**: The non-domination rank of the selected solutions."
msgstr ""

#: ../../../src/evox/operators/selection/non_dominate.py:170
msgid "**crowding_dis**: The crowding distance of the selected solutions."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:1
msgid "{py:mod}`evox.operators.selection.rvea_selection`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:18
msgid "{py:obj}`apd_fn <evox.operators.selection.rvea_selection.apd_fn>`"
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:20
#: ../../../src/evox/operators/selection/rvea_selection.py:34
msgid "Compute the APD (Angle-Penalized Distance) based on the given inputs."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:22
msgid ""
"{py:obj}`ref_vec_guided "
"<evox.operators.selection.rvea_selection.ref_vec_guided>`"
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:24
#: ../../../src/evox/operators/selection/rvea_selection.py:41
msgid ""
"Perform the Reference Vector Guided Evolutionary Algorithm (RVEA) selection "
"process."
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:36
msgid "A tensor representing the indices of the partition."
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:37
msgid "A tensor representing the gamma."
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:38
#, fuzzy
msgid "A tensor representing the angle."
msgstr "一个表示状态的类"

#: ../../../src/evox/operators/selection/rvea_selection.py:39
msgid "A tensor of shape (n, m) representing the objectives of the solutions."
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:40
msgid ""
"A tensor representing the parameter theta used for scaling the reference "
"vector."
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:42
msgid "A tensor containing the APD values for each solution."
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:43
msgid ""
"This function selects solutions based on the Reference Vector Guided "
"Evolutionary Algorithm. It calculates the distances and angles between "
"solutions and reference vectors, and returns the next set of solutions to be"
" evolved."
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:47
msgid ""
"A tensor of shape (n, d) representing the current population solutions."
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:48
#: ../../../src/evox/problems/numerical/dtlz.py:68
msgid ""
"A tensor of shape (n, m) representing the objective values for each "
"solution."
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:49
msgid "A tensor of shape (r, m) representing the reference vectors."
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:50
msgid "A tensor representing the parameter theta used in the APD calculation."
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:52
msgid ""
"A tuple containing:next_x: The next selected solutions.  next_f: The "
"objective values of the next selected solutions."
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:52
msgid "A tuple containing:"
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:53
#, fuzzy
msgid "next_x: The next selected solutions."
msgstr "获取当前的最优解。"

#: ../../../src/evox/operators/selection/rvea_selection.py:54
msgid "next_f: The objective values of the next selected solutions."
msgstr ""

#: ../../../src/evox/operators/selection/rvea_selection.py:57
msgid ""
"The function computes the distances between the solutions and reference "
"vectors, and selects the solutions with the minimum APD. It currently uses a"
" suboptimal selection implementation, and future improvements will optimize "
"the process using a `segment_sort` or `segment_argmin` in CUDA."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:1
msgid "{py:mod}`evox.operators.selection.tournament_selection`"
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:18
msgid ""
"{py:obj}`tournament_selection_multifit "
"<evox.operators.selection.tournament_selection.tournament_selection_multifit>`"
msgstr ""

#: ../../../src/evox/operators/selection/tournament_selection.py:20
#: ../../../src/evox/operators/selection/tournament_selection.py:34
msgid "Perform tournament selection based on multiple fitness values."
msgstr ""

#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:22
msgid ""
"{py:obj}`tournament_selection "
"<evox.operators.selection.tournament_selection.tournament_selection>`"
msgstr ""

#: ../../../src/evox/operators/selection/tournament_selection.py:24
#: ../../../src/evox/operators/selection/tournament_selection.py:41
msgid "Perform tournament selection based on single fitness values."
msgstr ""

#: ../../../src/evox/operators/selection/tournament_selection.py:36
#: ../../../src/evox/operators/selection/tournament_selection.py:43
msgid "Number of rounds of selection (how many solutions to select)."
msgstr ""

#: ../../../src/evox/operators/selection/tournament_selection.py:37
msgid ""
"A list of 1D tensors, each representing the fitness values of candidates for"
" different objectives."
msgstr ""

#: ../../../src/evox/operators/selection/tournament_selection.py:38
#: ../../../src/evox/operators/selection/tournament_selection.py:45
msgid "Number of candidates in each tournament. Defaults to 2."
msgstr ""

#: ../../../src/evox/operators/selection/tournament_selection.py:39
#: ../../../src/evox/operators/selection/tournament_selection.py:46
msgid "Indices of the selected solutions after tournament selection."
msgstr ""

#: ../../../src/evox/operators/selection/tournament_selection.py:41
msgid ""
"This function performs tournament selection by randomly selecting a group of"
" candidates for each round, and selecting the best one from each group based"
" on their fitness values across multiple objectives."
msgstr ""

#: ../../../src/evox/operators/selection/tournament_selection.py:44
msgid "A 1D tensor representing the fitness values of candidates."
msgstr ""

#: ../../../src/evox/operators/selection/tournament_selection.py:48
msgid ""
"This function performs tournament selection by randomly selecting a group of"
" candidates for each round, and selecting the best one from each group based"
" on their fitness values."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.md:1
msgid "{py:mod}`evox.problems`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:1
msgid "{py:mod}`evox.problems.hpo_wrapper`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:18
msgid "{py:obj}`HPOMonitor <evox.problems.hpo_wrapper.HPOMonitor>`"
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:20
#: ../../../src/evox/problems/hpo_wrapper.py:41
msgid ""
"The base class for hyper parameter optimization (HPO) monitors used in "
"`HPOProblem.workflow.monitor`."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:22
msgid ""
"{py:obj}`HPOFitnessMonitor <evox.problems.hpo_wrapper.HPOFitnessMonitor>`"
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:24
#: ../../../src/evox/problems/hpo_wrapper.py:66
msgid ""
"The monitor for hyper parameter optimization (HPO) that records the best "
"fitness found so far in the optimization process."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:26
msgid ""
"{py:obj}`HPOProblemWrapper <evox.problems.hpo_wrapper.HPOProblemWrapper>`"
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:28
#: ../../../src/evox/problems/hpo_wrapper.py:98
msgid "The problem for hyper parameter optimization (HPO)."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:38
msgid "Bases: {py:obj}`evox.core.Monitor`, {py:obj}`abc.ABC`"
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:55
#: ../../../src/evox/problems/hpo_wrapper.py:87
msgid ""
"Get the best fitness found so far in the optimization process that this "
"monitor is monitoring."
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:57
#: ../../../src/evox/problems/hpo_wrapper.py:89
#, fuzzy
msgid "The best fitness so far."
msgstr "获取当前的最优适应度值。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:63
msgid "Bases: {py:obj}`evox.problems.hpo_wrapper.HPOMonitor`"
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:72
msgid "Initialize the HPO fitness monitor."
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:74
msgid ""
"The metric function to use for multi-objective optimization, unused in "
"single-objective optimization. Currently we only support \"IGD\" or \"HV\" "
"for multi-objective optimization. Defaults to None."
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:79
msgid ""
"Update the best fitness value found so far based on the provided fitness "
"tensor and multi-objective metric."
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:81
msgid ""
"A tensor representing fitness values. It can be either a 1D tensor for "
"single-objective optimization or a 2D tensor for multi-objective "
"optimization."
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:83
#, fuzzy
msgid "If the dimensionality of the fitness tensor is not 1 or 2."
msgstr "这个问题的完整的维度。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:95
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:97
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:67
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:86
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:30
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:48
msgid "Bases: {py:obj}`evox.core.Problem`"
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:100
msgid ""
"Usage/home/bill/Source/evox/src/evox/problems/hpo_wrapper.py:100: (INFO/1) "
"Duplicate implicit target name: \"usage\"."
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:104
#, fuzzy
msgid "Initialize the HPO problem wrapper."
msgstr "为问题初始化设置。"

#: ../../../src/evox/problems/hpo_wrapper.py:106
msgid "The number of iterations to be executed in the optimization process."
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:107
msgid ""
"The number of instances to be executed in parallel in the optimization "
"process."
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:108
msgid ""
"The workflow to be used in the optimization process. Must be wrapped by "
"core.jit_class."
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:109
msgid ""
"Whether to copy the initial state of the workflow for each evaluation. "
"Defaults to True. If your workflow contains operations that IN-PLACE modify "
"the tensor(s) in initial state, this should be set to True. Otherwise, you "
"can set it to False to save memory."
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:111
msgid ""
"Evaluate the fitness (given by the internal workflow's monitor) of the batch"
" of hyper parameters by running the internal workflow."
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:113
msgid "The hyper parameters to evaluate."
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:115
msgid "The final fitness of the hyper parameters."
msgstr ""

#: ../../../src/evox/problems/hpo_wrapper.py:119
msgid ""
"Return the initial hyper-parameters dictionary of the underlying workflow."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.md:1
msgid "{py:mod}`evox.problems.neuroevolution`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:1
msgid "{py:mod}`evox.problems.neuroevolution.brax`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:18
msgid "{py:obj}`BraxProblem <evox.problems.neuroevolution.brax.BraxProblem>`"
msgstr ""

#: ../../../src/evox/problems/neuroevolution/brax.py:20
#: ../../../src/evox/problems/neuroevolution/brax.py:100
#, fuzzy
msgid "The Brax problem wrapper."
msgstr "问题。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:30
msgid ""
"{py:obj}`to_jax_array <evox.problems.neuroevolution.brax.to_jax_array>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:34
msgid ""
"{py:obj}`from_jax_array <evox.problems.neuroevolution.brax.from_jax_array>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:46
msgid "{py:obj}`__all__ <evox.problems.neuroevolution.brax.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:50
msgid ""
"{py:obj}`__brax_data__ <evox.problems.neuroevolution.brax.__brax_data__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:62
#, fuzzy
msgid "['BraxProblem']"
msgstr "基于Brax的问题"

#: ../../../src/evox/problems/neuroevolution/brax.py:106
#, fuzzy
msgid ""
"Construct a Brax-based problem. Firstly, you need to define a policy model. "
"Then you need to set the `environment name "
"<https://github.com/google/brax/tree/main/brax/envs>`, the maximum episode "
"length, the number of episodes to evaluate for each individual. For each "
"individual, it will run the policy with the environment for num_episodes "
"times with different seed, and use the reduce_fn to reduce the rewards "
"(default to average). Different individuals will share the same set of "
"random keys in each iteration."
msgstr ""
"构建一个基于Brax的问题。首先，需要定义一个可编译的策略函数（policy function）。策略函数应该具有以下签名： "
"如果您的策略是无状态的：:code:`fn(weights, obs) -> action`， 如果您的策略是有状态的：:code:`fn(state,"
" weights, obs) -> action, state`。接下来，您需要设置`环境名称 "
"<https://github.com/google/brax/tree/main/brax/envs>`_，最大幕长度，以及每个个体需要评估的幕的个数。对于每个个体，策略会在环境中运行`num_episodes`次，并使用不同的随机种子。然后使用`reduce_fn`来聚合奖励（默认为平均值）。在每次迭代中，不同的个体将共享相同的随机种子集合。"

#: ../../../src/evox/problems/neuroevolution/brax.py:115
msgid ""
"The policy model whose forward function is :code:forward(batched_obs) -> "
"action."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/brax.py:116
msgid "The environment name."
msgstr "环境名。"

#: ../../../src/evox/problems/neuroevolution/brax.py:117
#, fuzzy
msgid "The maximum number of time steps of each episode."
msgstr "运行的最大的时间步的数量。"

#: ../../../src/evox/problems/neuroevolution/brax.py:118
msgid "The number of episodes to evaluate for each individual."
msgstr "用于评估每个个体的幕数量。"

#: ../../../src/evox/problems/neuroevolution/brax.py:119
msgid ""
"The size of the population to be evaluated. If None, we expect the input to "
"have a population size of 1."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/brax.py:120
#, fuzzy
msgid ""
"Indicates whether to rotate the random key for each iteration (default is "
"True). <br/> If True, the random key will rotate after each iteration, "
"resulting in non-deterministic and potentially noisy fitness evaluations. "
"This means that identical policy weights may yield different fitness values "
"across iterations. <br/> If False, the random key remains the same for all "
"iterations, ensuring consistent fitness evaluations."
msgstr ""
"是否在每次迭代后轮换随机数种子（默认值为 True）。   如果设置为 "
"True，则在每次迭代后随机数种子会轮换，从而导致非适应度评估带有噪声的。这意味着相同的权重在不同迭代中可能返回不同的适应度值。   如果设置为 "
"False，则随机数种子在所有迭代中保持不变，从而确保适应度评估的一致性。"

#: ../../../src/evox/problems/neuroevolution/brax.py:121
#, fuzzy
msgid ""
"The function to reduce the rewards of multiple episodes. Default to "
"torch.mean."
msgstr "用于聚合多个幕奖励值的函数。默认值为 `jnp.mean`。"

#: ../../../src/evox/problems/neuroevolution/brax.py:122
msgid ""
"Brax's backend. If None, the default backend of the environment will be "
"used. Default to None."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/brax.py:123
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:82
msgid ""
"The device to run the computations on. Defaults to the current default "
"device."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/brax.py:125
#: ../../../src/evox/workflows/std_workflow.py:75
#, fuzzy
msgid "Notice"
msgstr "Notes"

#: ../../../src/evox/problems/neuroevolution/brax.py:126
msgid "The initial key is obtained from `torch.random.get_rng_state()`."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/brax.py:129
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:87
msgid ""
"This problem does NOT support HPO wrapper "
"(`problems.hpo_wrapper.HPOProblemWrapper`), i.e., the workflow containing "
"this problem CANNOT be vmapped."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/brax.py:131
#: ../../source/guide/developer/1-modulebase.md:126 ../../source/index.md:22
msgid "Examples"
msgstr "示例"

#: ../../../src/evox/problems/neuroevolution/brax.py:132
msgid ""
"from evox import problems problem = problems.neuroevolution.Brax( ...    "
"env_name=\"swimmer\", ...    policy=model, ...    max_episode_length=1000, "
"...    num_episodes=3, ...    pop_size=100, ...    rotate_key=False, ...)"
msgstr ""

#: ../../../src/evox/problems/neuroevolution/brax.py:113
msgid ""
"Evaluate the final rewards of a population (batch) of model parameters."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/brax.py:115
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:125
msgid ""
"A dictionary of parameters where each key is a parameter name and each value"
" is a tensor of shape (batch_size, *param_shape) representing the batched "
"parameters of batched models."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/brax.py:117
msgid ""
"A tensor of shape (batch_size,) containing the reward of each sample in the "
"population."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/brax.py:137
#, fuzzy
msgid "Visualize the brax environment with the given policy and weights."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/problems/neuroevolution/brax.py:139
msgid "The weights of the policy model. Which is a dictionary of parameters."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/brax.py:140
msgid ""
"The output type of the visualization, \"HTML\" or \"rgb_array\". Default to "
"\"HTML\"."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/brax.py:142
#, fuzzy
msgid "The visualization output."
msgstr "种群。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:1
msgid "{py:mod}`evox.problems.neuroevolution.supervised_learning`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:18
msgid ""
"{py:obj}`SupervisedLearningProblem "
"<evox.problems.neuroevolution.supervised_learning.SupervisedLearningProblem>`"
msgstr ""

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:20
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:70
msgid ""
"The supervised learning problem to test a model's parameters or a batch of "
"parameters with given data and criterion."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:30
msgid ""
"{py:obj}`__all__ <evox.problems.neuroevolution.supervised_learning.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:34
msgid ""
"{py:obj}`__supervised_data__ "
"<evox.problems.neuroevolution.supervised_learning.__supervised_data__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:46
#, fuzzy
msgid "['SupervisedLearningProblem']"
msgstr "监督学习"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:76
#, fuzzy
msgid "Initialize the `SupervisedLearningProblem`."
msgstr "为问题初始化设置。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:78
msgid "The neural network model whose parameters need to be evaluated."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:79
msgid "The data loader providing the dataset for evaluation."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:80
msgid "The loss function used to evaluate the parameters' performance."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:81
msgid ""
"The size of the population (batch size of the parameters) to be evaluated. "
"Defaults to None for single-run mode."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:84
msgid "If the data loader contains no items."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:123
msgid "Evaluate the fitness of a population (batch) of model parameters."
msgstr ""

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:127
msgid ""
"A tensor of shape (batch_size,) containing the fitness of each sample in the"
" population."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:1
msgid "{py:mod}`evox.problems.neuroevolution.utils`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:18
msgid ""
"{py:obj}`ModelStateForwardResult "
"<evox.problems.neuroevolution.utils.ModelStateForwardResult>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:30
msgid ""
"{py:obj}`get_vmap_model_state_forward "
"<evox.problems.neuroevolution.utils.get_vmap_model_state_forward>`"
msgstr ""

#: ../../../src/evox/problems/neuroevolution/utils.py:32
#: ../../../src/evox/problems/neuroevolution/utils.py:107
msgid ""
"Get model state forward function for vmap and non-vmap models. When "
"`get_non_vmap` is False, the function returns only vmap model state forward "
"function. When `get_non_vmap` is True, the function returns both vmap and "
"non-vmap model state forward functions."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:42
msgid "Bases: {py:obj}`typing.NamedTuple`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.md:1
msgid "{py:mod}`evox.problems.numerical`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.md:29
msgid "{py:obj}`__all__ <evox.problems.numerical.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.md:41
msgid ""
"['Ackley', 'Griewank', 'Rastrigin', 'Rosenbrock', 'Schwefel', 'Sphere', "
"'CEC2022', 'DTLZ1', 'DTLZ2',..."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:1
msgid "{py:mod}`evox.problems.numerical.basic`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:18
msgid ""
"{py:obj}`ShiftAffineNumericalProblem "
"<evox.problems.numerical.basic.ShiftAffineNumericalProblem>`"
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:20
#: ../../../src/evox/problems/numerical/basic.py:89
msgid ""
"A numerical problem with a shift and affine transformations to the input "
"points."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:22
msgid "{py:obj}`Ackley <evox.problems.numerical.basic.Ackley>`"
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:24
#: ../../../src/evox/problems/numerical/basic.py:120
#, fuzzy
msgid "The Ackley function whose minimum is x = [0, ..., 0]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:26
msgid "{py:obj}`Griewank <evox.problems.numerical.basic.Griewank>`"
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:28
#: ../../../src/evox/problems/numerical/basic.py:151
#, fuzzy
msgid "The Griewank function whose minimum is x = [0, ..., 0]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:30
msgid "{py:obj}`Rastrigin <evox.problems.numerical.basic.Rastrigin>`"
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:32
#: ../../../src/evox/problems/numerical/basic.py:182
#, fuzzy
msgid "The Rastrigin function whose minimum is x = [0, ..., 0]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:34
msgid "{py:obj}`Rosenbrock <evox.problems.numerical.basic.Rosenbrock>`"
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:36
#: ../../../src/evox/problems/numerical/basic.py:213
#, fuzzy
msgid "The Rosenbrock function whose minimum is x = [1, ..., 1]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:38
msgid "{py:obj}`Schwefel <evox.problems.numerical.basic.Schwefel>`"
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:40
#: ../../../src/evox/problems/numerical/basic.py:244
#, fuzzy
msgid "The Schwefel function whose minimum is x = [420.9687, ..., 420.9687]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:42
msgid "{py:obj}`Sphere <evox.problems.numerical.basic.Sphere>`"
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:44
#: ../../../src/evox/problems/numerical/basic.py:275
#, fuzzy
msgid "The sphere function whose minimum is x = [0, ..., 0]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:54
msgid "{py:obj}`ackley_func <evox.problems.numerical.basic.ackley_func>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:58
msgid "{py:obj}`griewank_func <evox.problems.numerical.basic.griewank_func>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:62
msgid ""
"{py:obj}`rastrigin_func <evox.problems.numerical.basic.rastrigin_func>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:66
msgid ""
"{py:obj}`rosenbrock_func <evox.problems.numerical.basic.rosenbrock_func>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:70
msgid "{py:obj}`schwefel_func <evox.problems.numerical.basic.schwefel_func>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:74
msgid "{py:obj}`sphere_func <evox.problems.numerical.basic.sphere_func>`"
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:95
#, fuzzy
msgid "Initialize the ShiftAffineNumericalProblem."
msgstr "为问题初始化设置。"

#: ../../../src/evox/problems/numerical/basic.py:97
msgid "The shift vector. Defaults to None. None represents no shift."
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:98
msgid ""
"The affine transformation matrix. Defaults to None. None represents no "
"affine transformation."
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:102
msgid ""
"Evaluate the given population by shifting and applying an affine "
"transformation to the input points first, and then evaluating the points "
"with the actual function."
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:104
#, fuzzy
msgid "The population of points to evaluate."
msgstr "给出用于评估的候选种群。"

#: ../../../src/evox/problems/numerical/basic.py:106
#, fuzzy
msgid "The evaluated fitness of the population."
msgstr "评估给定候选解的适应度。"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:117
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:148
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:179
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:210
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:241
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:272
msgid ""
"Bases: {py:obj}`evox.problems.numerical.basic.ShiftAffineNumericalProblem`"
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:126
#, fuzzy
msgid "Initialize the Ackley function with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../../src/evox/problems/numerical/basic.py:128
msgid "The parameter a in the equation. Defaults to 20.0."
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:129
msgid "The parameter b in the equation. Defaults to 0.2."
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:130
msgid "The parameter c in the equation. Defaults to 2 * pi."
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:131
#: ../../../src/evox/problems/numerical/basic.py:159
#: ../../../src/evox/problems/numerical/basic.py:190
#: ../../../src/evox/problems/numerical/basic.py:221
#: ../../../src/evox/problems/numerical/basic.py:252
#: ../../../src/evox/problems/numerical/basic.py:283
msgid ""
"The keyword arguments (shift and affine) to pass to the superclass "
"ShiftAffineNumericalProblem."
msgstr ""

#: ../../../src/evox/problems/numerical/basic.py:157
#: ../../../src/evox/problems/numerical/basic.py:188
#: ../../../src/evox/problems/numerical/basic.py:219
#: ../../../src/evox/problems/numerical/basic.py:250
#: ../../../src/evox/problems/numerical/basic.py:281
#, fuzzy
msgid "Initialize the Griewank function with the given parameters."
msgstr "使用给定的策略和权重可视化 Brax 环境。"

#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:1
msgid "{py:mod}`evox.problems.numerical.cec2022`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:18
msgid "{py:obj}`CEC2022 <evox.problems.numerical.cec2022.CEC2022>`"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:20
#: ../../../src/evox/problems/numerical/cec2022.py:33
msgid "The CEC 2022 single-objective test suite Problem"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:39
msgid ""
"Initialize a single test function instance from the CEC2022 test suite."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:41
msgid ""
"Args:     problem_number (`int`): The index for the specific test function "
"to be used. Must be ranged from 1 to 12.     dimension (`int`): The "
"dimensionality of the problem. Must be one of [2, 10, 20].     device "
"(`torch.device`, optional): The device on which tensors will be allocated. "
"Defaults to None."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:46
msgid ""
"Raises:     AssertionError: If the dimension is not one of the allowed "
"values or if the function is not defined.     FileNotFoundError: If the "
"necessary data files for the problem are not found."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:46
msgid "Shift the input vector."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:54
msgid "Rotate the input vector."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:70
msgid "Shift and rotate function with rate."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:86
msgid "Zakharov Function"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:94
#, fuzzy
msgid "Rosenbrock Function"
msgstr "Rosenbrock"

#: ../../../src/evox/problems/numerical/cec2022.py:102
msgid "Schaffer F7 Function"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:110
msgid "Step Rastrigin Function (Noncontinuous Rastrigin's)"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:118
#, fuzzy
msgid "Levy Function"
msgstr "测试函数"

#: ../../../src/evox/problems/numerical/cec2022.py:126
msgid "Hybrid Function 2"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:134
msgid "Hybrid Function 10"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:142
msgid "Hybrid Function 6"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:150
msgid "Composition Function 1"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:158
msgid "Composition Function 2"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:166
msgid "Composition Function 6"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:174
msgid "Composition Function 7"
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:182
msgid "Problem number = 1."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:190
msgid "Problem number = 4."
msgstr ""

#: ../../../src/evox/problems/numerical/cec2022.py:198
msgid "Problem number = 5."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:1
msgid "{py:mod}`evox.problems.numerical.dtlz`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:18
msgid "{py:obj}`DTLZTestSuit <evox.problems.numerical.dtlz.DTLZTestSuit>`"
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:20
#: ../../../src/evox/problems/numerical/dtlz.py:51
msgid ""
"Base class for DTLZ test suite problems in multi-objective optimization."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:22
msgid "{py:obj}`DTLZ1 <evox.problems.numerical.dtlz.DTLZ1>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:24
msgid "{py:obj}`DTLZ2 <evox.problems.numerical.dtlz.DTLZ2>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:26
msgid "{py:obj}`DTLZ3 <evox.problems.numerical.dtlz.DTLZ3>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:30
msgid "{py:obj}`DTLZ4 <evox.problems.numerical.dtlz.DTLZ4>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:34
msgid "{py:obj}`DTLZ5 <evox.problems.numerical.dtlz.DTLZ5>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:36
msgid "{py:obj}`DTLZ6 <evox.problems.numerical.dtlz.DTLZ6>`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:38
msgid "{py:obj}`DTLZ7 <evox.problems.numerical.dtlz.DTLZ7>`"
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:53
msgid "Inherit this class to implement specific DTLZ problem variants."
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:55
msgid "Number of decision variables."
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:56
#, fuzzy
msgid "Number of objectives."
msgstr "目标数量"

#: ../../../src/evox/problems/numerical/dtlz.py:57
msgid "Number of reference points used in the problem."
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:57
msgid "Override the setup method to initialize the parameters"
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:65
msgid ""
"Abstract method to evaluate the objective values for given decision "
"variables."
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:67
msgid ""
"A tensor of shape (n, d), where n is the number of solutions and d is the "
"number of decision variables."
msgstr ""

#: ../../../src/evox/problems/numerical/dtlz.py:73
#, fuzzy
msgid "Return the Pareto front for the problem."
msgstr "为问题初始化设置。"

#: ../../../src/evox/problems/numerical/dtlz.py:75
msgid "A tensor representing the Pareto front."
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:81
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:93
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:158
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:175
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:192
msgid "Bases: {py:obj}`evox.problems.numerical.dtlz.DTLZTestSuit`"
msgstr ""

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:110
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:134
msgid "Bases: {py:obj}`evox.problems.numerical.dtlz.DTLZ2`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.md:1
msgid "{py:mod}`evox.utils`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.md:29
msgid "{py:obj}`__all__ <evox.utils.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.md:41
msgid ""
"['switch', 'clamp', 'clamp_int', 'clamp_float', 'clip', 'maximum', "
"'minimum', 'maximum_float', 'mini..."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.control_flow.md:1
msgid "{py:mod}`evox.utils.control_flow`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.control_flow.md:18
msgid "{py:obj}`__all__ <evox.utils.control_flow.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.control_flow.md:30
msgid "['TracingCond', 'TracingWhile', 'TracingSwitch']"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:1
msgid "{py:mod}`evox.utils.jit_fix_operator`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:18
msgid "{py:obj}`switch <evox.utils.jit_fix_operator.switch>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:20
#: ../../../src/evox/utils/jit_fix_operator.py:82
msgid ""
"Element-wise switch select operator that generates a tensor from a list of "
"tensors based on the label tensor."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:22
msgid "{py:obj}`clamp <evox.utils.jit_fix_operator.clamp>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:24
#: ../../../src/evox/utils/jit_fix_operator.py:89
msgid ""
"Clamp the values of the input tensor `a` to be within the given lower (`lb`)"
" and upper (`ub`) bounds."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:26
msgid "{py:obj}`clamp_float <evox.utils.jit_fix_operator.clamp_float>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:28
#: ../../../src/evox/utils/jit_fix_operator.py:96
msgid ""
"Clamp the float values of the input tensor `a` to be within the given lower "
"(`lb`) and upper (`ub`) bounds."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:30
msgid "{py:obj}`clamp_int <evox.utils.jit_fix_operator.clamp_int>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:32
#: ../../../src/evox/utils/jit_fix_operator.py:103
msgid ""
"Clamp the int values of the input tensor `a` to be within the given lower "
"(`lb`) and upper (`ub`) bounds."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:34
msgid "{py:obj}`clip <evox.utils.jit_fix_operator.clip>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:36
#: ../../../src/evox/utils/jit_fix_operator.py:110
msgid "Clip the values of the input tensor `a` to be within the range [0, 1]."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:38
msgid "{py:obj}`maximum <evox.utils.jit_fix_operator.maximum>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:40
#: ../../../src/evox/utils/jit_fix_operator.py:117
msgid "Element-wise maximum of two input tensors `a` and `b`."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:42
msgid "{py:obj}`minimum <evox.utils.jit_fix_operator.minimum>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:44
#: ../../../src/evox/utils/jit_fix_operator.py:124
msgid "Element-wise minimum of two input tensors `a` and `b`."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:46
msgid "{py:obj}`maximum_float <evox.utils.jit_fix_operator.maximum_float>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:48
#: ../../../src/evox/utils/jit_fix_operator.py:131
msgid "Element-wise maximum of input tensor `a` and float `b`."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:50
msgid "{py:obj}`minimum_float <evox.utils.jit_fix_operator.minimum_float>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:52
#: ../../../src/evox/utils/jit_fix_operator.py:138
msgid "Element-wise minimum of input tensor `a` and float `b`."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:54
msgid "{py:obj}`maximum_int <evox.utils.jit_fix_operator.maximum_int>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:56
#: ../../../src/evox/utils/jit_fix_operator.py:145
msgid "Element-wise maximum of input tensor `a` and int `b`."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:58
msgid "{py:obj}`minimum_int <evox.utils.jit_fix_operator.minimum_int>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:60
#: ../../../src/evox/utils/jit_fix_operator.py:152
msgid "Element-wise minimum of input tensor `a` and int `b`."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:62
msgid "{py:obj}`lexsort <evox.utils.jit_fix_operator.lexsort>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:64
#: ../../../src/evox/utils/jit_fix_operator.py:159
msgid ""
"Perform lexicographical sorting of multiple tensors, considering each tensor"
" as a key."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:66
msgid "{py:obj}`nanmin <evox.utils.jit_fix_operator.nanmin>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:68
#: ../../../src/evox/utils/jit_fix_operator.py:166
msgid ""
"Compute the minimum of a tensor along a specified dimension, ignoring NaN "
"values."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:70
msgid "{py:obj}`nanmax <evox.utils.jit_fix_operator.nanmax>`"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:72
#: ../../../src/evox/utils/jit_fix_operator.py:173
msgid ""
"Compute the maximum of a tensor along a specified dimension, ignoring NaN "
"values."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:84
msgid ""
"A tensor containing labels used to select from the list of tensors. Must be "
"broadcastable to the shape of rest arguments."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:85
msgid ""
"A list of tensors from which one is selected based on the label. All tensors"
" in the list must be broadcastable to the same shape."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:88
msgid ""
"A tensor where each element is selected from the list of tensors based on "
"the corresponding element in the label tensor."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:91
msgid ""
"This function ensures that each element of the tensor `a` is not less than "
"the corresponding element of `lb` and not greater than the corresponding "
"element of `ub`."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:94
msgid ""
"Notice/home/bill/Source/evox/src/evox/utils/jit_fix_operator.py:94: (INFO/1)"
" Duplicate implicit target name: \"notice\"."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:95
#: ../../../src/evox/utils/jit_fix_operator.py:101
#: ../../../src/evox/utils/jit_fix_operator.py:108
msgid ""
"This is a fix function for "
"[`torch.clamp`](https://pytorch.org/docs/stable/generated/torch.clamp.html) "
"since it is not supported in JIT operator fusion."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:96
msgid ""
"This is NOT a precise replication of `torch.clamp` if `a`, `lb` or `ub` is a"
" float tensor and may suffer from numerical precision losses. Please use "
"`torch.clamp` instead if a precise clamp is required."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:98
#: ../../../src/evox/utils/jit_fix_operator.py:104
#: ../../../src/evox/utils/jit_fix_operator.py:111
msgid "The input tensor to be clamped."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:99
msgid "The lower bound tensor. Must be broadcastable to the shape of a."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:100
msgid "The upper bound tensor. Must be broadcastable to the shape of a."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:102
#: ../../../src/evox/utils/jit_fix_operator.py:108
#: ../../../src/evox/utils/jit_fix_operator.py:115
msgid ""
"A tensor where each element is clamped to be within the specified bounds."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:98
#: ../../../src/evox/utils/jit_fix_operator.py:105
msgid ""
"This function ensures that each element of the tensor `a` is not less than "
"`lb` and not greater than `ub`."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:100
msgid ""
"Notice/home/bill/Source/evox/src/evox/utils/jit_fix_operator.py:100: "
"(INFO/1) Duplicate implicit target name: \"notice\"."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:102
msgid ""
"This is NOT a precise replication of `torch.clamp` if `a` is a float tensor "
"and may suffer from numerical precision losses. Please use `torch.clamp` "
"instead if a precise clamp is required."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:105
#: ../../../src/evox/utils/jit_fix_operator.py:112
msgid ""
"The lower bound value. Each element of a will be clamped to be not less than"
" lb."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:106
#: ../../../src/evox/utils/jit_fix_operator.py:113
msgid ""
"The upper bound value. Each element of a will be clamped to be not greater "
"than ub."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:107
msgid ""
"Notice/home/bill/Source/evox/src/evox/utils/jit_fix_operator.py:107: "
"(INFO/1) Duplicate implicit target name: \"notice\"."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:109
msgid ""
"This is NOT a precise replication of `torch.clamp` if `a` is a int tensor "
"and may suffer from numerical precision losses. Please use `torch.clamp` "
"instead if a precise clamp is required."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:112
msgid "Notice: This function invokes `clamp(a, 0, 1)`."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:114
msgid "The input tensor to be clipped."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:116
msgid "A tensor where each element is clipped to be within [0, 1]."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:119
#: ../../../src/evox/utils/jit_fix_operator.py:133
#: ../../../src/evox/utils/jit_fix_operator.py:147
msgid ""
"Notice: This is a fix function for "
"[`torch.maximum`](https://pytorch.org/docs/stable/generated/torch.maximum.html]"
" since it is not supported in JIT operator fusion."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:121
#: ../../../src/evox/utils/jit_fix_operator.py:128
#: ../../../src/evox/utils/jit_fix_operator.py:135
#: ../../../src/evox/utils/jit_fix_operator.py:143
#: ../../../src/evox/utils/jit_fix_operator.py:149
#: ../../../src/evox/utils/jit_fix_operator.py:157
msgid "The first input tensor."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:122
#: ../../../src/evox/utils/jit_fix_operator.py:129
msgid "The second input tensor."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:124
#: ../../../src/evox/utils/jit_fix_operator.py:138
#: ../../../src/evox/utils/jit_fix_operator.py:152
msgid "The element-wise maximum of a and b."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:126
msgid ""
"Notice: This is a fix function for "
"[`torch.minimum`](https://pytorch.org/docs/stable/generated/torch.minimum.html]"
" since it is not supported in JIT operator fusion."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:131
#: ../../../src/evox/utils/jit_fix_operator.py:146
#: ../../../src/evox/utils/jit_fix_operator.py:160
msgid "The element-wise minimum of a and b."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:136
#: ../../../src/evox/utils/jit_fix_operator.py:144
msgid "The second input float, which is a scalar value."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:140
#: ../../../src/evox/utils/jit_fix_operator.py:154
msgid ""
"Notice: This is a fix function for "
"[`torch.minimum`](https://pytorch.org/docs/stable/generated/torch.minimum.html)"
" since it is not supported in JIT operator fusion."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:150
#: ../../../src/evox/utils/jit_fix_operator.py:158
msgid "The second input int, which is a scalar value."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:161
msgid ""
"This function sorts the given tensors lexicographically, where sorting is "
"performed by the first key, then by the second key in case of ties in the "
"first key, and so on. It works similarly to NumPy's `lexsort`, but is "
"designed for PyTorch tensors."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:165
msgid ""
"A list of tensors to be sorted, where each tensor represents a sorting key. "
"All tensors must have the same length along the specified dimension (dim)."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:168
msgid ""
"The dimension along which to perform the sorting. Defaults to -1 (the last "
"dimension)."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:170
msgid ""
"A tensor containing indices that will sort the input tensors "
"lexicographically. These indices indicate the order of elements in the "
"sorted tensors."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:173
msgid ""
"Example/home/bill/Source/evox/src/evox/utils/jit_fix_operator.py:173: "
"(INFO/1) Duplicate implicit target name: \"example\"."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:182
msgid "You can use `torch.unbind` to split the tensor into list."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:168
msgid ""
"This function replaces `NaN` values in the input tensor with `infinity` , "
"and then computes the minimum over the specified dimension, effectively "
"ignoring `NaN` values."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:171
#: ../../../src/evox/utils/jit_fix_operator.py:178
msgid ""
"The input tensor, which may contain NaN values. It can be of any shape."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:173
msgid ""
"The dimension along which to compute the minimum. Default is -1, which "
"corresponds to the last dimension."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:175
#: ../../../src/evox/utils/jit_fix_operator.py:182
msgid ""
"Whether to retain the reduced dimension in the result. Default is False. If "
"True, the output tensor will have the same number of dimensions as the "
"input, with the size of the reduced dimension set to 1."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:179
msgid ""
"A named tuple with two fields:values (torch.Tensor): A tensor containing the"
" minimum values computed along the specified dimension, ignoring NaN values."
"  indices (torch.Tensor): A tensor containing the indices of the minimum "
"values along the specified dimension.The returned tensors values and indices"
" will have the same shape as the input tensor, except for the dimension(s) "
"over which the operation was performed."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:179
#: ../../../src/evox/utils/jit_fix_operator.py:186
msgid "A named tuple with two fields:"
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:180
msgid ""
"`values` (`torch.Tensor`): A tensor containing the minimum values computed "
"along the specified dimension,   ignoring `NaN` values."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:182
msgid ""
"`indices` (`torch.Tensor`): A tensor containing the indices of the minimum "
"values along the specified dimension."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:184
#: ../../../src/evox/utils/jit_fix_operator.py:191
msgid ""
"The returned tensors `values` and `indices` will have the same shape as the "
"input tensor, except for the dimension(s) over which the operation was "
"performed."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:186
msgid ""
"Example/home/bill/Source/evox/src/evox/utils/jit_fix_operator.py:186: "
"(INFO/1) Duplicate implicit target name: \"example\"."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:195
msgid ""
"`NaN` values are ignored by replacing them with `infinity` before computing "
"the minimum."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:196
msgid ""
"If all values along a dimension are `NaN`, the result will be `infinity` for"
" that dimension, and the index will be returned as the first valid index."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:175
msgid ""
"This function replaces `NaN` values in the input tensor with `-infinity`, "
"and then computes the maximum over the specified dimension, effectively "
"ignoring `NaN` values."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:180
msgid ""
"The dimension along which to compute the maximum. Default is -1, which "
"corresponds to the last dimension."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:186
msgid ""
"A named tuple with two fields:values (torch.Tensor): A tensor containing the"
" maximum values computed along the specified dimension, ignoring NaN values."
"  indices (torch.Tensor): A tensor containing the indices of the maximum "
"values along the specified dimension.The returned tensors values and indices"
" will have the same shape as the input tensor, except for the dimension(s) "
"over which the operation was performed."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:187
msgid ""
"`values` (`torch.Tensor`): A tensor containing the maximum values computed "
"along the specified dimension,     ignoring `NaN` values."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:189
msgid ""
"`indices` (`torch.Tensor`): A tensor containing the indices of the maximum "
"values along the specified dimension."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:193
msgid ""
"Example/home/bill/Source/evox/src/evox/utils/jit_fix_operator.py:193: "
"(INFO/1) Duplicate implicit target name: \"example\"."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:202
msgid ""
"`NaN` values are ignored by replacing them with `-infinity` before computing"
" the maximum."
msgstr ""

#: ../../../src/evox/utils/jit_fix_operator.py:203
msgid ""
"If all values along a dimension are `NaN`, the result will be `-infinity` "
"for that dimension, and the index will be returned as the first valid index."
msgstr ""

#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:1
msgid "{py:mod}`evox.utils.parameters_and_vector`"
msgstr ""

#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:18
msgid ""
"{py:obj}`ParamsAndVector <evox.utils.parameters_and_vector.ParamsAndVector>`"
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:20
#: ../../../src/evox/utils/parameters_and_vector.py:33
msgid ""
"The class to convert (batched) parameters dictionary to vector(s) and vice "
"versa."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:39
#, fuzzy
msgid "Initialize the ParamsAndVector instance."
msgstr "为问题初始化设置。"

#: ../../../src/evox/utils/parameters_and_vector.py:41
msgid ""
"A PyTorch model whose parameters will be used to initialize the parameter "
"and vector conversion attributes. Must be an initialized PyTorch model."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:46
msgid "Convert the input parameters dictionary to a single vector."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:48
msgid "The input parameters dictionary."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:50
msgid "The output vector obtained by concatenating the flattened parameters."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:54
#, fuzzy
msgid "Convert a batched parameters dictionary to a batch of vectors."
msgstr "`batched_to_vector`可以将一批树状结构转换为一批向量。"

#: ../../../src/evox/utils/parameters_and_vector.py:56
msgid ""
"The input dictionary values must be batched parameters, i.e., they must have"
" the same shape at the first dimension."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:58
msgid "The input batched parameters dictionary."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:60
msgid ""
"The output vectors obtained by concatenating the flattened batched "
"parameters. The first dimension of the output vector corresponds to the "
"batch size."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:62
#, fuzzy
msgid "Convert a vector back to a parameters dictionary."
msgstr "`to_tree` 可以把向量转化回树的形式。"

#: ../../../src/evox/utils/parameters_and_vector.py:64
msgid "The input vector representing flattened model parameters."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:66
msgid "The reconstructed parameters dictionary."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:70
msgid "Convert a batch of vectors back to a batched parameters dictionary."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:72
msgid ""
"The input batch of vectors representing flattened model parameters. The "
"first dimension of the tensor corresponds to the batch size."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:74
msgid ""
"The reconstructed batched parameters dictionary whose tensors' first "
"dimensions correspond to the batch size."
msgstr ""

#: ../../../src/evox/utils/parameters_and_vector.py:78
msgid ""
"The forward function for the `ParamsAndVector` module is an alias of "
"`batched_to_params` to cope with `StdWorkflow`."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.md:1
msgid "{py:mod}`evox.vis_tools`"
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:1
msgid "{py:mod}`evox.vis_tools.exv`"
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:7
msgid "This module helps serialize data to EvoXVision storage format (exv)."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:13
msgid ""
"The numbers are stored in little-endian format. The metadata is a JSON utf-8"
" encoded string, which contains the schema of the binary data. The format of"
" the metadata is as follows:"
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:49
msgid ""
"where <type> represents the data type of the field, available types are:"
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:50
msgid "\"u8\", \"u16\", \"u32\", \"u64\","
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:51
msgid "\"i16\", \"i32\", \"i64\","
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:52
msgid "\"f16\", \"f32\", \"f64\" The size and offset are in bytes."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:56
msgid ""
"The magic number is used to identify the file format. 0x65787631 is the byte"
" code for \"exv1\". The binary data blob is a sequence of binary data "
"chunks. In EvoX, the algorithm is allowed to have a different behavior in "
"the first iteration (initialization phase), which can have a different chunk"
" size than the rest of the iterations. Therefore it contains two different "
"schemas for the initial iteration and the rest of the iterations."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:18
msgid "{py:obj}`EvoXVisionAdapter <evox.vis_tools.exv.EvoXVisionAdapter>`"
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:20 ../../../src/evox/vis_tools/exv.py:61
msgid ""
"EvoXVisionAdapter is a class that streams evolutionary optimization data to "
"an exv file. The exv file format is a binary format that created "
"specifically for the evolutionary optimization data. The format is designed "
"to be efficient for both stream reading and writing data, while being able "
"to randomly access data at any iteration."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:30
msgid "{py:obj}`_get_data_type <evox.vis_tools.exv._get_data_type>`"
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:34
msgid "{py:obj}`new_exv_metadata <evox.vis_tools.exv.new_exv_metadata>`"
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:36 ../../../src/evox/vis_tools/exv.py:53
msgid ""
"Takes the input of the populaton and fitness from the first two iterations, "
"and returns the schema for exv file format."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:67
msgid ""
"Create a new EvoXVisionAdapter instance, which writes data to an exv file. "
"To automatically inference the data schema, the EvoXVisionAdapter requires 2"
" iterations of data, therefore it will only start to write data after the 2 "
"iterations of the optimization loop are completed."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:71
#, fuzzy
msgid "The path to the exv file"
msgstr "到状态保存位置的路径"

#: ../../../src/evox/vis_tools/exv.py:72
msgid ""
"The buffer size to use for file operations, passed directly to the open() "
"function. The default is 0, which disables buffering (unbuffered mode)."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:98
msgid "Write the header of the exv file."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:106
msgid ""
"Stream data to the exv file. Depending on the `buffering` parameter, the "
"data may not be written immediately."
msgstr ""

#: ../../../src/evox/vis_tools/exv.py:114
msgid "Flush the internal buffer to the file."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:1
msgid "{py:mod}`evox.vis_tools.plot`"
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:18
msgid "{py:obj}`plot_dec_space <evox.vis_tools.plot.plot_dec_space>`"
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:20
#: ../../../src/evox/vis_tools/plot.py:50
msgid ""
"A Built-in plot function for visualizing the population of single-objective "
"algorithm. Use plotly internally, so you need to install plotly to use this "
"function."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:22
msgid "{py:obj}`plot_obj_space_1d <evox.vis_tools.plot.plot_obj_space_1d>`"
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:24
#: ../../../src/evox/vis_tools/plot.py:57
msgid ""
"Visualize the fitness values of the population in a single-objective "
"optimization problem."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:26
msgid ""
"{py:obj}`plot_obj_space_1d_no_animation "
"<evox.vis_tools.plot.plot_obj_space_1d_no_animation>`"
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:28
#: ../../../src/evox/vis_tools/plot.py:64
msgid ""
"Visualize the fitness values of the population in a single-objective "
"optimization problem. No animation."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:30
msgid ""
"{py:obj}`plot_obj_space_1d_animation "
"<evox.vis_tools.plot.plot_obj_space_1d_animation>`"
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:32
#: ../../../src/evox/vis_tools/plot.py:71
msgid ""
"Visualize the fitness values of the population in a single-objective "
"optimization problem. With animation."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:34
msgid "{py:obj}`plot_obj_space_2d <evox.vis_tools.plot.plot_obj_space_2d>`"
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:36
#: ../../../src/evox/vis_tools/plot.py:78
msgid ""
"Visualize the fitness values of the population in a multi-objective (2 "
"objectives) optimization problem."
msgstr ""

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:38
msgid "{py:obj}`plot_obj_space_3d <evox.vis_tools.plot.plot_obj_space_3d>`"
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:40
#: ../../../src/evox/vis_tools/plot.py:85
msgid ""
"Visualize the fitness values of the population in a multi-objective (3 "
"objectives) optimization problem."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:53
msgid ""
"If the problem is provided, we will plot the fitness landscape of the "
"problem."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:55
msgid ""
"A list of arrays, each array represents the population of one generation."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:56
#: ../../../src/evox/vis_tools/plot.py:61
#: ../../../src/evox/vis_tools/plot.py:83
#: ../../../src/evox/vis_tools/plot.py:90
msgid "Additional arguments to be passed to the plotly layout."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:58
#: ../../../src/evox/vis_tools/plot.py:63
#: ../../../src/evox/vis_tools/plot.py:85
#: ../../../src/evox/vis_tools/plot.py:92
msgid "A plotly figure."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:59
#: ../../../src/evox/vis_tools/plot.py:80
#: ../../../src/evox/vis_tools/plot.py:87
msgid ""
"A list of arrays, each array represents the fitness values of the population"
" of one generation."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:60
msgid "Whether to show the animation of the fitness values over generations."
msgstr ""

#: ../../../src/evox/vis_tools/plot.py:81
#: ../../../src/evox/vis_tools/plot.py:89
#, fuzzy
msgid "The Pareto front of the problem. Optional."
msgstr "这个问题的完整的维度。"

#: ../../../src/evox/vis_tools/plot.py:82
#: ../../../src/evox/vis_tools/plot.py:88
msgid ""
"Whether to sort the points in the plot. This will only affect the animation "
"behavior."
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.md:1
msgid "{py:mod}`evox.workflows`"
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.md:28
msgid "{py:obj}`__all__ <evox.workflows.__all__>`"
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.md:40
msgid "['EvalMonitor', 'StdWorkflow']"
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:1
msgid "{py:mod}`evox.workflows.eval_monitor`"
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:18
msgid "{py:obj}`EvalMonitor <evox.workflows.eval_monitor.EvalMonitor>`"
msgstr ""

#: ../../../src/evox/workflows/eval_monitor.py:20
#: ../../../src/evox/workflows/eval_monitor.py:33
msgid ""
"Evaluation monitor. Used for both single-objective and multi-objective "
"workflow. Hooked around the evaluation process, can monitor the offspring, "
"their corresponding fitness and keep track of the evaluation count. "
"Moreover, it can also record the best solution or the pareto front on-the-"
"fly."
msgstr ""
"评估监控器被用于单目标和多目标工作流。它与评估流程挂钩，可以监控子代及其相应的适应度并对评估计数进行跟踪。此外，它还能即时记录最优解或帕累托前沿。"

#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:30
msgid "Bases: {py:obj}`evox.core.Monitor`"
msgstr ""

#: ../../../src/evox/workflows/eval_monitor.py:39
#, fuzzy
msgid "Initialize the monitor."
msgstr "初始化"

#: ../../../src/evox/workflows/eval_monitor.py:41
#, fuzzy
msgid "Whether the optimization is multi-objective. Defaults to False."
msgstr "是否是多目标优化。默认为False。"

#: ../../../src/evox/workflows/eval_monitor.py:42
msgid ""
"Whether to record the full history of fitness value. Default to True. "
"Setting it to False may reduce memory usage."
msgstr "是否记录适应度值的完整历史。默认为True。将其设置为FALSE可能会减少内存使用。"

#: ../../../src/evox/workflows/eval_monitor.py:43
#, fuzzy
msgid ""
"Whether to record the full history of solutions. Default to False. Setting "
"it to True may increase memory usage."
msgstr "是否记录适应度值的完整历史。默认为True。将其设置为FALSE可能会减少内存使用。"

#: ../../../src/evox/workflows/eval_monitor.py:44
msgid ""
"Only affect Single-objective optimization. The number of elite solutions to "
"record. Default to 1, which will record the best individual."
msgstr "只影响单目标优化。要记录的精英解决方案的数量。默认为 1，将记录最佳个人。"

#: ../../../src/evox/workflows/eval_monitor.py:45
#, fuzzy
msgid "The device of the monitor. Defaults to None."
msgstr "状态之中对应种群变量的变量名。默认是“population”。"

#: ../../../src/evox/workflows/eval_monitor.py:61
#, fuzzy
msgid "Get the fitness values from the latest iteration."
msgstr "评估给定候选解的适应度。"

#: ../../../src/evox/workflows/eval_monitor.py:69
msgid "Get the solution from the latest iteration."
msgstr ""

#: ../../../src/evox/workflows/eval_monitor.py:77
#, fuzzy
msgid "Get the topk fitness values so far."
msgstr "获取当前的最优适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:85
#, fuzzy
msgid "Get the topk solutions so far."
msgstr "获取当前的最优适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:93
#, fuzzy
msgid "Get the best solution so far."
msgstr "获取当前的最优适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:101
#, fuzzy
msgid "Get the best fitness value so far."
msgstr "获取当前的最优适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:109
msgid "Get the full history of fitness values."
msgstr ""

#: ../../../src/evox/workflows/eval_monitor.py:117
msgid "Get the full history of solutions."
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:1
msgid "{py:mod}`evox.workflows.std_workflow`"
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:18
msgid "{py:obj}`_NegModule <evox.workflows.std_workflow._NegModule>`"
msgstr ""

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:20
msgid "{py:obj}`StdWorkflow <evox.workflows.std_workflow.StdWorkflow>`"
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:22
#: ../../../src/evox/workflows/std_workflow.py:50
#, fuzzy
msgid "The standard workflow."
msgstr "标准工作流"

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:47
msgid "Bases: {py:obj}`evox.core.Workflow`"
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:52
msgid ""
"Usage:/home/bill/Source/evox/src/evox/workflows/std_workflow.py:52: (INFO/1)"
" Duplicate implicit target name: \"usage:\"."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:56
msgid "Initialize the standard workflow with static arguments."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:58
msgid ""
"The optimization direction, can only be \"min\" or \"max\". Defaults to "
"\"min\". If \"max\", the fitness will be negated prior to fitness_transform "
"and monitor."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:63
msgid ""
"Setup the module with submodule initialization. Since all of these arguments"
" are mutable modules to be added as submodules, they are placed here instead"
" of `__init__` and thus `setup` MUST be invoked after `__init__`."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:65
#, fuzzy
msgid "The algorithm to be used in the workflow."
msgstr "监视器可以插入到工作流中。"

#: ../../../src/evox/workflows/std_workflow.py:66
#, fuzzy
msgid "The problem to be used in the workflow."
msgstr "监视器可以插入到工作流中。"

#: ../../../src/evox/workflows/std_workflow.py:67
msgid ""
"The monitors to be used in the workflow. Defaults to None. Notice: usually, "
"monitors can only be used when using JIT script mode."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:68
msgid ""
"The solution transformation function. MUST be JIT-compatible module/function"
" for JIT trace mode or a plain module for JIT script mode (default mode). "
"Defaults to None."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:69
msgid ""
"The fitness transformation function. MUST be JIT-compatible module/function "
"for JIT trace mode or a plain module for JIT script mode (default mode). "
"Defaults to None."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:70
msgid "The device of the workflow. Defaults to None."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:71
msgid ""
"The arguments to be passed to algorithm.setup(**kwargs). If not provided, "
"the algorithm.setup() will not be invoked."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:72
msgid ""
"The arguments to be passed to problem.setup(**kwargs). If not provided, the "
"problem.setup() will not be invoked."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:73
msgid ""
"The arguments to be passed to monitor.setup(**kwargs). If not provided, the "
"monitor.setup() will not be invoked."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:76
msgid ""
"The algorithm, problem and monitor will be IN-PLACE transformed to the "
"target device."
msgstr ""

#: ../../../src/evox/workflows/std_workflow.py:113
msgid ""
"Perform a single optimization step using the algorithm and the problem."
msgstr ""

#: ../../source/apidocs/index.rst:2 ../../source/index.md:15
msgid "API Reference"
msgstr "API文档"

#: ../../source/apidocs/index.rst:4
msgid "This page contains auto-generated API reference documentation [#f1]_."
msgstr ""

#: ../../source/apidocs/index.rst:11
msgid ""
"Created with `sphinx-autodoc2 <https://github.com/chrisjsewell/sphinx-"
"autodoc2>`_"
msgstr ""

#: ../../source/example/brax.ipynb:10002
#, fuzzy
msgid "Solving Brax Problem in EvoX"
msgstr "用EvoX解决Pong问题"

#: ../../source/example/brax.ipynb:10004
msgid ""
"EvoX deeply dives into neuroevolution with Brax. Here we will show an "
"example of solving Brax problem in EvoX."
msgstr ""

#: ../../source/example/brax.ipynb:40002
#: ../../source/guide/user/2-problems.ipynb:50002
msgid "What is Brax"
msgstr ""

#: ../../source/example/brax.ipynb:40004
#: ../../source/guide/user/2-problems.ipynb:50004
msgid ""
"Brax is a fast and fully differentiable physics engine used for research and"
" development of robotics, human perception, materials science, reinforcement"
" learning, and other simulation-heavy applications."
msgstr ""

#: ../../source/example/brax.ipynb:40006
#, fuzzy
msgid "Here we will demonstrate a \"hopper\" environment of Brax."
msgstr "我们将演示在Brax中使用“swimmer”环境。"

#: ../../source/example/brax.ipynb:40008
msgid ""
"For more information, you can browse the [Github of "
"Brax](https://github.com/google/brax)."
msgstr ""

#: ../../source/example/brax.ipynb:50002
#: ../../source/guide/user/2-problems.ipynb:60002
msgid "Design a neural network class"
msgstr ""

#: ../../source/example/brax.ipynb:50004
#: ../../source/guide/user/2-problems.ipynb:60004
msgid ""
"To start with, we need to decide which neural network we are about to "
"construct."
msgstr ""

#: ../../source/example/brax.ipynb:50006
#: ../../source/guide/user/2-problems.ipynb:60006
msgid "Here we will give a simple Multilayer Perceptron (MLP) class."
msgstr ""

#: ../../source/example/brax.ipynb:70002
#: ../../source/guide/user/2-problems.ipynb:80002
msgid "Initiate a model"
msgstr ""

#: ../../source/example/brax.ipynb:70004
msgid "Through the ``SimpleMLP`` class, we can initiate a MLP model."
msgstr ""

#: ../../source/example/brax.ipynb:90002
#: ../../source/guide/user/2-problems.ipynb:160004
msgid "Initiate an adapter"
msgstr ""

#: ../../source/example/brax.ipynb:90004
#: ../../source/guide/user/2-problems.ipynb:160006
#, fuzzy
msgid "An adapter can help us convert the data back-and-forth."
msgstr "现在`adapter`可以帮助我们来回转换数据格式。"

#: ../../source/example/brax.ipynb:110002
#: ../../source/guide/user/2-problems.ipynb:180002
msgid "With an adapter, we can set out to do this Neuroevolution Task."
msgstr ""

#: ../../source/example/brax.ipynb:110004
#: ../../source/guide/user/2-problems.ipynb:180008
msgid "Set up the running process"
msgstr ""

#: ../../source/example/brax.ipynb:110006
#: ../../source/guide/user/1-start.ipynb:40011
#: ../../source/guide/user/2-problems.ipynb:180010
#, fuzzy
msgid "Initiate an algorithm and a problem"
msgstr "创建一个算法和一个问题"

#: ../../source/example/brax.ipynb:110008
msgid ""
"We initiate a [PSO algorithm](#evox.algorithms.pso_variants.pso.PSO), and "
"the problem is a [Brax "
"problem](#evox.problems.neuroevolution.brax.BraxProblem) in \"hopper\" "
"environment."
msgstr ""

#: ../../source/example/brax.ipynb:130002
#: ../../source/guide/user/2-problems.ipynb:200008
#, fuzzy
msgid ""
"In this case, we will be using 1000 steps for each episode, and the average "
"reward of 3 episodes will be returned as the fitness value."
msgstr ""
"现在创建基于 Brax 的问题，其中 `max_episode_length` 是每个回合的最大步数，`num_episodes` "
"是每次评估要运行的回合数。在此情况下，我们将每个回合设置为 1000 步，3 个回合的平均奖励将作为适应度值返回。"

#: ../../source/example/brax.ipynb:130004
#: ../../source/guide/user/1-start.ipynb:60004
#: ../../source/guide/user/2-problems.ipynb:200010
#, fuzzy
msgid "Set an monitor"
msgstr "评估监控器"

#: ../../source/example/brax.ipynb:150002
#: ../../source/guide/user/1-start.ipynb:80002
#: ../../source/guide/user/2-problems.ipynb:220002
#, fuzzy
msgid "Initiate an workflow"
msgstr "分布式工作流程"

#: ../../source/example/brax.ipynb:170002
#: ../../source/guide/user/1-start.ipynb:100002
#: ../../source/guide/user/2-problems.ipynb:240002
#, fuzzy
msgid "Run the workflow"
msgstr "分布式工作流程"

#: ../../source/example/brax.ipynb:170004
#: ../../source/guide/user/2-problems.ipynb:240004
msgid "Run the workflow and see the magic!"
msgstr "运行工作流并见证魔法！"

#: ../../source/example/brax.ipynb:170007
#, fuzzy
msgid ""
"The following block will take around 20 minute to run. The time may vary "
"depending on your hardware."
msgstr "以下这段代码将需要大概10分钟来运行。具体的运行时间取决于您的硬件。"

#: ../../source/example/brax.ipynb:220003
msgid ""
"Normally, you only need `HTML(problem.visualize(best_params))` to render. "
"The code above is a workaround to ensure the result is displayed correctly "
"on our website."
msgstr ""

#: ../../source/example/brax.ipynb:220004
msgid ""
"The PSO algorithm is not specifically optimized for this type of task, so "
"performance limitations are expected. This example is for demonstration "
"purposes."
msgstr ""

#: ../../source/example/brax.ipynb:220007
msgid "We hope you enjoy solving Brax problems with EvoX and have fun!"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:10002
#, fuzzy
msgid "Custom Algorithm and Problem"
msgstr "自定义算法和问题"

#: ../../source/example/custom_algo_prob.ipynb:10003
msgid ""
"In this notebook, we will show how to use the "
"[`Algorithm`](#evox.core.components.Algorithm) and "
"[`Problem`](#evox.core.components.Problem) to create a custom algorithm and "
"problem. Here we will give an example of **implementing a PSO algorithm that"
" solves the Sphere problem**."
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:30002
#: ../../source/guide/developer/3-custom-alg-pro.md:99
msgid "Algorithm example: PSO algorithm"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:30004
msgid ""
"Particle Swarm Optimization (PSO) is a population-based metaheuristic "
"algorithm inspired by the social behavior of birds and fish. It is widely "
"used for solving continuous and discrete optimization problems."
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:30006
#: ../../source/guide/developer/3-custom-alg-pro.md:103
msgid "**Here is an implementation example of PSO algorithm in EvoX:**"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:50002
#: ../../source/guide/developer/3-custom-alg-pro.md:188
msgid "Problem example: Sphere problem"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:50004
#: ../../source/guide/developer/3-custom-alg-pro.md:190
msgid ""
"The Sphere problem is a simple, yet fundamental benchmark optimization "
"problem used to test optimization algorithms."
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:50006
#: ../../source/guide/developer/3-custom-alg-pro.md:192
msgid "The Sphere function is defined as:"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:50008
#: ../../source/guide/developer/3-custom-alg-pro.md:194
msgid ""
"\n"
"\\min f(x)= \\sum_{i=1}^{n} x_{i}^{2}\n"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:50011
#: ../../source/guide/developer/3-custom-alg-pro.md:197
msgid "**Here is an implementation example of Sphere problem in EvoX:**"
msgstr ""

#: ../../source/example/custom_algo_prob.ipynb:70002
#, fuzzy
msgid "Use the algorithm to solve the problem"
msgstr "自定义算法和问题"

#: ../../source/example/custom_algo_prob.ipynb:70004
#, fuzzy
msgid "Initiate the algorithm, problem and monitor"
msgstr "接下来创建algorithm，problem，monitor对象。"

#: ../../source/example/custom_algo_prob.ipynb:90002
#, fuzzy
msgid "Initiate the workflow and run it"
msgstr "现在，重新初始化工作流，并再次执行它。"

#: ../../source/example/index.md:1
msgid "EvoX's examples"
msgstr "EvoX的样例"

#: ../../source/example/moalg.ipynb:10002
#, fuzzy
msgid "Multi-Objective Algorithm"
msgstr "多目标"

#: ../../source/example/moalg.ipynb:20002
#, fuzzy
msgid ""
"In this notebook, we will use the Reference Vector Guided Evolutionary "
"Algorithm (**RVEA**) to find the optimal solutions of the **DTLZ2** problem."
msgstr "在这个文档里，我们会使用粒子群算法来寻找Ackley测试问题的最小值。"

#: ../../source/example/moalg.ipynb:40002
msgid "(Optional) Use GPU to run the code"
msgstr ""

#: ../../source/example/moalg.ipynb:40003
msgid ""
"We often prefer to run our code on a GPU for faster execution. However, if a"
" GPU is unavailable, running on a CPU is also acceptable."
msgstr ""

#: ../../source/example/moalg.ipynb:60002
msgid "Running example: RVEA on DTLZ2 problem"
msgstr ""

#: ../../source/example/moalg.ipynb:60003
msgid ""
"The following code is used to set up the "
"[`DTLZ2`](#evox.problems.numerical.dtlz) problem and the "
"[`RVEA`](#evox.algorithms.mo.rvea) algorithm. More information about the "
"problem and algorithm can be found in the corresponding section of the "
"documentation."
msgstr ""

#: ../../source/example/moalg.ipynb:80002
msgid ""
"With this setup in place, we can now start to optimize. We set to let the "
"multi-objective algorithm optimize for 100 steps on this problem"
msgstr ""

#: ../../source/example/moalg.ipynb:100002
msgid ""
"(Optional) You can uncomment and execute the following code to print a table"
" to view the hotspot functions."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:10002
msgid "Numerical Optimization"
msgstr "数值优化"

#: ../../source/example/so-algorithm.ipynb:20002
msgid ""
"This notebook offers a step-by-step tutorial on utilizing EvoX to optimize "
"the Ackley function through the Particle Swarm Optimization (PSO) algorithm."
" Both the PSO algorithm and the Ackley optimization problem are integrated "
"as built-in components within the EvoX framework."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:20004
msgid ""
"First, we should import all necessary modules including `PSO` (algorithm), "
"`Ackley` (problem) and `StdWorkflow` & `EvalMonitor` (workflow)."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:40002
msgid ""
"Here, we instantiate the [`PSO`](#evox.algorithms.pso_variants.pso) "
"algorithm. We specify the following settings:"
msgstr ""

#: ../../source/example/so-algorithm.ipynb:40004
msgid "`pop_size`: The size of the particle swarm (population)."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:40005
msgid ""
"`lb` and `ub`: The lower and upper bounds for each dimension in the search "
"space."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:40006
msgid "Other parameters are all default. Please refer to the detailed API."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:60002
msgid ""
"Next, we choose the [`Ackley`](#evox.problems.numerical.basic.Ackley) "
"function in EvoX' s numerical problem."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:80002
msgid ""
"We creat an [`EvalMonitor`](#evox.workflows.eval_monitor.EvalMonitor) "
"instance to track necessary information during the optimization procedure."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:100002
msgid ""
"The [`StdWorkflow`](#evox.workflows.std_workflow.StdWorkflow) class provides"
" a standardized process to integrate the algorithm, problem, and monitor."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:120002
msgid ""
"Calling `setup()` initializes the components so that the workflow is ready "
"to perform optimization steps."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:140002
msgid ""
"We run the optimization for a certain number of iterations (100 in this "
"example). In each iteration, the `step()` method updates the PSO algorithm, "
"evaluates new candidate solutions on the Ackley function, and tracks their "
"fitness via the monitor."
msgstr ""

#: ../../source/example/so-algorithm.ipynb:160002
msgid ""
"Finally, we retrieve the [`monitor`](#StdWorkflow.get_submodule) submodule "
"from the workflow to access the top solutions found so far "
"(`topk_solutions`) and their corresponding objective values "
"(`topk_fitness`). We then print the best result and the associated solution."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:10002
msgid "Solving Supervised Learning Tasks with Neuroevolution in EvoX"
msgstr ""

#: ../../source/example/supervised-learning.ipynb:20002
msgid ""
"EvoX provides solutions for supervised learning tasks based on "
"neuroevolution, with key modules including "
"[`SupervisedLearningProblem`](#evox.problems.neuroevolution.SupervisedLearningProblem)"
" and [`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector)."
" Taking the MNIST classification task as an example, this section "
"illustrates the neuroevolution process for supervised learning by adopting "
"the modules of EvoX."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:30002
msgid "Basic Setup"
msgstr ""

#: ../../source/example/supervised-learning.ipynb:40002
msgid ""
"Basic component imports and device configuration serve as the essential "
"starting steps for the neuroevolution process."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:40004
msgid ""
"Here, to ensure the reproducibility of results, a random seed can be "
"optionally set."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:60002
msgid ""
"In this step, a sample convolutional neural network (CNN) model is directly "
"defined upon the PyTorch framework and then loaded onto the device."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:80002
msgid ""
"Setting dataset implies the selection of the task. The data loader now needs"
" to be initialized based on PyTorch's built-in support. Here, the package "
"`torchvision` must be installed in advance depending on your PyTorch "
"version, if it is not already available."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:80005
msgid ""
"In case the MNIST dataset is not already present in the `data_root` "
"directory, the `download=True` flag is set to ensure that the dataset will "
"be automatically downloaded. Therefore, the setup may take some time during "
"the first run."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:100002
msgid ""
"To accelerate subsequent processes, all MNIST data are pre-loaded for faster"
" execution. Below, three datasets are pre-loaded for different stages "
"&ndash; gradient descent training, neuroevolution fine-tuning, and model "
"testing."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:100004
msgid ""
"It should be noted that this is an optional operation that trades space for "
"time. Its adoption depends on your GPU capacity, and it will always take "
"some time to prepare."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:120002
msgid ""
"Here, a `model_test` function is pre-defined to simplify the evaluation of "
"the model's prediction accuracy on the test dataset during subsequent "
"stages."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:140002
msgid "Gradient Descent Training (Optional)"
msgstr ""

#: ../../source/example/supervised-learning.ipynb:150002
msgid ""
"The gradient descent based model training is performed first. In this "
"example, this training is adopted to initialize the model, preparing it for "
"subsequent neuroevolution processes."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:150004
msgid ""
"The model training process in PyTorch is compatible with neuroevolution in "
"EvoX, making it convenient to reuse the same model implementation for "
"further steps."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:180002
msgid "Neuroevolution Fine-Tuning"
msgstr ""

#: ../../source/example/supervised-learning.ipynb:190002
msgid ""
"Based on the pre-trained model from the previous gradient descent process, "
"neuroevolution is progressively applied to fine-tune the model."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:190004
msgid ""
"First, the "
"[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector) "
"component is used to flatten the weights of the pre-trained model into a "
"vector, which serves as the initial center individual for the subsequent "
"neuroevolution process."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:210002
msgid ""
"In case of algorithms specifically designed for neuroevolution, which can "
"directly accept a dictionary of batched parameters as input, the usage of "
"[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector) can "
"be unnecessary."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:220002
msgid ""
"Additionally, a sample criterion is defined. Here, both the loss and "
"accuracy of the individual model are selected and weighted to serve as the "
"fitness function in the neuroevolution process. This step is customizable to"
" suit the optimization direction."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:240002
msgid ""
"At the same time, similar to the gradient descent training and model testing"
" processes, the neuroevolution fine-tuning process is also encapsulated into"
" a function for convenient use in subsequent stages."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:260002
msgid "Population-Based Neuroevolution Test"
msgstr ""

#: ../../source/example/supervised-learning.ipynb:270002
msgid ""
"In this example, the population-based algorithm for neuroevolution is tested"
" first, using Particle Swarm Optimization "
"([PSO](#evox.algorithms.pso_variants.PSO)) as a representation. The "
"configuration for neuroevolution is similar to that of other optimization "
"tasks &ndash; we need to define the problem, algorithm, monitor, and "
"workflow, along with their respective `setup()` functions to complete the "
"initialization."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:270004
msgid ""
"A key point to note here is that the population size (`POP_SIZE` in this "
"case) needs to be initialized in **both the problem and the algorithm** to "
"avoid potential errors."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:300002
msgid "Single-Individual Neuroveolution Test"
msgstr ""

#: ../../source/example/supervised-learning.ipynb:310002
msgid ""
"Next, the single-individual algorithm based neuroevolution is tested. "
"Similar to the population-based case, we need to define the problem, "
"algorithm, monitor, and workflow, and call their respective `setup()` "
"functions during initialization. In this case, a random search strategy is "
"selected as the algorithm."
msgstr ""

#: ../../source/example/supervised-learning.ipynb:310004
msgid ""
"A key point to note here is that "
"[`SupervisedLearningProblem`](#evox.problems.neuroevolution.SupervisedLearningProblem)"
" should be set with `pop_size=None`, and "
"[`EvalMonitor`](#evox.workflows.EvalMonitor) should have `topk=1`, as only a"
" single individual is being searched. A careful hyper-parameter setup helps "
"avoid unnecessary issues."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:1
#, fuzzy
msgid "Working with Module in EvoX"
msgstr "在EvoX中使用State"

#: ../../source/guide/developer/1-modulebase.md:3
msgid ""
"A **module** is a fundamental concept in programming that refers to a self-"
"contained unit of code designed to perform a specific task or a set of "
"related tasks."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:5
msgid ""
"This notebook will introduce the basic module in EvoX: "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:7
msgid "Introduction to Module"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:9
msgid ""
"In the [Quick Start Documentation](#/guide/user/1-start) of the [User "
"Guide](#/guide/user/index), we have mentioned the basic running process in "
"EvoX:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:13
msgid "This process requires four basic class in EvoX:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:15
msgid "[`Algorithm`](#evox.core.components.Algorithm)"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:16
msgid "[`Problem`](#evox.core.components.Problem)"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:17
msgid "[`Monitor`](evox.core.components.Monitor)"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:18
msgid "[`Workflow`](#evox.core.components.Workflow)"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:21
msgid ""
"It is necessary to provide a unified module for them. In EvoX, the four "
"classes are all inherited from the base module — "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
#, fuzzy
msgid "Module base"
msgstr "模块类"

#: ../../source/guide/developer/1-modulebase.md:28
#, fuzzy
msgid "ModuleBase class"
msgstr "模块类"

#: ../../source/guide/developer/1-modulebase.md:30
msgid ""
"The [`ModuleBase`](#evox.core.module.ModuleBase) class is inherited from "
"[`torch.nn.Module`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#)."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:32
msgid ""
"There are many methods in this class, and some important methods are here:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "Method"
msgstr "方法"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "Signature"
msgstr "签名"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "Usage"
msgstr "使用情况"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
#, fuzzy
msgid "`__init__`"
msgstr "__init__"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#: ../../source/guide/developer/3-custom-alg-pro.md:38
#, fuzzy
msgid "`(self, ...)`"
msgstr "{python}`(self, ...)`"

#: ../../source/guide/developer/1-modulebase.md:23
#, fuzzy
msgid "Initialize the module."
msgstr "初始化这个模块和所有的子模块"

#: ../../source/guide/developer/1-modulebase.md:23
#, fuzzy
msgid "`setup`"
msgstr "设置"

#: ../../source/guide/developer/1-modulebase.md:23
#: ../../source/guide/developer/3-custom-alg-pro.md
#, fuzzy
msgid "`(self, ...) -> self`"
msgstr "{python}`(self, ...)`"

#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"Module initialization lines should be written in the overwritten method of "
"`setup` rather than `__init__`."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
msgid "`load_state_dict`"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"`(self, state_dict: Mapping[str, torch.Tensor], copy: bool = False, ...)`"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"Copy parameters and buffers from `state_dict` into this module and its "
"descendants. It overwrites "
"[`torch.nn.Module.load_state_dict`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.load_state_dict)."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
msgid "`add_mutable`"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:23
msgid ""
"`(self, name: str, value: Union[torch.Tensor | nn.Module, "
"Sequence[torch.Tensor | nn.Module], Dict[str, torch.Tensor | nn.Module]]) ->"
" None`"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:41
msgid "Role of Module"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:43
msgid ""
"In EvoX, the [`ModuleBase`](#evox.core.module.ModuleBase) could help to:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:45
msgid "**Contain mutable values**"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:47
msgid ""
"​\tThis module is an object-oriented one that can contain mutable values."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:49
msgid "**Support functional programming**"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:51
msgid ""
"​\tFunctional programming model is supported via `self.state_dict()` and "
"`self.load_state_dict(...)`."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:53
msgid "**Standardize the initialization**:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:55
msgid ""
"​\tBasically, predefined submodule(s) which will be ADDED to this module and"
" accessed later in member method(s) should be treated as \"non-static "
"members\", while any other member(s) should be treated as \"static "
"members\"."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:57
msgid ""
"​\tThe module initialization for non-static members are recommended to be "
"written in the overwritten method of `setup` (or any other member method) "
"rather than `__init__`."
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:59
#, fuzzy
msgid "Usage of Module"
msgstr "这个模块的状态。"

#: ../../source/guide/developer/1-modulebase.md:61
msgid ""
"Specifically, there are some rules for using "
"[`ModuleBase`](#evox.core.module.ModuleBase) in EvoX:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:63
#, fuzzy
msgid "Static methods"
msgstr "方法"

#: ../../source/guide/developer/1-modulebase.md:65
msgid "Static methods to be JIT shall be defined like:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:74
msgid "Non-static Methods"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:76
msgid ""
"If a method with python dynamic control flows like `if` were to be JIT, a "
"separated static method with `jit(..., trace=False)` or "
"`torch.jit.script_if_tracing` shall be used:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:102
msgid "Supporting for JIT and non-JIT functions"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:104
msgid ""
"[`ModuleBase`](#evox.core.module.ModuleBase) is usually used with "
"`jit_class` to automatically JIT all non-magic member methods:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:128
msgid ""
"An example of one module inherited from the "
"[`ModuleBase`](#evox.core.module.ModuleBase) is like:"
msgstr ""

#: ../../source/guide/developer/1-modulebase.md:150
msgid ""
"For more details, please look through [the Module in "
"EvoX](#evox.core.module)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:10002
msgid "Optimizing Development for EvoX via PyTorch Advanced Techniques"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:20002
msgid "Basic Optimization Support for Functions in PyTorch"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:20004
msgid ""
"PyTorch provides fundamental optimization support for functions, primarily "
"through vectorizing map (vmap) operations and Just-In-Time (JIT) "
"compilation. These techniques enable efficient batch processing and enhance "
"execution performance, respectively. Introductions of these optimizations "
"are provided in the following sections."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:30002
msgid "Batch Processing Support through Vectorizing Map in PyTorch"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:30004
msgid ""
"Vectorizing map, implemented in PyTorch as "
"[`torch.vmap`](https://pytorch.org/docs/stable/generated/torch.vmap.html), "
"is a powerful tool that takes a callable function and returns a batched "
"version of it. According to specified strategy, this new function vectorizes"
" the operations of the original one, which facilitates efficient batch "
"processing. In EvoX, for example, this feature plays a crucial role in "
"hyperparameter optimization (HPO)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:50002
msgid "Just-In-Time (JIT) Support in PyTorch"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:50004
msgid ""
"In PyTorch, "
"[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
" and "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" provide two distinct types of JIT tools, supporting function performance "
"optimization through tracing and scripting, respectively."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:50006
msgid ""
"Based on the tracing strategy, the `torch.jit.trace` method offers higher "
"parsing speed and broader compatibility, such as with `torch.vmap` "
"operations. Although it provides excellent support for simple functions, it "
"is not suitable for complex tasks involving dynamic if-else branches and "
"loop control flows."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:70002
msgid ""
"In the example below, the traced `vmap` function successfully returns the "
"correct code representation:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:90002
msgid ""
"However, dynamic python control-flow cannot be traced correctly and a "
"warning will be raised:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:110002
msgid ""
"Alternatively, the `torch.jit.script` method, which adopts a scripting "
"strategy, is better suited for complex tasks that involve dynamic control "
"flows but has limited compatibility."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:120002
msgid ""
"In this example, the same `vmap_sample_func` function, after being scripted,"
" returns an **incorrect** code representation:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:140002
msgid "Yet, it can correctly deal with complex dynamic python control flow:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:160003
msgid ""
"`torch.jit.script` relies on type hint to work properly. For example, any "
"unannotated input argument is treated as a `torch.Tensor` while you can "
"annotate some input arguments to be python types to make `torch.jit.script` "
"work as intended."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170002
msgid "Combined Usage of JIT and Vectorizing Map in PyTorch"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170004
msgid ""
"Based on the introductions above, when `torch.jit.trace` and "
"`torch.jit.script` are used in combination with `torch.vmap`, coordination "
"is required due to compatibility considerations."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170006
msgid ""
"The figure below illustrates the relationship between `torch.jit.script`, "
"`torch.jit.trace`, and `torch.vmap`, highlighting their mutual invocation "
"paths. If module A invokes module B, it implies that B can be called by A."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170008
msgid "JIT introduction"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:170013
msgid ""
"For detailed usage of JIT and vectorizing map on PyTorch, please refer to "
"the official PyTorch documentation for "
"[TorchScript](#https://pytorch.org/docs/stable/jit.html) and "
"[`torch.vmap`](#https://pytorch.org/docs/stable/generated/torch.vmap.html)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:180002
msgid "Specific Optimization Support in EvoX"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:180004
msgid ""
"Within EvoX, most functions are defined inside classes, particularly "
"subclasses of [`ModuleBase`](#evox.core.module.ModuleBase). To provide more "
"comprehensive optimization supports, EvoX offers specific enhancements."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:190002
msgid ""
"Using JIT to Subclasses of [`ModuleBase`](#evox.core.module.ModuleBase)"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:200002
msgid ""
"For better understanding of this part, we need to explain three important "
"functions in EvoX: [`jit_class`](#evox.core.module.jit_class), "
"[`vmap`](#evox.core.jit_util.vmap) and [`jit`](l#evox.core.jit_util.jit)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:210002
msgid "[`jit_class`](#evox.core.module.jit_class) Function"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220002
msgid ""
"[`jit_class`](#evox.core.module.jit_class) is a helper function used to "
"Just-In-Time (JIT) script of "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" or trace "
"([`torch.jit.trace_module`](https://pytorch.org/docs/stable/generated/torch.jit.trace_module.html#torch-"
"jit-trace-module)) all member methods of the input class."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220004
msgid "[`jit_class`](#evox.core.module.jit_class) has two parameters:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220006
msgid "`cls`: the original class whose member methods are to be lazy JIT."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220007
#, fuzzy
msgid ""
"`trace`: whether to trace the module or to script the module. Default to "
"`False`."
msgstr "是否在工作流开始时清除监视器历史记录。默认值为 `True`。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220010
msgid ""
"In many cases, it is not necessary to wrap your custom algorithms or "
"problems with [`jit_class`](#evox.core.module.jit_class), the workflow(s) "
"will do the trick for you."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:220011
msgid ""
"With `trace=True`, all the member functions are effectively modified to "
"return `self` additionally since side-effects cannot be traced. If you want "
"to preserve the side effects, please set `trace=False` and use the "
"`use_state` function to wrap the member method to generate pure-functional "
"(the `use_state` function will be explained in the next part)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:230003
msgid "[`vmap`](#evox.core.jit_util.vmap) Function"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:240002
msgid ""
"[`vmap`](#evox.core.jit_util.vmap) function vectorized map the given "
"function to its mapped version. Based on "
"[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html), we "
"made many improvements, and you can see "
"[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html) for "
"more information."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:250002
msgid "[`jit`](#evox.core.jit_util.jit) Function"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260002
msgid ""
"[`jit`](#evox.core.jit_util.jit) compile the given `func` via "
"[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
" (`trace=True`) or "
"[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
" (`trace=False`)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260007
msgid ""
"With `trace=True`, `torch.jit.trace` cannot use SAME example input arguments"
" for function of DIFFERENT parameters,e.g., you cannot pass `tensor_a, "
"tensor_a` to `torch.jit.trace`d version of `f(x: torch.Tensor, y: "
"torch.Tensor)`."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260008
msgid ""
"With `trace=False`, `torch.jit.script` cannot contain `vmap` expressions "
"directly, please wrap them with `jit(..., trace=True)` or `torch.jit.trace`."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:260011
msgid ""
"In the [Working with Module in EvoX](#/guide/developer/1-modulebase), we "
"have briefly introduced some rules about the methods inside a subclass of "
"the [`ModuleBase`](#evox.core.module.ModuleBase) . Now that "
"[`jit_class`](#evox.core.module.jit_class), "
"[`vmap`](#evox.core.jit_util.vmap) and [`jit`](#evox.core.jit_util.jit) have"
" been explained, we will explain more rules and provide some specific hints."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:270002
msgid "Definition of Static Methods Inside the Subclass"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:280002
msgid "Inside the subclass, static methods to be JIT shall be defined like:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:290002
msgid "Definition of Non-static Methods Inside the Subclass"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:300002
msgid ""
"If a method with **Python dynamic control flows** like `if` were to be JIT, "
"a separated static method with `jit(..., trace=False)` or "
"`torch.jit.script_if_tracing` shall be used:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:300035
msgid ""
"Dynamic control flow in Python refers to control structures that change "
"dynamically based on conditions at runtime. `if...elif...else` Conditional "
"Statements, `for`loop and `while` loop are all dynamic control flows. If you"
" have to use them when defining non-static Methods inside the subclass of "
"[`ModuleBase`](#evox.core.module.ModuleBase), please follow the above rule."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:310002
msgid "Invocation of External Methods Inside the Subclass"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:320002
msgid ""
"Inside the subclass, external JIT methods can be invocated by the class "
"methods to be JIT:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:330002
msgid "Automatically JIT for the Subclass Used with `jit_class`"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:340002
msgid ""
"[`ModuleBase`](#evox.core.module.ModuleBase)  and its subclasses are usually"
" used with [`jit_class`](#evox.core.module.jit_class) to automatically JIT "
"all non-magic member methods:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:350002
msgid "Invocation of External Vmap-wrapped Methods Inside the Subclass"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:360002
msgid ""
"Inside the subclass, external vmap-wrapped methods can be invocated by the "
"class methods to be JIT:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:360034
msgid ""
"If method A invokes vmap-wrapped method B, then A and all methods invoke "
"method A can not be vmap-wrapped again."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:370002
msgid "Internal Vmap-wrapped Methods Inside the Subclass"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:380002
msgid ""
"Inside the subclass, internal vmap-wrapped methods can be  JIT by using the "
"[`trace_impl`](#evox.core.module.trace_impl):"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:380040
msgid ""
"If a class method use [`trace_impl`](#evox.core.module.trace_impl), it will "
"be only available in the trace mode. More details about `trace_impl` will be"
" shown in the next part."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390002
msgid "Using `@trace_impl` and `@vmap_impl`"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390004
msgid ""
"When designing a function or method, you may not always consider whether it "
"is `JIT`-compatible. However, this property becomes crucial in specific "
"scenarios, such as solving Hyperparameter Optimization (HPO) problems. For "
"more details on deploying HPO with EvoX, refer to [Efficient HPO with "
"EvoX](#/guide/user/3-hpo)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390006
msgid ""
"A typical characteristic of such problems is that only certain parts of the "
"algorithm need modification—for instance, the `step` method of an algorithm."
" This allows you to avoid rewriting the entire algorithm. In such cases, you"
" can use the `@trace_impl` or `@vmap_impl` decorator to rewrite the function"
" as a trace-JIT-time or vmap-JIT-time proxy for the specified `target` "
"method."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390008
msgid ""
"The decorators [`@trace_impl`](#trace_impl) and [`@vmap_impl`](#vmap_impl) "
"accept a single input parameter: the target method invoked when not "
"tracing/vmapping JIT. These decorators are applicable **only** to member "
"methods within a `jit_class`."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390010
msgid ""
"Since the annotated function serves as a rewritten version of the target "
"function, it must maintain identical input/output signatures (e.g., number "
"and types of arguments). Otherwise, the resulting behavior is undefined."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390012
msgid ""
"If the annotated function is intended for use with `vmap`, it must satisfy "
"three additional constraints:"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390014
msgid ""
"**No In-Place Operations on Attributes:** The algorithm must not include "
"methods that perform in-place operations on its attributes."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390029
msgid ""
"**Avoid Python Control Flow:** The code logic must not rely on Python "
"control flow structures. To handle Python control flow, use "
"[`TracingCond`](#TracingCond), [`TracingWhile`](#TracingWhile), and "
"[`TracingSwitch`](#TracingSwitch)."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390079
msgid ""
"**Avoid In-Place Operations on `self`:** Vectorized map in-place operations "
"on `self` are not well-defined and cannot be compiled. Even if it is "
"compiled successfully, you can still silently get incorrect results."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390082
#, fuzzy
msgid "Using `use_state`"
msgstr "状态。"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390084
msgid ""
"[`use_state`](#use_state) transforms a given stateful function (which "
"performs in-place alterations on `nn.Module`s) into a pure-functional "
"version that receives an additional `state` parameter (of type `Dict[str, "
"torch.Tensor]`) and returns the altered state."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390086
msgid ""
"The input `func` is the stateful function to be transformed or its generator"
" function, and `is_generator` specifies whether `func` is a function or a "
"function generator (e.g., a lambda that returns the stateful function). It "
"defaults to `True`."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390088
#, fuzzy
msgid "Here is a simple example:"
msgstr "代码样例"

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390129
msgid "Using `core._vmap_fix`"
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390131
msgid ""
"The module [`_vmap_fix`](#_vmap_fix) provides useful functions. After the "
"automatic import, `_vmap_fix` enables `torch.vmap` to be correctly traced by"
" `torch.jit.trace`, while resolving issues such as random number handling "
"that couldn't be properly traced during the `vmap` process. It also provides"
" the `debug_print` function, which allows dynamic printing of Tensor values "
"during both `vmap` and tracing."
msgstr ""

#: ../../source/guide/developer/2-jit-vmap-tutorial.ipynb:390133
msgid ""
"Detailed information can be found in the [`_vmap_fix`](#_vmap_fix) "
"documentation."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:1
msgid "Custom algorithms and problems in EvoX"
msgstr "EvoX中的自定义算法和问题"

#: ../../source/guide/developer/3-custom-alg-pro.md:3
#, fuzzy
msgid ""
"In this chapter, we will introduce how to implement your own algorithms and "
"problems in EvoX."
msgstr "在本章中，我们将介绍如何在 EvoX 中实现您自己的算法。"

#: ../../source/guide/developer/3-custom-alg-pro.md:5
#, fuzzy
msgid "Layout of the algorithms and problems"
msgstr "自定义算法和问题"

#: ../../source/guide/developer/3-custom-alg-pro.md:7
#, fuzzy
msgid ""
"In most traditional EC libraries, algorithms usually call the objective "
"function internally, which gives the following layout:"
msgstr "在传统的EC库中，算法通常在内部调用目标函数，其布局如下"

#: ../../source/guide/developer/3-custom-alg-pro.md:15
#, fuzzy
msgid "**But in EvoX, we have a flat layout:**"
msgstr "但在 EvoX 中，我们采用了扁平布局"

#: ../../source/guide/developer/3-custom-alg-pro.md:21
msgid ""
"This layout makes both algorithms and problems more universal: an algorithm "
"can optimize different problems, while a problem can also be suitable for "
"many algorithms."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:25
#, fuzzy
msgid "Algorithm class"
msgstr "算法类"

#: ../../source/guide/developer/3-custom-alg-pro.md:27
msgid ""
"The [`Algorithm`](#evox.core.components.Algorithm) class is inherited from "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:29
msgid ""
"**In total,** **there are 5 methods (2 methods are optional) that we need to"
" implement:**"
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid ""
"Initialize the algorithm instance, for example, the population size (keeps "
"constant during iteration), hyper-parameters (can only be set by HPO problem"
" wrapper or initialized here), and / or mutable tensors (can be modified on "
"the fly)."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md
#, fuzzy
msgid "`setup` (optional)"
msgstr "init_ask (可选的)"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid ""
"Initialize the mutable submodule(s) of the algorithm. See "
"[`ModuleBase`](#evox.core.module.ModuleBase). Usually, it is not necessary "
"to overwrite this method."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "`step`"
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "`(self)`"
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid "Perform a normal optimization iteration step of the algorithm."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md
#, fuzzy
msgid "`init_step` (optional)"
msgstr "init_tell (可选的 )"

#: ../../source/guide/developer/3-custom-alg-pro.md
msgid ""
"Perform the first step of the optimization of the algorithm. If this method "
"were not overwritten, the `step` method would be invoked instead."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:39
msgid ""
"The static initialization can still be written in the `__init__` while the "
"mutable submodule(s) initialization cannot. Therefore, multiple calls of "
"`setup` for repeated initializations are possible if the overwritten `setup`"
" method invokes the `setup()` of "
"[`ModuleBase`](#evox.core.module.ModuleBase) first."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:41
msgid ""
"If such `setup` method in [`ModuleBase`](#evox.core.module.ModuleBase) is "
"not suitable for your algorithm, you can override the `setup` method when "
"you create your own algorithm class."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:45
#, fuzzy
msgid "Problem class"
msgstr "问题类"

#: ../../source/guide/developer/3-custom-alg-pro.md:47
msgid ""
"The [`Problem`](#evox.core.components.Problem) class is also inherited from "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:49
#, fuzzy
msgid ""
"However, the Problem class is quite simple. **Beside the `__init__` method, "
"the only necessary method is the `evaluate` method.**"
msgstr "`Problem` 类相当简单，除了 `__init__` 和 `setup`，唯一必需的方法是 `evaluate`。"

#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "Initialize the settings of the problem."
msgstr "为问题初始化设置。"

#: ../../source/guide/developer/3-custom-alg-pro.md:38
#, fuzzy
msgid "`evaluate`"
msgstr "评估"

#: ../../source/guide/developer/3-custom-alg-pro.md:38
msgid "`(self, pop: torch.Tensor) -> torch.Tensor`"
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:38
#, fuzzy
msgid "Evaluate the fitness of the given population."
msgstr "评估给定候选解的适应度。"

#: ../../source/guide/developer/3-custom-alg-pro.md:56
msgid ""
"However, the type of `pop` argument in `evaluate` can be changed to other "
"JIT-compatible types in the overwritten method."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:59
msgid "Example"
msgstr "样例"

#: ../../source/guide/developer/3-custom-alg-pro.md:61
msgid ""
"Here we give an example of **implementing a PSO algorithm that solves the "
"Sphere problem**."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:63
#, fuzzy
msgid "Pseudo-code of the example"
msgstr "代码样例"

#: ../../source/guide/developer/3-custom-alg-pro.md:65
#, fuzzy
msgid "Here is a pseudo-code:"
msgstr "这是一个遗传算法的伪代码。"

#: ../../source/guide/developer/3-custom-alg-pro.md:81
#, fuzzy
msgid ""
"And here is what each part of the algorithm and the problem corresponds to "
"in EvoX."
msgstr "这里是算法的每个部分在 EvoX 中对应的内容。"

#: ../../source/guide/developer/3-custom-alg-pro.md:101
msgid ""
"Particle Swarm Optimization (PSO) is a population-based meta-heuristic "
"algorithm inspired by the social behavior of birds and fish. It is widely "
"used for solving continuous and discrete optimization problems."
msgstr ""

#: ../../source/guide/developer/3-custom-alg-pro.md:212
#, fuzzy
msgid "Now, you can initiate a workflow and run it."
msgstr "现在你可以组合出一个workflow并运行。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:1
msgid "Transformation from MATLAB to PyTorch and EvoX"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:3
msgid ""
"This document aims to guide MATLAB users in transitioning to PyTorch and "
"EvoX for evolutionary computation. We will highlight the core differences "
"between MATLAB and PyTorch in terms of syntax, data structures, and "
"workflow. We will then illustrate these differences using a Particle Swarm "
"Optimization (PSO) example in both MATLAB and PyTorch."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:5
msgid "Syntax Differences"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:7
msgid "Array Creation and Indexing"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:9
#: ../../source/guide/developer/4-transfer-from-matlab.md:23
#: ../../source/guide/developer/4-transfer-from-matlab.md:43
#: ../../source/guide/developer/4-transfer-from-matlab.md:57
#: ../../source/guide/developer/4-transfer-from-matlab.md:69
#: ../../source/guide/developer/4-transfer-from-matlab.md:81
#: ../../source/guide/developer/4-transfer-from-matlab.md:91
msgid "MATLAB"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:11
msgid "Uses 1-based indexing."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:12
msgid ""
"Vectors and matrices are declared using square brackets and semicolons "
"(e.g., `[1 2 3; 4 5 6]`). Random initialization with `rand()` returns values"
" in the interval $[0, 1)$."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:13
msgid ""
"Slicing is performed using the `(start:end)` syntax and utilizes 1-based "
"indexing."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:15
#: ../../source/guide/developer/4-transfer-from-matlab.md:32
#: ../../source/guide/developer/4-transfer-from-matlab.md:49
#: ../../source/guide/developer/4-transfer-from-matlab.md:62
#: ../../source/guide/developer/4-transfer-from-matlab.md:74
#, fuzzy
msgid "PyTorch"
msgstr "安装ROCm"

#: ../../source/guide/developer/4-transfer-from-matlab.md:17
msgid "Uses 0-based indexing."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:18
msgid ""
"Arrays (tensors) are typically created using constructors like "
"`torch.rand()`, `torch.zeros()`, or Python lists converted to tensors with "
"`torch.tensor()`."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:19
msgid "Slicing is done using `[start:end]` with 0-based indices."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:21
#, fuzzy
msgid "Matrix Computation"
msgstr "种群。"

#: ../../source/guide/developer/4-transfer-from-matlab.md:25
msgid "Performs linear algebraic matrix multiplication by `*`."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:26
msgid ""
"Uses `.*` to multiply corresponding elements of matrices of the same size."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:27
msgid "`/` represents the matrix right division."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:28
msgid "`.^` represents the element-wise power."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:29
msgid ""
"Trailing and leading dimension(s) of tensors with length 1 is/are "
"**ignored**."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:30
msgid ""
"Automatically find broadcastable dimensions for element-wise operations and "
"perform **implicit** dimension extension."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:34
msgid ""
"Performs linear algebraic matrix multiplication by `@` or `torch.matmul()`."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:35
msgid ""
"Directly uses `*` to multiply corresponding elements of tensors of the same "
"shape or broadcastable shapes."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:36
msgid "`/` represents the element-wise division."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:37
msgid "`**` represents the element-wise power."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:38
msgid ""
"Dimension(s) of tensors with length 1 is/are **preserved** and treated as "
"**broadcast dimension**."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:39
msgid ""
"**Prevent** most implicit dimension extension, broadcast dimension(s) are "
"usually required."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:41
msgid "Functions and Definitions"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:45
msgid "A function is defined by the `function` keyword."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:46
msgid ""
"A file can contain multiple functions, but typically the primary function "
"shares the file name."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:47
msgid ""
"Anonymous functions (e.g., `@(x) sum(x.^2)`) are used for short inline "
"calculations."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:51
msgid ""
"Functions are defined using the def keyword, typically within a single `.py`"
" file or module."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:52
msgid ""
"Classes are used to encapsulate data and methods in an object-oriented "
"manner."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:53
msgid ""
"Lambdas serve as short anonymous functions (`lambda x: x.sum()`), but multi-"
"line lambdas are not allowed."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:55
msgid "Control Flow"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:59
msgid "Uses for `i = 1:N` ... `end` loops with 1-based indexing."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:60
msgid "Conditional statements like `if`, `elseif`, and `else`."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:64
msgid "Uses `for i in range(N):` with 0-based indexing."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:65
msgid ""
"Indentation is significant for scoping in loops and conditionals (no `end` "
"keyword)."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:67
msgid "Printing and Comments"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:71
msgid "Uses `fprintf()` functions for formatted output."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:72
msgid "Uses `%` for single-line comments."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:76
msgid "Uses `print` with f-strings for formatted output."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:77
msgid "Uses `#` for single-line comments."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:79
msgid "Multi-line Coding"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:83
msgid ""
"Uses `...` at the trailing of a line to indicate that the next line shall be"
" treated as the same line as."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:84
msgid "Python"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:86
msgid ""
"Uses `\\` at the trailing of a line to indicate that the next line shall be "
"treated as the same line as."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:87
msgid ""
"If multiple lines are inside parentheses, no specific trailing symbol is "
"required."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:89
msgid "How to Write Evolutionary Computation Algorithm via EvoX?"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:93
msgid "A MATLAB code example for PSO algorithm is as follows:"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:154
msgid ""
"In MATLAB, function `init_pso()` initializes the algorithm, and a separate "
"function `step_pso()` performs an iteration step and the main function "
"`example_pso()` orchestrates the loop."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:156
msgid "EvoX"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:157
msgid "In EvoX, you can construct the PSO algorithm in following way:"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:159
msgid ""
"First, it is recommended to import necessary modules and functions from EvoX"
" and PyTorch."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:169
msgid ""
"Then, you can transform the MATLAB code to the python code correspondingly "
"according to the \"Syntax Differences\" section."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:238
msgid ""
"It is worth noting that we use `[]` with `;` and `,` in MATLAB to "
"concatenate matrices and vectors along specific dimension; however, in EvoX,"
" the `torch.cat` must be invoked with argument `dim` to indicate the "
"concatenation dimension. Moreover, in PyTorch, tensors to be concatenated "
"must have the same number of dimensions; therefore, additional "
"`XXX.unsqueeze(0)` is applied to add a new dimension of length 1 before the "
"first dimension."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:242
msgid ""
"In EvoX, the PSO logic is encapsulated within a class that inherits from "
"`Algorithm`. This object-oriented design simplifies state management and "
"iteration, and introduces following advantages:"
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:243
msgid ""
"Inherited `evaluate()` method   You can simply call "
"`self.evaluate(self.population)` to compute fitness values, rather than "
"manually passing your objective function each iteration."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:245
msgid ""
"Built-In Workflow Integration   When you register your PSO class with a "
"workflow `StdWorkflow`, it handles iterative calls to "
"[`step()`](#StdWorkflow.step) on your behalf."
msgstr ""

#: ../../source/guide/developer/4-transfer-from-matlab.md:248
msgid ""
"By extending `Algorithm`, `__init__()` sets up all major PSO components "
"(population, velocity, local/global best, etc.) in a standard Python class "
"constructor."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:10002
#, fuzzy
msgid "Deploy HPO with Custom Algorithms"
msgstr "2个CSO算法协同演化。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:10004
msgid ""
"In this chapter, we will focus on deploying HPO with custom algorithms, "
"emphasizing the details rather than the overall workflow. A brief "
"introduction to HPO deployment is provided in the previous chapter, "
"[Efficient HPO with EvoX](#/guide/user/3-hpo), and prior reading is highly "
"recommended."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20002
msgid "Making Algorithms Parallelizable"
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20004
msgid ""
"Since we need to transform the inner algorithm into the problem, it's "
"crucial that the inner algorithm is parallelizable. Therefore, some "
"modifications to the algorithm may be necessary."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20006
msgid ""
"To ensure the function is JIT-compilable, it must meet the conditions "
"outlined in [JIT components](#/guide/developer/2-jit-able). In addition to "
"these requirements, the algorithm must also satisfy the following two "
"constraints:"
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20008
msgid ""
"The algorithm should have no methods with in-place operations on the "
"attributes of the algorithm itself."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20025
msgid "The code logic does not rely on python control flow."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20058
msgid ""
"In EvoX, we can easily make the algorithm parallelizable by the "
"[`@trace_impl`](#trace_impl) decorator."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20060
msgid ""
"The parameter of this decorator is a non-parallelizable function, and the "
"decorated function is a rewrite of the original function. Detailed "
"introduction of [`@trace_impl`](#trace_impl) can be found in [JIT "
"Components](#/guide/developer/2-jit-able)."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20062
msgid ""
"Under this mechanism, we can retain the original function for use outside "
"HPO tasks while enabling efficient computation within HPO tasks. Moreover, "
"this modification is highly convenient."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30002
msgid "Utilizing the HPOMonitor"
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30004
msgid ""
"In the HPO task, we should use the [`HPOMonitor`](#HPOMonitor) to track the "
"metrics of each inner algorithm. The [`HPOMonitor`](#HPOMonitor) adds only "
"one method, `tell_fitness`, compared to the standard [`monitor`](#Monitor). "
"This addition is designed to offer greater flexibility in evaluating "
"metrics, as HPO tasks often involve multi-dimensional and complex metrics."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30006
msgid ""
"Users only need to create a subclass of [`HPOMonitor`](#HPOMonitor) and "
"override the `tell_fitness` method to define custom evaluation metrics."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30008
msgid ""
"We also provide a simple [`HPOFitnessMonitor`](#HPOFitnessMonitor), which "
"supports calculating the 'IGD' and 'HV' metrics for multi-objective "
"problems, and the minimum value for single-objective problems."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:40002
#: ../../source/guide/user/3-hpo.ipynb:50002
#, fuzzy
msgid "A simple example"
msgstr "代码样例"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:40004
msgid ""
"Here, we'll demonstrate a simple example of how to use HPO with EvoX. We "
"will use the [`PSO`](#PSO) algorithm to search for the optimal hyper-"
"parameters of a basic algorithm to solve the sphere problem."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:40006
msgid "First, let's import the necessary modules."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:60002
msgid ""
"Next, we define an simple sphere problem. Note that this has no difference "
"from the common [`problems`](#evox.problems)."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:80002
msgid ""
"Next, we define the algorithm. The original `step` function is non-"
"parallelizable, so we rewrite it using the [`@trace_impl`](#trace_impl) "
"decorator to make it parallelizable. Specifically, we modify in-place "
"operations and adjust the Python control flow."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:100002
msgid ""
"To handle the Python control flow, we use [`TracingCond`](#TracingCond), "
"[`TracingWhile`](#TracingWhile) and [`TracingSwitch`](#TracingSwitch). "
"Since, in tracing mode, variables outside the method may be incorrectly "
"interpreted as static variables, we need to use state to track them. A "
"detailed introduction to [`TracingCond`](#TracingCond), "
"[`TracingWhile`](#TracingWhile) and [`TracingSwitch`](#TracingSwitch) can be"
" found in [JIT Components](#/guide/developer/2-jit-able). Below, we provide "
"two equivalent implementations for the `trace_step` method."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:100043
msgid ""
"Next, we can use the [`StdWorkflow`](#StdWorkflow) to wrap the "
"[`problem`](#evox.problems), [`algorithm`](#evox.algorithms) and "
"[`monitor`](#Monitor). Then we use the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) to transform the "
"[`StdWorkflow`](#StdWorkflow) to HPO problem."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:120002
msgid ""
"We can test whether the [`HPOProblemWrapper`](#HPOProblemWrapper) correctly "
"recognizes the hyper-parameters we defined. Since we have made no "
"modifications to the hyper-parameters for the 7 instances, they should be "
"identical across all instances."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:140002
msgid ""
"We can also specify our own set of hyperparameter values. Note that the "
"number of hyperparameter sets must match the number of instances in the "
"[`HPOProblemWrapper`](#HPOProblemWrapper). The custom hyper-parameters "
"should be provided as a dictionary whose values are wrapped in the "
"[`Parameter`](#Parameter)."
msgstr ""

#: ../../source/guide/developer/custom_hpo_prob.ipynb:160002
msgid ""
"Now, we use the [`PSO`](#PSO) algorithm to optimize the hyper-parameters of "
"`ExampleAlgorithm`. Note that the population size of the [`PSO`](#PSO) must "
"match the number of instances; otherwise, unexpected errors may occur. In "
"this case, we need to transform the solution in the outer workflow, as the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) requires a dictionary as input."
msgstr ""

#: ../../source/guide/developer/environment.md:1
#, fuzzy
msgid "Develop environment"
msgstr "环境名。"

#: ../../source/guide/developer/environment.md:3
msgid "Clone the repository and install it in editable mode (recommended)"
msgstr ""

#: ../../source/guide/developer/environment.md:11
msgid "Nix"
msgstr ""

#: ../../source/guide/developer/environment.md:13
msgid "Enable the Nix environment by running the following command:"
msgstr ""

#: ../../source/guide/developer/environment.md:17
msgid ""
"This will create a shell with all the necessary dependencies and a `.venv` "
"directory with the Python environment."
msgstr ""

#: ../../source/guide/developer/environment.md:19
#, fuzzy
msgid "Style guide"
msgstr "用户指引"

#: ../../source/guide/developer/environment.md:21
msgid "EvoX's has the following style guide:"
msgstr ""

#: ../../source/guide/developer/environment.md:22
msgid ""
"Make sure to use [ruff](https://docs.astral.sh/ruff/) to lint your code."
msgstr ""

#: ../../source/guide/developer/environment.md:23
msgid "Make sure there are no trailing whitespaces."
msgstr ""

#: ../../source/guide/developer/environment.md:25
msgid "Pre-commit"
msgstr ""

#: ../../source/guide/developer/environment.md:27
msgid ""
"We recommend using [pre-commit](https://pre-commit.com/) to enforce the "
"style guide. After installing pre-commit, run the following command to "
"install the hooks in your local repository:"
msgstr ""

#: ../../source/guide/developer/environment.md:33
msgid "Run Unit Test"
msgstr ""

#: ../../source/guide/developer/environment.md:35
msgid ""
"prepare the test environment by installing the required packages (e.g., "
"`torch`) in your Python environment"
msgstr ""

#: ../../source/guide/developer/environment.md:36
msgid "run unittest:"
msgstr ""

#: ../../source/guide/developer/index.md:1
msgid "Developer Guide"
msgstr "开发者指引"

#: ../../source/guide/experimental/index.md:1
#, fuzzy
msgid "Experimental Features"
msgstr "关键特征"

#: ../../source/guide/install/index.md:1
msgid "Installation Guide"
msgstr "安装教程"

#: ../../source/guide/install/install.md:1
msgid "EvoX Installation Guide"
msgstr "EvoX安装教程"

#: ../../source/guide/install/install.md:3
msgid "Install EvoX"
msgstr "安装EvoX"

#: ../../source/guide/install/install.md:5
#, fuzzy
msgid "EvoX is available at PyPI and can be installed via:"
msgstr "EvoX 可以在 PyPI 上找到，可以通过以下方式安装："

#: ../../source/guide/install/install.md:16
#, fuzzy
msgid ""
"You can also assign extra options during the installation, currently "
"available extras are `gymnasium`, `neuroevolution`, `envpool`, "
"`distributed`, and `full`. For example, to install EvoX with all features, "
"run the following command:"
msgstr ""
"EvoX 提供多种可选特性，包括 "
"`gymnasium`、`neuroevolution`、`envpool`、`distributed`和`full`（包含所有特性）。例如，要安装包含所有特性的"
" EvoX，您可以使用以下命令："

#: ../../source/guide/install/install.md:22
#, fuzzy
msgid "Install PyTorch with accelerator support"
msgstr "安装支持GPU加速的JAX"

#: ../../source/guide/install/install.md:24
#, fuzzy
msgid ""
"`evox` relies on `torch` to provide hardware acceleration. The overall "
"architecture of these Python packages looks like this:"
msgstr "`EvoX`依赖于`JAX`来提供硬件加速的能力。这些Python包的整体架构如下："

#: ../../source/guide/install/install.md:42
msgid ""
"To summarize, whether `evox` has CPU support or Nvidia GPU support (CUDA) or"
" AMD GPU support (ROCm) depends on the installed PyTorch version. Please "
"refer to the PyTorch official website for more installation help: "
"[`torch`](https://pytorch.org/)"
msgstr ""

#: ../../source/guide/install/install.md:45
msgid "Nvidia GPU support on Windows"
msgstr ""

#: ../../source/guide/install/install.md:47
msgid ""
"EvoX support GPU acceleration through PyTorch. There are two ways to use "
"PyTorch with GPU acceleration on Windows:"
msgstr ""

#: ../../source/guide/install/install.md:50
msgid ""
"Using WSL 2 (Windows Subsystem for Linux) and install PyTorch on the Linux "
"side."
msgstr ""

#: ../../source/guide/install/install.md:51
msgid "Directly install PyTorch on Windows."
msgstr ""

#: ../../source/guide/install/install.md:53
msgid ""
"We also provide a [one-click script](https://github.com/EMI-"
"Group/evox/blob/main/win-install.bat) for fast deployment on fresh installed"
" windows 10/11 64bit with Nvidia GPUs. The script will not use WSL 2 and "
"will install the native Pytorch version on Windows. It will automatically "
"install related applications like VSCode, Git and MiniForge3."
msgstr ""

#: ../../source/guide/install/install.md:55
#, fuzzy
msgid "Windows WSL 2 (optional)"
msgstr "Windows WSL 2"

#: ../../source/guide/install/install.md:56
#, fuzzy
msgid ""
"Ensure the [Nvidia "
"driver](https://www.nvidia.com/Download/index.aspx?lang=en-us) is properly "
"installed first. Otherwise the script will fall back to cpu mode."
msgstr ""
"下载 [最新的NVIDIA Windows "
"GPU驱动](https://www.nvidia.com/Download/index.aspx?lang=en-us)，并安装."

#: ../../source/guide/install/install.md:57
msgid ""
"When running the script, ensure a stable network (accessible to `github.com`"
" etc.)."
msgstr ""

#: ../../source/guide/install/install.md:58
msgid ""
"If the script is failed due to network failure, close and reopen it to "
"continue the installation."
msgstr ""

#: ../../source/guide/install/install.md:61
#, fuzzy
msgid ""
"Download the [latest NVIDIA Windows GPU "
"Driver](https://www.nvidia.com/Download/index.aspx?lang=en-us), and install "
"it. Then your WSL 2 will support Nvidia GPUs in its Linux environments."
msgstr ""
"下载 [最新的NVIDIA Windows "
"GPU驱动](https://www.nvidia.com/Download/index.aspx?lang=en-us)，并安装."

#: ../../source/guide/install/install.md:64
#, fuzzy
msgid ""
"Do **NOT** install any NVIDIA GPU Linux driver within WSL 2. Install the "
"driver on the Windows side."
msgstr ""
"请**不要**在 WSL 2 内部安装任何 NVIDIA GPU Linux 驱动程序。GPU 驱动程序属于内核空间程序，应安装在 Windows "
"主机系统上。"

#: ../../source/guide/install/install.md:68
msgid ""
"NVIDIA has a detailed [CUDA on WSL User "
"Guide](https://docs.nvidia.com/cuda/wsl-user-guide/index.html)"
msgstr ""
"NVIDIA官方有一个详细的教程 [CUDA on WSL User Guide](https://docs.nvidia.com/cuda/wsl-"
"user-guide/index.html)"

#: ../../source/guide/install/install.md:71
msgid "AMD GPU (ROCm) support"
msgstr ""

#: ../../source/guide/install/install.md:73
msgid ""
"We recommend using a Docker container from "
"[`rocm/pytorch`](https://hub.docker.com/r/rocm/pytorch)."
msgstr ""

#: ../../source/guide/install/install.md:79
#, fuzzy
msgid "Verify the installation"
msgstr "验证安装是否正确"

#: ../../source/guide/install/install.md:81
msgid "Open a Python terminal, and run the following:"
msgstr "打开 Python 终端，并运行以下命令："

#: ../../source/guide/install/python.md:1
msgid "Python Installation Guide"
msgstr "Python安装教程"

#: ../../source/guide/install/python.md:3
msgid ""
"EvoX is written in Python, so you will need to have Python installed on your"
" system. EvoX support Python 3.9 and above, and we recommend using the "
"latest version of Python."
msgstr ""
"EvoX是用Python写的，所以你需要先在你的系统上安装Python。EvoX支持Python 3.9及以上，同时我们推荐使用最新版的Python。"

#: ../../source/guide/install/python.md:6
msgid "Windows Version"
msgstr "Windows 版本"

#: ../../source/guide/install/python.md:8
msgid ""
"Go to [Download Python](https://www.python.org/downloads/) and download the "
"latest version of Python."
msgstr "访问[Download Python](https://www.python.org/downloads/) 来下载最新版的Python。"

#: ../../source/guide/install/python.md:11
msgid ""
"Make sure to check the box that says \"Add Python to PATH\" during the "
"installation process."
msgstr "请确保在安装的过程中勾选\"Add Python to PATH\"这个选项。"

#: ../../source/guide/install/python.md:14
msgid "Linux Version"
msgstr "Linux 版本"

#: ../../source/guide/install/python.md:16
msgid ""
"Different Linux distributions have different ways to install Python. It "
"depends on the package manager of your distribution. Here are some examples:"
msgstr "不同的Linux发行版有不同的安装Python的方式。这取决于发行版所用的包管理器。这里有些例子："

#: ../../source/guide/install/python.md:19
msgid "Debian/Ubuntu: `apt`"
msgstr ""

#: ../../source/guide/install/python.md:20
msgid "Archlinux: `pacman`"
msgstr ""

#: ../../source/guide/install/python.md:21
msgid "Fedora: `dnf`"
msgstr ""

#: ../../source/guide/user/1-start.ipynb:10002
msgid "Quick Start"
msgstr "快速开始"

#: ../../source/guide/user/1-start.ipynb:10004
msgid ""
"In this notebook, we will help you be familiar with EvoX through an simple "
"example."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:10006
msgid "To start with, make sure you have already installed the EvoX."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:40002
msgid "The basic running process in EvoX"
msgstr ""

#: ../../source/guide/user/1-start.ipynb:40004
msgid ""
"As a distributed GPU-accelerated framework for scalable evolutionary "
"computation, EvoX can be used to do many kinds computations, so we say "
"\"EvoX is all you need\". Though many kinds of computations are different "
"more or less, in EvoX we standardize the basic running process:"
msgstr ""

#: ../../source/guide/user/1-start.ipynb:40013
msgid ""
"EvoX offers a comprehensive suite of 50+ Evolutionary Algorithms (EAs) and a"
" wide range of 100+ Benchmark Problems/Environments, all benefiting from "
"distributed GPU-acceleration."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:40015
#, fuzzy
msgid ""
"For more details, please refer to our API documentation: [List of "
"Algorithms](#evox.algorithms) and [List of Problems](#evox.problems)."
msgstr ""
"有关更详细的列表，请参阅我们的 API "
"文档。[算法列表](https://evox.readthedocs.io/en/latest/api/algorithms/index.html) 和"
" [问题列表](https://evox.readthedocs.io/en/latest/api/problems/index.html)。"

#: ../../source/guide/user/1-start.ipynb:40017
msgid ""
"Here we will create a [PSO](#evox.algorithms.pso_variants.pso) algorithm and"
" an [Ackley](#evox.problems.numerical.basic.Ackley) function problem."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:60002
msgid ""
"Notice the algorithm and problem themselves do not contain the monitoring of"
" the steps, so we will not get any feed back only depending on them. It "
"turns out that we need a **monitor**."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:60006
#, fuzzy
msgid ""
"[`Monitor`](#evox.workflows.eval_monitor.EvalMonitor) is a standard class in"
" EvoX to monitor the intermediate values inside a optimization process. "
"Information like fitness or population can be easily obtained by the "
"monitor."
msgstr "监视器是监控优化过程中中间值的标准方法。像适应度或种群这样的信息可以通过监视器轻松获得。"

#: ../../source/guide/user/1-start.ipynb:60008
msgid "Doing is better than saying, so let us create a “Evaluation monitor”:"
msgstr ""

#: ../../source/guide/user/1-start.ipynb:80004
msgid ""
"A **workflow** outlines the series of steps required to accomplish a task or"
" project. In EvoX, a workflow represents the overall process of evolutionary"
" computation, putting the algorithm, problem and monitor together."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:80006
msgid ""
"If we want to run the algorithm to solve the problem with a monitor, we need"
" to create a workflow of the [`Workflow`](#evox.core.components.Workflow) "
"class."
msgstr ""

#: ../../source/guide/user/1-start.ipynb:100004
msgid "Now, we can run the workflow:"
msgstr ""

#: ../../source/guide/user/1-start.ipynb:120002
msgid ""
"Congretulations if you can reproduce the Quick Start demo! Hope you enjoy "
"the EvoX!"
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:10002
#, fuzzy
msgid "Extended Applications"
msgstr "处理扩展应用"

#: ../../source/guide/user/2-problems.ipynb:10004
msgid ""
"EvoX facilitates efficient exploration of complex optimization landscapes, "
"effective tackling of black-box optimization challenges, and deep dives into"
" neuroevolution with Brax. Thus, it is talented in extended applications.  "
"Here we will show an example of Neuroevolution Tasks using EvoX and Brax."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:40002
#, fuzzy
msgid "Use EvoX to solve Neuroevolution Tasks"
msgstr "神经演化任务"

#: ../../source/guide/user/2-problems.ipynb:40003
msgid ""
"Neuroevolution is an optimization method that combines neural networks with "
"evolutionary algorithms to evolve the structure and parameters of neural "
"networks. By simulating natural selection and genetic mechanisms, "
"Neuroevolution aims to optimize neural network architectures and weights, "
"addressing complex problems such as game AI, robotic control, and more."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:40005
msgid ""
"In our example of neuroevolution tasks, Brax is needed. So it is recommended"
" to install Brax if you want to replicate this example."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:50006
msgid ""
"Here we will demonstrate a \"hopper\" environment of Brax. For more "
"information, you can browse the [Github of "
"Brax](https://github.com/google/brax)."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:80004
msgid "Through the `SimpleMLP` class, we can initiate a MLP model."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:100002
msgid ""
"We can compute the total number of the model parameters, and check if the "
"model id initialized correctly. If everything goes well, we will see the "
"total number is 63."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:120002
msgid ""
"We can also test the dimoension of the inputs and outputs. If everything "
"goes well, 11 inputs will obtain 3 outputs."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:140002
#, fuzzy
msgid ""
"If we check the weights data of this network, we will see the data is in the"
" dictionary form, and many EC algorithms cannot directly work with such a "
"format:"
msgstr "然而，如果我们检查这个网络的权重，我们会发现它是一组参数集，而进化计算（EC）算法无法直接处理这种格式的数据。"

#: ../../source/guide/user/2-problems.ipynb:160002
#, fuzzy
msgid ""
"Fortunately, EvoX provides some useful utilities to help us bridge the gap, "
"and in this case, we have "
"[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector) class"
" to help us convert a tree-like struct into a vector and back."
msgstr ""
"幸运的是，EvoX提供了一些有用的工具来帮助我们弥合这一差距，在这种情况下，我们有`TreeAndVector`来帮助我们将树状结构转换成向量，然后再转换回来。"

#: ../../source/guide/user/2-problems.ipynb:160008
msgid ""
"[`to_vector`](#evox.utils.parameters_and_vector.ParamsAndVector.to_vector) "
"can convert a parameters dictionary to a vector."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:160009
msgid ""
"[`to_params`](#evox.utils.parameters_and_vector.ParamsAndVector.to_params) "
"can convert a vector back to a parameters dictionary."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:160011
msgid "There are also batched version conversion."
msgstr "还有批量版本的转换。"

#: ../../source/guide/user/2-problems.ipynb:160013
msgid ""
"[`batched_to_vector`](#evox.utils.parameters_and_vector.ParamsAndVector.batched_to_vector)"
" can convert a batched parameters dictionary to a batch of vectors."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:160014
msgid ""
"[`batched_to_params`](#evox.utils.parameters_and_vector.ParamsAndVector.batched_to_params)"
" can convert a batch of vectors back to a batched parameters dictionary."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:180005
msgid ""
"For some algorithms designed for neuroevolution, that is, algorithms that "
"directly accept the batched parameters dictionary, adapter is not necessary "
"and should be removed to improve performance."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:180012
msgid ""
"We still initiate a [PSO](#evox.algorithms.pso_variants.pso.PSO) algorithm, "
"and the problem is a [Brax "
"problem](#evox.problems.neuroevolution.brax.BraxProblem) in \"hopper\" "
"environment."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:200003
#, fuzzy
msgid "`max_episode_length` is the maximum number of steps for each episode."
msgstr "运行的最大的时间步的数量。"

#: ../../source/guide/user/2-problems.ipynb:200005
#, fuzzy
msgid "`num_episodes` is the number of episodes to run for each evaluation."
msgstr "用于评估每个个体的幕数量。"

#: ../../source/guide/user/2-problems.ipynb:240007
#, fuzzy
msgid ""
"The following block will take around 1 minute to run. The time may vary "
"depending on your hardware."
msgstr "以下这段代码将需要大概10分钟来运行。具体的运行时间取决于您的硬件。"

#: ../../source/guide/user/2-problems.ipynb:260003
msgid ""
"The PSO wasn’t specialized for this type of tasks, so its performance "
"limitations here are expected. Here we just show an example."
msgstr ""

#: ../../source/guide/user/2-problems.ipynb:260006
msgid ""
"Hope you can use a quantity of more effective algorithms in EvoX and enjoy "
"your time!"
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:10002
#, fuzzy
msgid "Efficient HPO with EvoX"
msgstr "用EvoX解决Pong问题"

#: ../../source/guide/user/3-hpo.ipynb:10004
msgid ""
"In this chapter, we will explore how to use EvoX for hyperparameter "
"optimization (HPO)."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:10006
msgid ""
"HPO plays a crucial role in many machine learning tasks but is often "
"overlooked due to its high computational cost, which can sometimes take days"
" to process, as well as the challenges involved in deployment."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:10008
msgid ""
"With EvoX, we can simplify HPO deployment using the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) and achieve efficient computation "
"by leveraging the `vmap` method and GPU acceleration."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:20002
msgid "Transforming Workflow into Problem"
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:20004
#, fuzzy
msgid "HPO structure"
msgstr "文档的结构"

#: ../../source/guide/user/3-hpo.ipynb:20010
msgid ""
"The key to deploying HPO with EvoX is to transform the "
"[`workflows`](#evox.workflows) into [`problems`](#evox.problems) using the "
"[`HPOProblemWrapper`](#HPOProblemWrapper). Once transformed, we can treat "
"the [`workflows`](#evox.workflows) as standard [`problems`](#evox.problems)."
" The input to the 'HPO problem' consists of the hyper-parameters, and the "
"output is the evaluation metrics."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:30002
msgid "The Key Component -- `HPOProblemWrapper`"
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:30004
msgid ""
"To ensure the [`HPOProblemWrapper`](#HPOProblemWrapper) recognizes the "
"hyper-parameters, we need to wrap them using [`Parameter`](#Parameter). With"
" this straightforward step, the hyper-parameters will be automatically "
"identified."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:40002
msgid "Utilizing the `HPOFitnessMonitor`"
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:40004
msgid ""
"We provide an [`HPOFitnessMonitor`](#HPOFitnessMonitor) that supports "
"calculating 'IGD' and 'HV' metrics for multi-objective problems, as well as "
"the minimum value for single-objective problems."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:40006
msgid ""
"It is important to note that the [`HPOFitnessMonitor`](#HPOFitnessMonitor) "
"is a basic monitor designed for HPO problems. You can also create your own "
"customized monitor flexibly using the approach outlined in [Deploy HPO with "
"Custom Algorithms](#/guide/developer/custom_hpo_prob)."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:50004
msgid ""
"Here, we'll demonstrate a simple example of using EvoX for HPO. "
"Specifically, we will use the [PSO](#PSO) algorithm to optimize the hyper-"
"parameters of the [PSO](#PSO) algorithm for solving the sphere problem."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:50006
msgid ""
"Please note that this chapter provides only a brief overview of HPO "
"deployment. For a more detailed guide, refer to [Deploy HPO with Custom "
"Algorithms](#/guide/developer/custom_hpo_prob)."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:50008
msgid "To start, let's import the necessary modules."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:70002
msgid "Next, we define a simple Sphere problem."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:90002
msgid ""
"Next, we can use the [`StdWorkflow`](#StdWorkflow) to wrap the "
"[`problem`](#evox.problems), [`algorithm`](#evox.algorithms) and "
"[`monitor`](#Monitor). Then we use the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) to transform the "
"[`StdWorkflow`](#StdWorkflow) to an HPO problem."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:110002
msgid "The [`HPOProblemWrapper`](#HPOProblemWrapper) takes 4 arguments:"
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:110003
#, fuzzy
msgid ""
"`iterations`: The number of iterations to be executed in the optimization "
"process."
msgstr "注意：外部迭代次数需要设置为最大代数（Maximum Generation）的两倍加一。"

#: ../../source/guide/user/3-hpo.ipynb:110004
#, fuzzy
msgid ""
"`num_instances`: The number of instances to be executed in parallel in the "
"optimization process."
msgstr "注意：外部迭代次数需要设置为最大代数（Maximum Generation）的两倍加一。"

#: ../../source/guide/user/3-hpo.ipynb:110005
msgid ""
"`workflow`: The workflow to be used in the optimization process. Must be "
"wrapped by [`jit_class`](#jit_class)."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:110006
msgid ""
"`copy_init_state`: Whether to copy the initial state of the workflow for "
"each evaluation. Defaults to `True`. If your workflow contains operations "
"that IN-PLACE modify the tensor(s) in initial state, this should be set to "
"`True`. Otherwise, you can set it to `False` to save memory."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:110008
msgid ""
"We can verify whether the [`HPOProblemWrapper`](#HPOProblemWrapper) "
"correctly recognizes the hyper-parameters we define. Since no modifications "
"are made to the hyper-parameters across the 5 instances, they should remain "
"identical for all instances."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:130002
msgid ""
"We can also define a custom set of hyperparameter values. It is important to"
" ensure that the number of hyperparameter sets matches the number of "
"instances in the [`HPOProblemWrapper`](#HPOProblemWrapper). Additionally, "
"custom hyper-parameters must be provided as a dictionary whose values are "
"wrapped using the [`Parameter`](#Parameter)."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:150002
msgid ""
"Now, we use the [PSO](#PSO) algorithm to optimize the hyperparameters of the"
" [PSO](#PSO) algorithm."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:150004
msgid ""
"It is important to ensure that the population size of the [PSO](#PSO) "
"matches the number of instances; otherwise, unexpected errors may occur."
msgstr ""

#: ../../source/guide/user/3-hpo.ipynb:150006
msgid ""
"Additionally, the solution needs to be transformed in the outer workflow, as"
" the [`HPOProblemWrapper`](#HPOProblemWrapper) requires the input to be in "
"the form of a dictionary."
msgstr ""

#: ../../source/guide/user/index.md:1 ../../source/index.md:4
msgid "User Guide"
msgstr "用户指引"

#: ../../source/index.md:22 ../../source/miscellaneous/index.md:1
msgid "Miscellaneous"
msgstr "杂项"

#: ../../source/index.md:22
msgid "Additional Resources"
msgstr "补充资源"

#: ../../source/index.md:1
msgid "Welcome to EvoX's documentation!"
msgstr "欢迎来到EvoX的文档！"

#: ../../source/index.md:31
msgid ""
"[[English Version]](https://evox.readthedocs.io/en/latest/)   "
"[[中文版本]](https://evox.readthedocs.io/zh/latest/)"
msgstr ""
"[[English Version]](https://evox.readthedocs.io/en/latest/)   "
"[[中文版本]](https://evox.readthedocs.io/zh/latest/)"

#: ../../source/index.md:33
msgid ""
"EvoX is a distributed GPU-accelerated framework for scalable evolutionary "
"computation."
msgstr "EvoX是一个可以对大规模演化计算进行分布式GPU加速的框架。"

#: ../../source/index.md:37
msgid "Key Features"
msgstr "关键特征"

#: ../../source/index.md:39
msgid "🚀 **Fast Performance**:"
msgstr "🚀 **超高性能**："

#: ../../source/index.md:40
msgid ""
"Experience **GPU-Accelerated** optimization, achieving speeds over 100x "
"faster than traditional methods."
msgstr "体验**GPU 加速**的优化，速度比传统方法快百倍以上。"

#: ../../source/index.md:41
#, fuzzy
msgid ""
"Leverage the power of Distributed Workflows for even more rapid "
"optimization."
msgstr ""
"利用 {class}`分布式工作流 <evox.workflows.RayDistributedWorkflow>` 的强大功能，实现更快速的优化。"

#: ../../source/index.md:43
msgid "🌐 **Versatile Optimization Suite**:"
msgstr "🌐 **多功能优化套件**:"

#: ../../source/index.md:44
#, fuzzy
msgid ""
"Cater to all your needs with both [Single-objective and Multi-"
"objectiv](#algorithms) optimization capabilities."
msgstr ""
"满足您所有需求，包括 {doc}`单目标 <api/algorithms/so/index>` 和 {doc}`多目标 "
"<api/algorithms/mo/index>`优化功能。"

#: ../../source/index.md:45
#, fuzzy
msgid ""
"Dive into a comprehensive library of [Benchmark Problems](#problems), "
"ensuring robust testing and evaluation."
msgstr "深入了解全面的{doc}`基准测试问题库 <api/problems/numerical/index>`，确保进行稳健的测试和评估。"

#: ../../source/index.md:46
#, fuzzy
msgid ""
"Explore the frontier of AI with extensive tools for "
"[Neuroevolution](#neuroevolution) tasks."
msgstr ""
"探索人工智能前沿领域，利用广泛的工具进行 {doc}`神经演化 <api/problems/neuroevolution/index>` 任务。"

#: ../../source/index.md:48
msgid "🛠️ **Designed for Simplicity**:"
msgstr "🛠️ **简易性设计**:"

#: ../../source/index.md:49
msgid ""
"Embrace the elegance of **Functional Programming**, simplifying complex "
"algorithmic compositions."
msgstr "拥抱优雅的**函数式编程**，化繁为简，轻松构建复杂算法。"

#: ../../source/index.md:50
msgid ""
"Benefit from **Hierarchical State Management**, ensuring modular and clean "
"programming."
msgstr "得益于**层次化状态管理**，体验模块化和清爽的编程体验。"

#: ../../source/index.md:53
msgid "<br></br>"
msgstr "<br></br>"

#: ../../source/index.md:60
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-desktop-download\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M11.25 9.331V.75a.75.75 0 0 1 1.5 0v8.58l1.949-2.11A.75.75 0 1 1 15.8 "
"8.237l-3.25 3.52a.75.75 0 0 1-1.102 0l-3.25-3.52A.75.75 0 1 1 9.3 7.22l1.949"
" 2.111Z\"></path><path d=\"M2.5 3.75v11.5c0 .138.112.25.25.25h18.5a.25.25 0 "
"0 0 .25-.25V3.75a.25.25 0 0 0-.25-.25h-5.5a.75.75 0 0 1 0-1.5h5.5c.966 0 "
"1.75.784 1.75 1.75v11.5A1.75 1.75 0 0 1 21.25 17h-6.204c.171 1.375.805 2.652"
" 1.769 3.757A.752.752 0 0 1 16.25 22h-8.5a.75.75 0 0 1-.566-1.243c.965-1.105"
" 1.599-2.382 1.77-3.757H2.75A1.75 1.75 0 0 1 1 15.25V3.75C1 2.784 1.784 2 "
"2.75 2h5.5a.75.75 0 0 1 0 1.5h-5.5a.25.25 0 0 0-.25.25ZM10.463 17c-.126 "
"1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5Z\"></path></svg> Installation "
"Guide"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-desktop-download\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M11.25 9.331V.75a.75.75 0 0 1 1.5 0v8.58l1.949-2.11A.75.75 0 1 1 15.8 "
"8.237l-3.25 3.52a.75.75 0 0 1-1.102 0l-3.25-3.52A.75.75 0 1 1 9.3 7.22l1.949"
" 2.111Z\"></path><path d=\"M2.5 3.75v11.5c0 .138.112.25.25.25h18.5a.25.25 0 "
"0 0 .25-.25V3.75a.25.25 0 0 0-.25-.25h-5.5a.75.75 0 0 1 0-1.5h5.5c.966 0 "
"1.75.784 1.75 1.75v11.5A1.75 1.75 0 0 1 21.25 17h-6.204c.171 1.375.805 2.652"
" 1.769 3.757A.752.752 0 0 1 16.25 22h-8.5a.75.75 0 0 1-.566-1.243c.965-1.105"
" 1.599-2.382 1.77-3.757H2.75A1.75 1.75 0 0 1 1 15.25V3.75C1 2.784 1.784 2 "
"2.75 2h5.5a.75.75 0 0 1 0 1.5h-5.5a.25.25 0 0 0-.25.25ZM10.463 17c-.126 "
"1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5Z\"></path></svg> 安装教程"

#: ../../source/index.md:66
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path d=\"M3.5 "
"8a5.5 5.5 0 1 1 8.596 4.547 9.005 9.005 0 0 1 5.9 8.18.751.751 0 0 1-1.5.045"
" 7.5 7.5 0 0 0-14.993 0 .75.75 0 0 1-1.499-.044 9.005 9.005 0 0 1 "
"5.9-8.181A5.496 5.496 0 0 1 3.5 8ZM9 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm8.29 "
"4c-.148 0-.292.01-.434.03a.75.75 0 1 1-.212-1.484 4.53 4.53 0 0 1 3.38 8.097"
" 6.69 6.69 0 0 1 3.956 6.107.75.75 0 0 1-1.5 0 5.193 5.193 0 0 "
"0-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0 0 17.29 "
"8Z\"></path></svg> User Guide"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path d=\"M3.5 "
"8a5.5 5.5 0 1 1 8.596 4.547 9.005 9.005 0 0 1 5.9 8.18.751.751 0 0 1-1.5.045"
" 7.5 7.5 0 0 0-14.993 0 .75.75 0 0 1-1.499-.044 9.005 9.005 0 0 1 "
"5.9-8.181A5.496 5.496 0 0 1 3.5 8ZM9 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm8.29 "
"4c-.148 0-.292.01-.434.03a.75.75 0 1 1-.212-1.484 4.53 4.53 0 0 1 3.38 8.097"
" 6.69 6.69 0 0 1 3.956 6.107.75.75 0 0 1-1.5 0 5.193 5.193 0 0 "
"0-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0 0 17.29 "
"8Z\"></path></svg> 用户教程"

#: ../../source/index.md:72
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M12.292 2.06v-.001l11.25 4.75a.749.749 0 0 1 0 1.382L19 10.108V15a.75.75"
" 0 0 1-.11.391h-.001a2.84 2.84 0 0 "
"1-.392.482c-.249.256-.625.58-1.163.896-1.08.638-2.776 1.23-5.334 1.23-.673 "
"0-1.286-.041-1.846-.113a.75.75 0 0 1 .192-1.487c.492.063 1.042.1 1.654.1 "
"2.317 0 3.746-.533 "
"4.572-1.021.31-.178.596-.397.849-.65l.079-.085V10.74l-5.208 2.2a.75.75 0 0 "
"1-.584 0L5.75 10.424v3.17c.502.129.96.391 1.327.758.579.578.923 1.41.923 "
"2.428v4.5a.761.761 0 0 1-.345.634 2.157 2.157 0 0 1-.21.117 3.923 3.923 0 0 "
"1-.52.213A6.121 6.121 0 0 1 5 22.532a6.092 6.092 0 0 1-1.925-.288 4.065 "
"4.065 0 0 1-.52-.213 1.816 1.816 0 0 1-.22-.124.757.757 0 0 "
"1-.335-.624v-4.5c0-1.02.344-1.85.923-2.43a2.904 2.904 0 0 1 "
"1.327-.757V9.793L.458 8.19a.75.75 0 0 1 0-1.38l11.25-4.75a.75.75 0 0 1 .584 "
"0ZM12 11.436 21.322 7.5 12 3.564 2.678 7.5ZM5 15c-.377 "
"0-.745.141-1.017.413-.265.265-.483.7-.483 1.368v4.022c.299.105.797.228 "
"1.5.228s1.201-.123 1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.433 1.433 0"
" 0 0 5 15Z\"></path></svg> Developer Guide"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M12.292 2.06v-.001l11.25 4.75a.749.749 0 0 1 0 1.382L19 10.108V15a.75.75"
" 0 0 1-.11.391h-.001a2.84 2.84 0 0 "
"1-.392.482c-.249.256-.625.58-1.163.896-1.08.638-2.776 1.23-5.334 1.23-.673 "
"0-1.286-.041-1.846-.113a.75.75 0 0 1 .192-1.487c.492.063 1.042.1 1.654.1 "
"2.317 0 3.746-.533 "
"4.572-1.021.31-.178.596-.397.849-.65l.079-.085V10.74l-5.208 2.2a.75.75 0 0 "
"1-.584 0L5.75 10.424v3.17c.502.129.96.391 1.327.758.579.578.923 1.41.923 "
"2.428v4.5a.761.761 0 0 1-.345.634 2.157 2.157 0 0 1-.21.117 3.923 3.923 0 0 "
"1-.52.213A6.121 6.121 0 0 1 5 22.532a6.092 6.092 0 0 1-1.925-.288 4.065 "
"4.065 0 0 1-.52-.213 1.816 1.816 0 0 1-.22-.124.757.757 0 0 "
"1-.335-.624v-4.5c0-1.02.344-1.85.923-2.43a2.904 2.904 0 0 1 "
"1.327-.757V9.793L.458 8.19a.75.75 0 0 1 0-1.38l11.25-4.75a.75.75 0 0 1 .584 "
"0ZM12 11.436 21.322 7.5 12 3.564 2.678 7.5ZM5 15c-.377 "
"0-.745.141-1.017.413-.265.265-.483.7-.483 1.368v4.022c.299.105.797.228 "
"1.5.228s1.201-.123 1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.433 1.433 0"
" 0 0 5 15Z\"></path></svg> 开发者教程"

#: ../../source/index.md:82
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> "
"Algorithms"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> 算法"

#: ../../source/index.md:88
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> "
"Problems"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> 问题"

#: ../../source/index.md:95
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> "
"Metrics"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> 指标"

#: ../../source/miscellaneous/selecting_gpu.md:1
msgid "Selecting GPU / CPU"
msgstr "选择 GPU / CPU"

#: ../../source/miscellaneous/selecting_gpu.md:3
msgid ""
"To run your program on a specific GPU, you can use the "
"`CUDA_VISIBLE_DEVICES` environment variable. For example, to run your "
"program on the second GPU, you can use:"
msgstr ""
"要在特定的 GPU 上运行程序，您可以使用 `CUDA_VISIBLE_DEVICES` 环境变量。例如，要在第二个 GPU 上运行程序，您可以使用："

#: ../../source/miscellaneous/selecting_gpu.md:9
msgid "To run your program on multiple GPUs, you can use:"
msgstr "要在多个GPU上跑你的程序，你可以用："

#: ../../source/miscellaneous/selecting_gpu.md:15
msgid "To disable GPU usage (use CPU), you can use:"
msgstr "如果要禁用GPU（即使用CPU），你可以用："

#~ msgid "EvoX's API"
#~ msgstr "EvoX的API"

#~ msgid "**env_per_worker**"
#~ msgstr ""

#~ msgid "Number of gym environment per worker."
#~ msgstr ""

#~ msgid "**pop_size**"
#~ msgstr ""

#~ msgid ""
#~ "Population size, this argument together with num_workers will be used to "
#~ "determine the sharding strategy."
#~ msgstr ""

#~ msgid ""
#~ "[![Open in Colab](https://colab.research.google.com/assets/colab-"
#~ "badge.svg)](https://colab.research.google.com/github/EMI-"
#~ "Group/evox/blob/main/docs/source/guide/basics/1-start.ipynb)"
#~ msgstr ""

#~ msgid "Open in Colab"
#~ msgstr "在Colab中打开"

#~ msgid ""
#~ "[![Open in Colab](https://colab.research.google.com/assets/colab-"
#~ "badge.svg)](https://colab.research.google.com/github/EMI-"
#~ "Group/evox/blob/main/docs/source/guide/basics/2-problems.ipynb)"
#~ msgstr ""

#~ msgid "EvoX's guide!"
#~ msgstr ""

#~ msgid "API reference"
#~ msgstr ""

#~ msgid "Contents:"
#~ msgstr ""

#~ msgid "Indices and tables"
#~ msgstr ""

#~ msgid "{ref}`genindex`"
#~ msgstr ""

#~ msgid "{ref}`modindex`"
#~ msgstr ""

#~ msgid "{ref}`search`"
#~ msgstr "{ref}`search`"

#~ msgid ""
#~ "A Built-in plot function for visualizing the population of single-objective "
#~ "algorithm. Use plotly internally, so you need to install plotly to use this "
#~ "function."
#~ msgstr "内置的单目标算法种群可视化绘图函数。内部使用plotly库，因此要使用此功能，您需要先安装plotly。"

#~ msgid ""
#~ "If the problem is provided, we will plot the fitness landscape of the "
#~ "problem."
#~ msgstr "如果提供了问题实例，我们将绘制该问题的适应度landscape。"

#~ msgid ""
#~ "pop_transform and fitness_transform are applied at each node, while "
#~ "global_fitness_transform is applied at the main node once per step, so "
#~ "monitor should be passed as global_fitness_transform."
#~ msgstr ""
#~ "pop_transform和fitness_transform在每个节点上分别应用，而global_fitness_transform则在主节点上每一步执行一次。因此，monitor应当作为global_fitness_transform传递。"

#~ msgid "**fitness_transform:**"
#~ msgstr "**fitness_transform:**"

#~ msgid "**global_fitness_transform:**"
#~ msgstr "**global_fitness_transform:**"

#~ msgid "This transform is applied at the main node."
#~ msgstr "这个变换在主节点上应用。"

#~ msgid "**record_pop**"
#~ msgstr "**种群记录**"

#~ msgid "Whether to record the population if monitor is enabled."
#~ msgstr "如果启用了monitor，是否要记录种群数据。"

#~ msgid "**record_time**"
#~ msgstr "**时间记录**"

#~ msgid ""
#~ "Whether to record the time at the end of each generation. Due to its timing "
#~ "nature, record_time requires synchronized functional call. Default to False."
#~ msgstr "是否记录每代结束的时间。由于它的计时性质，record_time需要同步的函数调用。默认为False。"

#~ msgid "Universal Workflow"
#~ msgstr "通用工作流"

#~ msgid "**jit_monitor**"
#~ msgstr "**jit_monitor**"

#~ msgid "If the monitor can be jit compiled by JAX or not. Default to False."
#~ msgstr "监视器是否可以通过JAX进行jit编译。默认为False。"

#~ msgid ""
#~ "Automatically apply cooperative coevolution to any algorithm. The process of"
#~ " cooperative coevolution is vectorized, meaning all sub-populations will "
#~ "evolve at the same time in each generation."
#~ msgstr "将协同演化自动应用于任何算法。协同演化的过程被向量化，意味着在每一代中，所有的子种群将同时进化。"

#~ msgid ""
#~ "Automatically apply cooperative coevolution to any algorithm. The process of"
#~ " cooperative coevolution is not vectorized, meaning all sub-populations will"
#~ " evolve one at a time (round-robin) in each generation."
#~ msgstr "将协同演化自动应用于任何算法。协同演化的过程未被向量化，这意味着在每一代中，所有子种群将逐一（轮流）进行进化。"

#~ msgid "CPSO_S"
#~ msgstr "CPSO_S"

#~ msgid ""
#~ "Cooperative particle swarm optimizer. Implemented using EvoX's built-in "
#~ "coevolution framework. CPSOS essentially a wrapper around PSO and "
#~ "Coevolution."
#~ msgstr ""
#~ "协同粒子群优化器（CPSO）在EvoX库中通过其内置的协同演化框架得以实现，实质上，CPSOS本质上是对PSO（粒子群优化算法）和协同演化的封装。"

#~ msgid "https://ieeexplore.ieee.org/document/1304845"
#~ msgstr "https://ieeexplore.ieee.org/document/1304845"

#~ msgid ""
#~ "will be wrapped with `use_state` decorator. This decorator requires the "
#~ "method have the following signature:"
#~ msgstr "将会用 use_state 装饰器包装。这个装饰器要求方法具有以下签名："

#~ msgid ""
#~ ":::{warning} Currently, for all user-defined private methods, the name of "
#~ "the method should start with `_``. :::"
#~ msgstr ":::{警告} 目前，对于所有用户定义的私有方法，方法名称应该以 _ 开头。 :::"

#~ msgid ""
#~ "To solve is problem, it is common practice to jit-compile low-level "
#~ "components, thus giving high-level components more freedom. In EvoX, we have"
#~ " some general rules on whether a function should be jit-able or not."
#~ msgstr ""
#~ "为了解决这个问题，通常的做法是 JIT 编译低层组件，从而给高层组件更多的自由。在 EvoX 中，我们有一些关于函数是否应该是可 JIT "
#~ "编译的通用规则。"

#~ msgid "Component"
#~ msgstr "组件"

#~ msgid "jit-able"
#~ msgstr "可以被jit编译的"

#~ msgid "`Workflow`"
#~ msgstr "工作流"

#~ msgid "Optional"
#~ msgstr "可选的"

#~ msgid "`Algorithm`"
#~ msgstr "算法"

#~ msgid "Yes"
#~ msgstr "是的"

#~ msgid "`Problem`"
#~ msgstr "问题"

#~ msgid "`Operators`"
#~ msgstr "操作符"

#~ msgid "`Monitor`"
#~ msgstr "监控器"

#~ msgid "No"
#~ msgstr "不是"

#~ msgid ""
#~ "For standard workflow, one can jit compile when not using monitors and "
#~ "working with jit-able problems. But even though the workflow can be "
#~ "compiled, there isn't much performance gain. For problems, it depends on the"
#~ " task."
#~ msgstr ""
#~ "对于标准工作流，当不使用监视器并且处理可 JIT 编译的问题时，可以进行 JIT 编译。但即使工作流可以被编译，性能提升也不大。对于问题，这取决于任务。"

#~ msgid ""
#~ "Many algorithms are expensive in terms of space or time. For example, CMA-ES"
#~ " requires $O(N^2)$ space. Thus, it is costly to run CMA-ES on high-dimension"
#~ " problems. Sep-CMA-ES scales better but sacrifices the performance. That's "
#~ "where the container algorithm comes in. With it, we can easily construct a "
#~ "variant of CMA-ES that uses $O((\\frac{N}{M})^2)$ space, where $M$ is the "
#~ "number of blocks. This variant is a balance between the normal CMA-ES and "
#~ "Sep-CMA-ES."
#~ msgstr ""
#~ "许多算法在空间或时间方面的成本都很高。例如，CMA-ES需要$O(N^2)$的空间。因此，在高维问题上运行CMA-ES的成本很高。Sep-CMA-"
#~ "ES的扩展性更好，但牺牲了性能。这就是容器算法的用武之地。有了它，我们可以轻松构建一个使用$O((\\frac{N}{M})^2)$空间的CMA-"
#~ "ES变体，其中$M$是块的数量。这种变体是普通CMA-ES和Sep-CMA-ES之间的平衡。"

#~ msgid "Working with PyTree"
#~ msgstr "处理 PyTree"

#~ msgid ""
#~ "Usually, algorithms expect the decision variables to be in the form of a "
#~ "1D-vector. PyTrees are tree-like structures that are not directly compatible"
#~ " with normal algorithms. So, there are two solutions out there:"
#~ msgstr "一般来说，算法期望决策变量以一维形式呈现。但是Pytrees是树类结构不能直接与常见的算法兼容。所以这里有两种解决方法："

#~ msgid "Flatten the PyTree to 1D-vector."
#~ msgstr "将Pytree平展成一维向量。"

#~ msgid "Use a specialized algorithm that work with PyTree directly."
#~ msgstr "使用经过特殊化算法来直接处理Pytree。"

#~ msgid ""
#~ "Solution 1 is called `adapter` in EvoX, which is quite simple, but we are "
#~ "not talking about this here. Solution 2 seems more complicated, but the "
#~ "advantage is that the structural information is preserved, meaning the "
#~ "algorithm could see the tree structure and apply some type of heuristic "
#~ "here."
#~ msgstr ""
#~ "在EvoX中方法1被命名为adapter并且非常简单，这里不再进行赘述。方法2更为复杂，但是保留原本的信息结构是他的一个优点，这意味着算法可以知道树的结构并且在此使用某种类型的启发式算法。"

#~ msgid "Advanced Tutorial"
#~ msgstr "进阶教程"

#~ msgid ""
#~ "To record information related to the population as well, turn on "
#~ "`record_pop` option in the workflow."
#~ msgstr "要同时记录与种群相关的信息，请在工作流中打开 `record_pop` 选项。"

#~ msgid ""
#~ "This will cause the population be sent to the monitor as well, and the "
#~ "monitor can then determine the best solution on the fly."
#~ msgstr "这将导致种群也被发送到监视器，监视器随后可以即时确定最佳解决方案。"

#~ msgid ""
#~ "Please note that when the population size is very large, is option can harm "
#~ "the overall performance."
#~ msgstr "请注意，当种群规模非常大时，这个选项可能会影响整体性能。"

#~ msgid "Getting Started"
#~ msgstr "开始"

#~ msgid "**base_algorithms:**"
#~ msgstr "**基础算法：**"

#~ msgid "**dim:**"
#~ msgstr "**目标数目**"

#~ msgid "**num_subpops:**"
#~ msgstr "**子种群的数量**"

#~ msgid "**random_subpop:**"
#~ msgstr "**随机化子种群：**"

#~ msgid "**key**"
#~ msgstr "**随机数生成器密钥**"

#~ msgid "State"
#~ msgstr "状态"

#~ msgid "**state**"
#~ msgstr "**状态**"

#~ msgid "population"
#~ msgstr "种群"

#~ msgid "state"
#~ msgstr "状态"

#~ msgid "**fitness**"
#~ msgstr "**适应度**"

#~ msgid "Ask the algorithm for the initial population"
#~ msgstr "向算法获取初始化种群"

#~ msgid ""
#~ "Override this method if you need to initialize the population in a special "
#~ "way. For example, Genetic Algorithm needs to evaluate the fitness of the "
#~ "initial population of size N, but after that, it only need to evaluate the "
#~ "fitness of the offspring of size M, and N != M. Since JAX requires the "
#~ "function return to have static shape, we need to have two different "
#~ "functions, one is the normal `ask` and another is `init_ask`."
#~ msgstr ""
#~ "如果您需要以特殊的方式初始化种群，请重写此方法。例如，遗传算法需要评估大小为 N 的初始种群的适应度，但在那之后，它只需要评估大小为 M "
#~ "的后代的适应度，并且 N != M。由于 JAX 要求函数返回具有静态形状，因此我们需要有两个不同的函数，一个是常规的 `ask`，另一个是 "
#~ "`init_ask`。"

#~ msgid ""
#~ "Tell the algorithm the fitness of the initial population Use in pair with "
#~ "`init_ask`."
#~ msgstr "告诉算法初始种群的适应度并应该与`init_ask`函数配对使用。"

#~ msgid "**state: State**"
#~ msgstr "**state: State**"

#~ msgid "**population: N*D matrix**"
#~ msgstr "**population: 一个 N*D 的矩阵**"

#~ msgid "**mask: n*1 bool array**"
#~ msgstr "**mask: 一个 n*1 的布尔数组**"

#~ msgid "**fitness: N*M matrix**"
#~ msgstr "**fitness: 一个 N*M 的矩阵**"

#~ msgid "dict"
#~ msgstr "字典"

#~ msgid "**X**"
#~ msgstr "**X**"

#~ msgid "ndarray"
#~ msgstr "ndarray"

#~ msgid "**ref**"
#~ msgstr "**ref**"

#~ msgid "**num_sample**"
#~ msgstr "**样本数量**"

#~ msgid "**sample_method**"
#~ msgstr "**sample_method**"

#~ msgid "**full_fit_history**"
#~ msgstr "**full_fit_history**"

#~ msgid "**full_sol_history**"
#~ msgstr "**full_sol_history**"

#~ msgid "**topk**"
#~ msgstr ""

#~ msgid "**calc_pf**"
#~ msgstr ""

#~ msgid ""
#~ "Only affect Multi-objective optimization. Whether to keep updating the "
#~ "pareto front during the run. (The Archive) Default to False. Setting it to "
#~ "True will cause the monitor to maintain a pareto front of all the solutions "
#~ "with unlimited size, which may hurt performance."
#~ msgstr ""
#~ "只影响多目标优化。是否在运行过程中记录整个帕累托前沿。默认值为False。将其设置为True将导致监视器维护一个无限大小的所有解决方案的帕累托前沿，这可能会影响性能。"

#~ msgid "**base_filename**"
#~ msgstr "**base_filename**"

#~ msgid "**out_dir**"
#~ msgstr "**out_dir**"

#~ msgid "**out_type**"
#~ msgstr "**out_type**"

#~ msgid "**batch_size**"
#~ msgstr "**batch_size**"

#~ msgid "**compression**"
#~ msgstr "**compression**"

#~ msgid "**population_name**"
#~ msgstr ""

#~ msgid "**fitness_name**"
#~ msgstr ""

#~ msgid "**to_host**"
#~ msgstr ""

#~ msgid "**fitness_only**"
#~ msgstr ""

#~ msgid "Standard Multi-objective Monitor"
#~ msgstr "标准多目标监视器"

#~ msgid ""
#~ "Standard multi-objective monitor Used for multi-objective workflow, can "
#~ "monitor fitness and record the pareto front."
#~ msgstr "标准多目标监视器，用于多目标工作流，可以监控适应度并记录帕累托前沿。"

#~ msgid "**record_pf**"
#~ msgstr "**record_pf**"

#~ msgid ""
#~ "Whether to record the pareto front during the run. Default to False. Setting"
#~ " it to True will cause the monitor to maintain a pareto front of all the "
#~ "solutions with unlimited size, which may hurt performance."
#~ msgstr ""
#~ "是否在运行过程中记录帕累托前沿。默认值为假（False）。将其设置为真（True）将导致监视器维护一个无限大小的所有解决方案的帕累托前沿，这可能会影响性能。"

#~ msgid "**record_fit_history**"
#~ msgstr "**record_fit_history**"

#~ msgid "Standard Single-objective Monitor"
#~ msgstr "标准单目标监视器"

#~ msgid ""
#~ "Standard single-objective monitor Used for single-objective workflow, can "
#~ "monitor fitness and the population."
#~ msgstr "标准单目标监控器 用于单目标工作流，可以监控适应度和种群。"

#~ msgid "**record_topk**"
#~ msgstr "**record_topk**"

#~ msgid ""
#~ "Control how many elite solutions are recorded. Default is 1, which will "
#~ "record the best individual."
#~ msgstr "控制录制多少精英解决方案。默认为1，它将记录最好的个体。"

#~ msgid "Contruct a brax-based problem"
#~ msgstr "构造一个基于Brax的问题"

#~ msgid "**policy**"
#~ msgstr "**策略**"

#~ msgid "**env_name**"
#~ msgstr "**env_name**"

#~ msgid ""
#~ "The number of brax environments to run in parallel. Usually this should "
#~ "match the population size at the algorithm side."
#~ msgstr "要并行运行的BRAX环境的数量。通常，这应该与算法端的种群大小相匹配。"

#~ msgid "**cap_episode**"
#~ msgstr "**cap_episode**"

#~ msgid "**backend**"
#~ msgstr "**后端**"

#~ msgid "**num_workers**"
#~ msgstr "**num_workers**"

#~ msgid "**env_options**"
#~ msgstr "**env_options**"

#~ msgid "**env_creator**"
#~ msgstr "**env_creator**"

#~ msgid "**mo_keys**"
#~ msgstr "**mo_keys**"

#~ msgid "**controller_options**"
#~ msgstr "**控制器选项**"

#~ msgid "**worker_options**"
#~ msgstr "**工作者选项**"

#~ msgid "**weights**"
#~ msgstr "**权重**"

#~ msgid "**ale_render_mode**"
#~ msgstr "**ale_render_mode**"

#~ msgid "**dataset**"
#~ msgstr "**状态**"

#~ msgid "**loss_func**"
#~ msgstr ""

#~ msgid "**split**"
#~ msgstr "**策略**"

#~ msgid "**operations**"
#~ msgstr "**options**"

#~ msgid "**datadir**"
#~ msgstr "**out_dir**"

#~ msgid "**seed**"
#~ msgstr "**维度**"

#~ msgid "**try_gcs**"
#~ msgstr ""

#~ msgid "**d**"
#~ msgstr "**维度**"

#~ msgid "**m**"
#~ msgstr "**目标数目**"

#~ msgid "**ref_num**"
#~ msgstr "**ref_num**"

#~ msgid "Ray-based Distributed Workflow"
#~ msgstr "基于Ray的分布式工作流"

#~ msgid "Create a distributed workflow"
#~ msgstr "创建分布式工作流"

#~ msgid ""
#~ "Distributed workflow can distribute the workflow to different nodes, it will"
#~ " create num_workers copies of the workflows with the same seed, and at each "
#~ "step each workflow only evaluate part of the population, then pass the "
#~ "fitness to other nodes to recreate the whole fitness array."
#~ msgstr ""
#~ "分布式工作流能够将工作流程分布到不同的节点上。它会使用相同的随机种子创建num_workers个相同工作流程副本，并且在每一步中，每个工作流程仅评估种群的一部分，然后将适应度值传递给其他节点以重建整个适应度数组。这样，通过各节点间的协作，实现大规模并行计算和优化过程的高效执行。"

#~ msgid "sol_transforms and fit_transforms are applied at each node,"
#~ msgstr "候选解变换和适应度变换，这个变换在每个工作节点上应用。"

#~ msgid "**algorithm**"
#~ msgstr "**算法**"

#~ msgid "**problem**"
#~ msgstr "**问题**"

#~ msgid "Number of workers."
#~ msgstr "工作者的数目。"

#~ msgid "**opt_direction**"
#~ msgstr "**opt_direction**"

#~ msgid "**options**"
#~ msgstr "**options**"

#~ msgid "The runtime options of the worker actor."
#~ msgstr "工作者（worker）actor的运行时选项。"

#~ msgid "**sol_transforms:**"
#~ msgstr "**pop_transform:**"

#~ msgid "Population transform, this transform is applied at each worker node."
#~ msgstr "Population transform，这种转换会被应用到每一个worker节点。"

#~ msgid "**fit_transforms:**"
#~ msgstr ""

#~ msgid "Fitness transform, this transform is applied at each worker node."
#~ msgstr "适应度变换，这个变换在每个工作节点上应用。"

#~ msgid "Non-jit Workflow"
#~ msgstr ""

#~ msgid "**monitor**"
#~ msgstr "**监控器**"

#~ msgid "Optional monitor."
#~ msgstr "可选监控器。"

#~ msgid "**sol_transforms**"
#~ msgstr ""

#~ msgid "**fit_transforms**"
#~ msgstr ""

#~ msgid "Sample the algorithm but don't change it's state"
#~ msgstr "对算法采样但不改变它的状态"

#~ msgid "**sol_transform**"
#~ msgstr ""

#~ msgid "**jit_problem**"
#~ msgstr "**jit_problem**"

#~ msgid "If the problem can be jit compiled by JAX or not. Default to True."
#~ msgstr "问题是否可以通过JAX进行jit编译。默认为True。"

#~ msgid "**num_objectives**"
#~ msgstr "**num_objectives**"

#~ msgid ""
#~ "Number of objectives. When the problem can be jit compiled, this field is "
#~ "not needed. When the problem cannot be jit compiled, this field should be "
#~ "set, if not, default to 1."
#~ msgstr "目标数量。当问题可以被 JIT（即时编译）时，这个字段不是必需的。当问题不能被 JIT 编译时，应设置这个字段，如果没有设置，默认为 1。"

#~ msgid ""
#~ "Enable the distributed workflow to run across multiple nodes. To use jax's "
#~ "distribution ability, one need to run the same program on all nodes with "
#~ "different parameters in `jax.distributed.initialize`."
#~ msgstr ""
#~ "启用分布式工作流在多个节点上运行。要使用 JAX 的分布式处理能力，需要在所有节点上运行相同的程序，并在 "
#~ "jax.distributed.initialize 中使用不同的参数。"

#~ msgid "The sharded state, distributed amoung all nodes."
#~ msgstr "分布在所有节点上的分片状态。"

#~ msgid "Enable the workflow to run on multiple local devices."
#~ msgstr "允许workflow利用单台机器的多个设备（GPU）。"

#~ msgid "**devices**"
#~ msgstr "**设备**"

#~ msgid "A list of devices. If set to None, all local devices will be used."
#~ msgstr "设备列表。如果设置为“None”，将使用所有本地设备。"

#~ msgid "The sharded state, distributed amoung all devices."
#~ msgstr "分布在所有设备上的分片状态。"

#~ msgid ""
#~ "In EvoX, we almost guarantee that all low-level components are jit-compiled "
#~ "(all operators), and high-level components (`Workflow`) can have both jit-"
#~ "compiled variants (e.g. {doc}`StdWorkflow </api/workflows/standard>`) and "
#~ "non-jit-compiled variants (e.g. {doc}`StdWorkflow "
#~ "</api/workflows/non_jit>`)."
#~ msgstr ""

#~ msgid ""
#~ "This time, we can access the minimum fitness achieved through the `monitor`."
#~ msgstr "这次，我们可以通过 `monitor` 访问达到的最小适应度。"

#~ msgid ""
#~ "Now create brax-based problem. The `batch_size` defines how many environment"
#~ " in a single batch,  and `cap_episode` controls when to truncate the "
#~ "episode."
#~ msgstr ""
#~ "现在创建基于Brax的问题。`batch_size` 定义了单个批次中有多少个环境，而 `cap_episode` 控制了何时截断一个情节。"

#~ msgid ""
#~ "In this case, we set `batch_size` to 4096, which is the same as our "
#~ "population size. This means the whole population will be evaluated in a "
#~ "single pass!"
#~ msgstr "在这种情况下，我们将 `batch_size` 设置为4096，这与我们的种群大小相同。这意味着整个种群将在一次传递中被评估！"

#~ msgid ""
#~ "<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
#~ "octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
#~ "fill-rule=\"evenodd\" d=\"M12.292 2.06a.75.75 0 00-.584 0L.458 6.81a.75.75 0"
#~ " 000 1.38L4.25 9.793v3.803a2.901 2.901 0 00-1.327.757c-.579.58-.923 "
#~ "1.41-.923 2.43v4.5c0 "
#~ ".248.128.486.335.624.06.04.117.073.22.124.124.062.297.138.52.213.448.149 "
#~ "1.09.288 1.925.288s1.477-.14 1.925-.288c.223-.075.396-.15.52-.213a2.11 2.11 "
#~ "0 00.21-.117A.762.762 0 008 21.28v-4.5c0-1.018-.344-1.85-.923-2.428a2.9 2.9 "
#~ "0 00-1.327-.758v-3.17l5.958 2.516a.75.75 0 00.584 0l5.208-2.2v4.003a2.552 "
#~ "2.552 0 01-.079.085 4.057 4.057 0 01-.849.65c-.826.488-2.255 1.021-4.572 "
#~ "1.021-.612 0-1.162-.037-1.654-.1a.75.75 0 00-.192 1.487c.56.072 1.173.113 "
#~ "1.846.113 2.558 0 4.254-.592 5.334-1.23.538-.316.914-.64 1.163-.896a2.84 "
#~ "2.84 0 00.392-.482h.001A.75.75 0 0019 15v-4.892l4.542-1.917a.75.75 0 "
#~ "000-1.382l-11.25-4.75zM5 15c-.377 0-.745.141-1.017.413-.265.265-.483.7-.483 "
#~ "1.368v4.022c.299.105.797.228 1.5.228s1.201-.123 "
#~ "1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.431 1.431 0 005 "
#~ "15zm7-3.564L2.678 7.5 12 3.564 21.322 7.5 12 11.436z\"></path></svg> "
#~ "Developer Guide"
#~ msgstr ""
#~ "<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
#~ "octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
#~ "fill-rule=\"evenodd\" d=\"M12.292 2.06a.75.75 0 00-.584 0L.458 6.81a.75.75 0"
#~ " 000 1.38L4.25 9.793v3.803a2.901 2.901 0 00-1.327.757c-.579.58-.923 "
#~ "1.41-.923 2.43v4.5c0 "
#~ ".248.128.486.335.624.06.04.117.073.22.124.124.062.297.138.52.213.448.149 "
#~ "1.09.288 1.925.288s1.477-.14 1.925-.288c.223-.075.396-.15.52-.213a2.11 2.11 "
#~ "0 00.21-.117A.762.762 0 008 21.28v-4.5c0-1.018-.344-1.85-.923-2.428a2.9 2.9 "
#~ "0 00-1.327-.758v-3.17l5.958 2.516a.75.75 0 00.584 0l5.208-2.2v4.003a2.552 "
#~ "2.552 0 01-.079.085 4.057 4.057 0 01-.849.65c-.826.488-2.255 1.021-4.572 "
#~ "1.021-.612 0-1.162-.037-1.654-.1a.75.75 0 00-.192 1.487c.56.072 1.173.113 "
#~ "1.846.113 2.558 0 4.254-.592 5.334-1.23.538-.316.914-.64 1.163-.896a2.84 "
#~ "2.84 0 00.392-.482h.001A.75.75 0 0019 15v-4.892l4.542-1.917a.75.75 0 "
#~ "000-1.382l-11.25-4.75zM5 15c-.377 0-.745.141-1.017.413-.265.265-.483.7-.483 "
#~ "1.368v4.022c.299.105.797.228 1.5.228s1.201-.123 "
#~ "1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.431 1.431 0 005 "
#~ "15zm7-3.564L2.678 7.5 12 3.564 21.322 7.5 12 11.436z\"></path></svg> 开发者教程"

#~ msgid "Cooperative Coevolution"
#~ msgstr "协同演化"

#~ msgid "A container for vectorized co-evolutionary algorithms."
#~ msgstr "向量化的协同演化算法容器"

#~ msgid ""
#~ "A batch of base algorithms. Usually created from `Stateful.stack(...)`, "
#~ "where ... is a list of algorithms."
#~ msgstr "一批基础算法。通常是由`Stateful.stack(...)`创建出来的，其中...是一个算法的列表。"

#~ msgid ""
#~ "Whether to shuffle the problem dimension before co-evolution. When set to "
#~ "False, each subpopulation will corespond to a contiguous block of the "
#~ "decision variables, for example, dimension 0~9 for subpopulation 0, 10~19 "
#~ "for subpopulation 1, etc. When set to True, the decision variables will be "
#~ "shuffled."
#~ msgstr ""
#~ "是否打乱问题的维度。如果设置为False，那么每个子种群会对应原始的问题中连续的一段决策变量，比如说，0-9维会分配给0号子种群，10-19维会分配给1号子种群。当设置为True的时候，决策变量将会被打乱。"

#~ msgid "Return type"
#~ msgstr "返回值类型"

#~ msgid "This method should not be overwritten."
#~ msgstr "此方法不应被复写。"

#~ msgid "A PRNGKey."
#~ msgstr "一个伪随机数生成器密钥。"

#~ msgid "The state of this module and all submodules combined."
#~ msgstr "该模块及其所有子模块的组合之和。"

#~ msgid "Initialize multiple copies of this module in parallel"
#~ msgstr "并行初始化多个此模块。"

#~ msgid "Whether to skip the state initialization"
#~ msgstr "是否跳过状态初始化"

#~ msgid ""
#~ "The state of this module and all submodules combined, and the last node_id"
#~ msgstr "该模块及其所有子模块，以及最后的node_id。"

#~ msgid ""
#~ "Add a replace method to dataclasses. It's different from dataclasses.replace"
#~ " in that it doesn't call the __init__, instead it copies the object and sets"
#~ " the new values."
#~ msgstr ""
#~ "为数据类添加一个 replace 方法。它与 dataclasses.replace 不同，后者会调用 __init__ 方法，而此方法不会调用 "
#~ "__init__ 方法，而是复制对象并设置新的值。"

#~ msgid "A container for co-evolutionary algorithms."
#~ msgstr "一个协同演化的算法容器。"

#~ msgid "Clustered Algorithm"
#~ msgstr "聚类算法"

#~ msgid ""
#~ "A container that split the encoding into subproblems, and run an Algorithm "
#~ "on each."
#~ msgstr "一个容器，它将编码分割成若干子问题，并在每个子问题上运行一个算法。"

#~ msgid ""
#~ "Can take in any base algorithm, split the problem into n different sub-"
#~ "problems and solve each problem using the base algorithm. Dim must be a "
#~ "multiple of num_cluster, and num_cluster must be a multiple of num_gpus."
#~ msgstr ""
#~ "能够接收任何基础算法，将问题分割成 n "
#~ "个不同的子问题，并使用基础算法解决每个子问题。其中，维度（Dim）必须是簇数量（num_cluster）的倍数，而簇数量（num_cluster）必须是"
#~ " GPU 数量（num_gpus）的倍数。"

#~ msgid "Ask the algorithm"
#~ msgstr "询问这个算法"

#~ msgid "Ask the algorithm for points to explore"
#~ msgstr "向算法询问要探索的点"

#~ msgid ""
#~ "* *population* -- The candidate solution. * *state* -- The new state of the "
#~ "algorithm."
#~ msgstr "**population** —— 候选解。**state** —— 算法的新状态。"

#~ msgid "*population* -- The candidate solution."
#~ msgstr "*population* -- 候选解。"

#~ msgid "*state* -- The new state of the algorithm."
#~ msgstr "*state* -- 算法的新的状态。"

#~ msgid "Setup mutable state here"
#~ msgstr "在这里设置可变状态"

#~ msgid ""
#~ "The state it self is immutable, but it act as a mutable state by returning "
#~ "new state each time."
#~ msgstr "状态本身是不可变的，但是你可以通过生成一个新的状态来实现修改的操作。"

#~ msgid ""
#~ "Tell the algorithm about the points it chose and their corresponding fitness"
#~ msgstr "告诉算法它选择的点以及它们对应的适应度"

#~ msgid "The state of this algorithm"
#~ msgstr "算法的状态"

#~ msgid "Cluster container with random mask"
#~ msgstr "带有随机掩码的簇容器"

#~ msgid ""
#~ "pop_size is needed, because JAX needs static shape, if pop_size is None, it "
#~ "will try to read pop_size from base_algorithm"
#~ msgstr ""
#~ "需要指定种群大小（pop_size），因为 JAX 需要静态形状，如果种群大小（pop_size）未设定，系统将尝试从基础算法中读取种群大小"

#~ msgid "Containers"
#~ msgstr "容器"

#~ msgid "Tree Algorithm"
#~ msgstr "树算法"

#~ msgid "Algorithms"
#~ msgstr "算法"

#~ msgid ""
#~ "The module that contains all pre-defined algorithms, including both single-"
#~ "objective algorithms and multi-objective algorithms."
#~ msgstr "包含所有预定义算法的模块，包括单目标算法和多目标算法。"

#~ msgid "BCEIBEA"
#~ msgstr "BCEIBEA"

#~ msgid "Bi-criterion evolution based IBEA"
#~ msgstr "Bi-criterion evolution based IBEA"

#~ msgid "link: https://ieeexplore.ieee.org/abstract/document/7347391"
#~ msgstr "链接：https://ieeexplore.ieee.org/abstract/document/7347391"

#~ msgid "Args:"
#~ msgstr "参数："

#~ msgid ""
#~ "kappa (float, optional): The scaling factor for selecting parents in the "
#~ "environmental selection."
#~ msgstr "kappa（浮点型，可选）：环境选择中用于选择父代的缩放因子。"

#~ msgid ""
#~ "It controls the probability of selecting parents based on their fitness "
#~ "values. Defaults to 0.05."
#~ msgstr "它控制了基于个体适应度值选择父代的概率。默认值为0.05。"

#~ msgid "BiGE"
#~ msgstr "BiGE"

#~ msgid "BiGE algorithm"
#~ msgstr "BiGE算法"

#~ msgid "link: https://doi.org/10.1016/j.artint.2015.06.007"
#~ msgstr "链接：https://doi.org/10.1016/j.artint.2015.06.007"

#~ msgid "EAG-MOEA/D"
#~ msgstr "EAG-MOEA/D"

#~ msgid "EAG-MOEA/D algorithm"
#~ msgstr "EAG-MOEA/D算法"

#~ msgid "link: https://ieeexplore.ieee.org/abstract/document/6882229"
#~ msgstr "链接：https://ieeexplore.ieee.org/abstract/document/6882229"

#~ msgid "GDE3"
#~ msgstr "GDE3"

#~ msgid "GDE3 algorithm"
#~ msgstr "GDE3算法"

#~ msgid "link: https://ieeexplore.ieee.org/document/1554717"
#~ msgstr "链接：https://ieeexplore.ieee.org/document/1554717"

#~ msgid "Parameters for Differential Evolution"
#~ msgstr "差分演化的参数"

#~ msgid "F"
#~ msgstr "F"

#~ msgid "CR"
#~ msgstr "CR"

#~ msgid "HypE"
#~ msgstr "HypE"

#~ msgid "HypE algorithm"
#~ msgstr "HypE算法"

#~ msgid ""
#~ "link: https://direct.mit.edu/evco/article-abstract/19/1/45/1363/HypE-An-"
#~ "Algorithm-for-Fast-Hypervolume-Based-Many"
#~ msgstr ""
#~ "链接：https://direct.mit.edu/evco/article-abstract/19/1/45/1363/HypE-An-"
#~ "Algorithm-for-Fast-Hypervolume-Based-Many"

#~ msgid "IBEA"
#~ msgstr "IBEA"

#~ msgid "IBEA algorithm"
#~ msgstr "IBEA算法"

#~ msgid "link: https://link.springer.com/chapter/10.1007/978-3-540-30217-9_84"
#~ msgstr "链接：https://link.springer.com/chapter/10.1007/978-3-540-30217-9_84"

#~ msgid "kappa: fitness scaling factor. Default: 0.05"
#~ msgstr "kappa：适应度缩放因子。默认值：0.05"

#~ msgid "IMMOEA"
#~ msgstr "IMMOEA"

#~ msgid "get sub_population by Gaussian Process and mutation."
#~ msgstr ""

#~ msgid ""
#~ "select certain number of sub_population by NSGA-II's selection algorithm."
#~ msgstr ""

#~ msgid "KnEA"
#~ msgstr "KnEA"

#~ msgid "KnEA algorithm"
#~ msgstr "KnEA算法"

#~ msgid "link: https://ieeexplore.ieee.org/document/6975108"
#~ msgstr "链接：https://ieeexplore.ieee.org/document/6975108"

#~ msgid "LMOCSO"
#~ msgstr "LMOCSO"

#~ msgid "LMOCSO algorithm"
#~ msgstr "LMOCSO算法"

#~ msgid "link: https://ieeexplore.ieee.org/document/8681243"
#~ msgstr "链接：https://ieeexplore.ieee.org/document/8681243"

#~ msgid ""
#~ "alpha : The parameter controlling the rate of change of penalty. Defaults to"
#~ " 2. max_gen : The maximum number of generations. Defaults to 100. If the "
#~ "number of iterations is not 100, change the value based on the actual value."
#~ msgstr "alpha：控制罚分变化率的参数。默认值为2。max_gen：最大代数。默认值为100。如果迭代次数不是100，根据实际值更改该值。"

#~ msgid "MOEA/D"
#~ msgstr "MOEA/D"

#~ msgid "link: https://ieeexplore.ieee.org/document/4358754"
#~ msgstr "链接：https://ieeexplore.ieee.org/document/4358754"

#~ msgid "MOEA/D-DRA"
#~ msgstr "MOEA/D-DRA"

#~ msgid "MOEA/D-DRA algorithm"
#~ msgstr "MOEA/D-DRA算法"

#~ msgid "link: https://ieeexplore.ieee.org/abstract/document/4982949"
#~ msgstr "链接：https://ieeexplore.ieee.org/abstract/document/4982949"

#~ msgid "MOEA/D-M2M"
#~ msgstr "MOEA/D-M2M"

#~ msgid "MOEA/D based on MOP to MOP algorithm"
#~ msgstr "MOEA/D M2M 算法"

#~ msgid "link: https://ieeexplore.ieee.org/abstract/document/6595549"
#~ msgstr "链接：https://ieeexplore.ieee.org/abstract/document/6595549"

#~ msgid "NSGA-II"
#~ msgstr "NSGA-II"

#~ msgid "link: https://ieeexplore.ieee.org/document/996017"
#~ msgstr "链接：https://ieeexplore.ieee.org/document/996017"

#~ msgid "NSGA-III"
#~ msgstr "NSGA-III"

#~ msgid "NSGA-III algorithm"
#~ msgstr "NSGA-III算法"

#~ msgid "link: https://ieeexplore.ieee.org/document/6600851"
#~ msgstr "链接：https://ieeexplore.ieee.org/document/6600851"

#~ msgid "RVEA"
#~ msgstr "RVEA"

#~ msgid "RVEA algorithms"
#~ msgstr "RVEA算法"

#~ msgid "link: https://ieeexplore.ieee.org/document/7386636"
#~ msgstr "链接：https://ieeexplore.ieee.org/document/7386636"

#~ msgid ""
#~ "alpha : The parameter controlling the rate of change of penalty. Defaults to"
#~ " 2. fr : The frequency of reference vector adaptation. Defaults to 0.1. "
#~ "max_gen : The maximum number of generations. Defaults to 100. If the number "
#~ "of iterations is not 100, change the value based on the actual value."
#~ msgstr ""
#~ "alpha：控制罚分变化率的参数。默认值为2。fr：参考向量适应频率。默认值为0.1。max_gen：最大代数。默认值为100。如果迭代次数不是100，根据实际值更改该值。"

#~ msgid "RVEAa"
#~ msgstr "RVEAa"

#~ msgid ""
#~ "RVEAa algorithms (RVEA embedded with the reference vector regeneration "
#~ "strategy)"
#~ msgstr ""

#~ msgid "SPEA2"
#~ msgstr "SPEA2"

#~ msgid "SPEA2 algorithm"
#~ msgstr "SPEA2算法"

#~ msgid ""
#~ "link: https://www.research-collection.ethz.ch/handle/20.500.11850/145755"
#~ msgstr "链接：https://www.research-collection.ethz.ch/handle/20.500.11850/145755"

#~ msgid "SRA"
#~ msgstr "SRA"

#~ msgid "Stochastic ranking algorithm"
#~ msgstr "随机排序算法"

#~ msgid "link: https://ieeexplore.ieee.org/abstract/document/7445185"
#~ msgstr "链接：https://ieeexplore.ieee.org/abstract/document/7445185"

#~ msgid "tDEA"
#~ msgstr "tDEA"

#~ msgid "Theta-dominance based evolutionary algorithm"
#~ msgstr "基于θ优势的演化算法"

#~ msgid "link: https://ieeexplore.ieee.org/abstract/document/7080938"
#~ msgstr "链接：https://ieeexplore.ieee.org/abstract/document/7080938"

#~ msgid "AMaLGaM"
#~ msgstr "AMaLGaM"

#~ msgid "ARS"
#~ msgstr "ARS"

#~ msgid "ASEBO"
#~ msgstr "ASEBO"

#~ msgid "CLPSO"
#~ msgstr "CLPSO"

#~ msgid "CMA-ES"
#~ msgstr "CMA-ES"

#~ msgid ""
#~ "CMA-ES involves eigendecomposition, which introduces relatively large "
#~ "numerical error, and may lead to non-deterministic behavior on different "
#~ "hardware backends."
#~ msgstr "CMA-ES涉及特征分解，这会引入相对较大的数值误差，并可能导致在不同硬件后端上的非确定性行为。"

#~ msgid "CoDE"
#~ msgstr "CoDE"

#~ msgid ""
#~ "CoDE Wang Y, Cai Z, Zhang Q. Differential evolution with composite trial "
#~ "vector generation strategies and control parameters[J]. IEEE transactions on"
#~ " evolutionary computation, 2011, 15(1): 55-66."
#~ msgstr ""
#~ "CoDE Wang Y, Cai Z, Zhang Q. Differential evolution with composite trial "
#~ "vector generation strategies and control parameters[J]. IEEE transactions on"
#~ " evolutionary computation, 2011, 15(1): 55-66."

#~ msgid "CR-FM-NES"
#~ msgstr "CR-FM-NES"

#~ msgid "CSO"
#~ msgstr "CSO"

#~ msgid ""
#~ "CSO(lb: jax.Array, ub: jax.Array, pop_size: int, phi: float = 0.0, mean: "
#~ "Optional[jax.Array] = None, stdev: Optional[jax.Array] = None)"
#~ msgstr ""

#~ msgid "DE"
#~ msgstr "DE"

#~ msgid "DES"
#~ msgstr "DES"

#~ msgid "DMS-PSO-EL"
#~ msgstr "DMS-PSO-EL"

#~ msgid "ESMC"
#~ msgstr "ESMC"

#~ msgid "FIPS"
#~ msgstr "FIPS"

#~ msgid "GuidedES"
#~ msgstr "GuidedES"

#~ msgid "Single-objective"
#~ msgstr "单目标"

#~ msgid "JaDE"
#~ msgstr "JaDE"

#~ msgid ""
#~ "JaDE Zhang J, Sanderson A C. JADE: adaptive differential evolution with "
#~ "optional external archive[J]. IEEE Transactions on evolutionary computation,"
#~ " 2009, 13(5): 945-958."
#~ msgstr ""
#~ "JaDE Zhang J, Sanderson A C. JADE: adaptive differential evolution with "
#~ "optional external archive[J]. IEEE Transactions on evolutionary computation,"
#~ " 2009, 13(5): 945-958."

#~ msgid "LES"
#~ msgstr "LES"

#~ msgid "MA-ES"
#~ msgstr "MA-ES"

#~ msgid "xNES"
#~ msgstr "xNES"

#~ msgid "See [link](https://arxiv.org/pdf/1106.4487.pdf) for default parameters"
#~ msgstr "参考链接[link](https://arxiv.org/pdf/1106.4487.pdf)中的默认参数"

#~ msgid "Noise-Reuse-ES"
#~ msgstr "Noise-Reuse-ES"

#~ msgid "ODE"
#~ msgstr "ODE"

#~ msgid "OpenES"
#~ msgstr "OpenES"

#~ msgid "PersistentES"
#~ msgstr "PersistentES"

#~ msgid "PGPE"
#~ msgstr "PGPE"

#~ msgid ""
#~ "PGPE(pop_size: int, center_init: jax.Array, optimizer: Union[str, "
#~ "optax._src.base.GradientTransformation, evox.core.module.Stateful], "
#~ "stdev_init: float = 0.1, center_learning_rate: float = 0.15, "
#~ "stdev_learning_rate: float = 0.1, stdev_max_change: float = 0.2)"
#~ msgstr ""

#~ msgid "PSO"
#~ msgstr "PSO"

#~ msgid ""
#~ "PSO(lb: jax.Array, ub: jax.Array, pop_size: jax.Array, w: jax.Array = 0.6, "
#~ "phi_p: jax.Array = 2.5, phi_g: jax.Array = 0.8, mean: Optional[jax.Array] = "
#~ "None, stdev: Optional[jax.Array] = None, bound_method: str = 'clip')"
#~ msgstr ""

#~ msgid "RMES"
#~ msgstr "RMES"

#~ msgid "SaDE"
#~ msgstr "SaDE"

#~ msgid ""
#~ "SaDE Qin A K, Huang V L, Suganthan P N. Differential evolution algorithm "
#~ "with strategy adaptation for global numerical optimization[J]. IEEE "
#~ "transactions on Evolutionary Computation, 2008, 13(2): 398-417."
#~ msgstr ""
#~ "SaDE Qin A K, Huang V L, Suganthan P N. Differential evolution algorithm "
#~ "with strategy adaptation for global numerical optimization[J]. IEEE "
#~ "transactions on Evolutionary Computation, 2008, 13(2): 398-417."

#~ msgid "SHADE"
#~ msgstr "SHADE"

#~ msgid ""
#~ "SHADE Tanabe R, Fukunaga A. Success-history based parameter adaptation for "
#~ "differential evolution[C]//2013 IEEE congress on evolutionary computation. "
#~ "IEEE, 2013: 71-78."
#~ msgstr ""
#~ "SHADE Tanabe R, Fukunaga A. Success-history based parameter adaptation for "
#~ "differential evolution[C]//2013 IEEE congress on evolutionary computation. "
#~ "IEEE, 2013: 71-78."

#~ msgid "SL-PSO-GS"
#~ msgstr "SL-PSO-GS"

#~ msgid "SL-PSO-US"
#~ msgstr "SL-PSO-US"

#~ msgid "SWMMPSO"
#~ msgstr "SWMMPSO"

#~ msgid "This module allow easy managing of states."
#~ msgstr "这个模块允许轻松管理状态。"

#~ msgid ""
#~ "All the constants (e.g. hyperparameters) are initialized in the "
#~ "``__init__``, and mutated states are initialized in the ``setup`` method."
#~ msgstr "所有常数（例如超参数）都在“ __init__” 中初始化，而变异状态则在 “setup” 方法中初始化。"

#~ msgid ""
#~ "The ``init`` method will automatically call the ``setup`` of the current "
#~ "module and recursively call ``setup`` methods of all submodules."
#~ msgstr "“init” 方法将自动调用当前模块的 “setup”，并递归地调用所有子模块的 “setup” 方法。"

#~ msgid ""
#~ "Currently, there are two special metadata that can be used to control the "
#~ "behavior of the module initialization: - ``stack``: If set to True, the "
#~ "module will be initialized multiple times, and the states will be stacked "
#~ "together. - ``nested``: If set to True, the a list of modules, that is "
#~ "[module1, module2, ...], will be iterated and initialized."
#~ msgstr ""
#~ "目前，有两个特殊的元数据可以用于控制模块初始化的行为：- ``stack``：如果设置为 `True`，模块将被多次初始化，状态将堆叠在一起。- "
#~ "``nested``：如果设置为 `True`，则会遍历并初始化一个模块列表，即 `[module1, module2, ...]`。"

#~ msgid "The state of this problem."
#~ msgstr "这个问题的状态。"

#~ msgid "* *dict* -- The new state of the problem. * *ndarray* -- The fitness."
#~ msgstr "**dict** —— 问题的新状态。**ndarray** —— 适应度（fitness）。"

#~ msgid "*dict* -- The new state of the problem."
#~ msgstr "*dict* -- 这个问题的新的状态。"

#~ msgid "*ndarray* -- The fitness."
#~ msgstr "*ndarray* -- 适应度值。"

#~ msgid "State Class"
#~ msgstr "状态类"

#~ msgid ""
#~ "``State`` is immutable, to update state, use the ``update`` method or the "
#~ "``|`` operator. ``State`` has already implemented ``tree_flatten``, "
#~ "``tree_unflatten`` and has registered as a valid pytree node. So it can be "
#~ "used as pytree with JAX without any issue."
#~ msgstr ""
#~ "“State ”是不可变的，要更新状态，请使用“update ” 方法或 “| ”运算符。“State ” 已经实现了 "
#~ "“tree_flatten”、“tree_unflatten ”并且已注册为有效的 pytree 节点。因此，它可以与 JAX 一起作为 pytree "
#~ "使用。"

#~ msgid "Construct a ``State`` from dataclass instance or keyword arguments"
#~ msgstr "从Python数据类（dataclass）或关键字（keyword arguments）构建一个状态（State）对象"

#~ msgid "Example::"
#~ msgstr "例子："

#~ msgid "Clear all the callbacks in the state"
#~ msgstr "清除这个状态里的回调函数"

#~ msgid "Execute all the callbacks in the state"
#~ msgstr "执行状态里的回调函数"

#~ msgid ""
#~ "Find the state with node_id matching the state_id A hint can be given with "
#~ "the module_name"
#~ msgstr "找到节点 ID 与状态 ID 匹配的状态。可以通过模块名称给出提示"

#~ msgid "Construct a ``State`` from dataclass instance"
#~ msgstr "从Python数据类（``dataclass``）构建一个状态（``State``）对象"

#~ msgid "PyTree index, apply the index to every element in the state."
#~ msgstr "对Pytree进行索引，将对Pytree中的每个元素使用索引。"

#~ msgid "Load the saved state from disk"
#~ msgstr "从硬盘上加载保存的状态"

#~ msgid "The path to load the state"
#~ msgstr "到状态保存位置的路径"

#~ msgid "If True, use orbax to load the state, otherwise use pickle"
#~ msgstr "如果为True，则使用orbax加载状态，否则使用pickle"

#~ msgid "Prepare closures stored in others to the current state"
#~ msgstr ""

#~ msgid ""
#~ "Recursively find a sub-state by a query name. eg: `'foo.bar'` will find a "
#~ "sub state named foo, then find `bar` under sub-states of `foo`"
#~ msgstr "递归地通过查询名称查找子状态。例如：`foo.bar` 将先查找名为 `foo` 的子状态，然后在 `foo` 的子状态中查找 `bar`"

#~ msgid "Add a callback to the state"
#~ msgstr "将一个回调函数加入状态中"

#~ msgid ""
#~ "Update the current State with another State or dict and return new State."
#~ msgstr "使用另一个 State 或 dict 更新当前 State，并返回新的 State。"

#~ msgid "This method also accept keyword arguments."
#~ msgstr "这个方法也接受关键字参数。"

#~ msgid "Save the state to local filesystem"
#~ msgstr "将状态保存至本地的文件系统"

#~ msgid "If True, use orbax to save the state, otherwise use pickle"
#~ msgstr "如果为True，则使用 `orbax` 保存状态，否则使用 `pickle` 保存状态"

#~ msgid "Generational Distance"
#~ msgstr "世代距离"

#~ msgid ""
#~ "Hypervolume indicator Implemented using monte carlo. We offers two different"
#~ " sample methods: `bounding_cube` and `each_cube`. With `bounding_cube`, we "
#~ "draw samples from a hypercube that can bound all objectives. With "
#~ "`each_cube`, we draw samples from each hypercube form by each objective and "
#~ "the reference point. Since reference point is often far from pf, "
#~ "`bounding_cube` method usually gives more accurate result."
#~ msgstr ""
#~ "超体积指标，使用蒙特卡洛方法实现。我们提供两种不同的样本方法：`bounding_cube` 和 `each_cube`。使用 "
#~ "`bounding_cube` 方法，我们从一个可以包围所有目标的超立方体中抽取样本。使用 `each_cube` "
#~ "方法，我们从由每个目标和参考点形成的每个超立方体中抽取样本。由于参考点通常远离帕雷托前沿（pf），`bounding_cube`方法通常能提供更准确的结果。"

#~ msgid "The reference point."
#~ msgstr "参考点。"

#~ msgid "Number of samples to draw when doing monte carlo."
#~ msgstr "在使用蒙特卡洛方法的时候样本的数量。"

#~ msgid "`bounding_cube` or `each_cube`. Default to `bounding_cube`."
#~ msgstr "`bounding_cube` 或 `each_cube`. 默认为 `bounding_cube`."

#~ msgid "Inverted Generational Distance"
#~ msgstr "反世代距离"

#~ msgid "Metrics"
#~ msgstr "度量指标"

#~ msgid ""
#~ "Whether to record the full history of solutions. Default to False. Setting "
#~ "it to True may increase memory usage, and adding a significant overhead of "
#~ "transfering the entire solutions set from GPU to CPU."
#~ msgstr "是否记录完整的解集的历史。默认值为False。将其设置为True可能会减少内存占用，并会带来很大的GPU/CPU间数据传输开销。"

#~ msgid ""
#~ "Clear the history of fitness and solutions. Normally it will be called at "
#~ "the initialization of Workflow object."
#~ msgstr "清楚历史适应度值和解集。正常情况下，Workflow对象在初始化的时候会自动调用此方法。"

#~ msgid "Get the full history of fitness values."
#~ msgstr "获取完整的适应度值历史记录。"

#~ msgid "Get the fitness values from the latest iteration."
#~ msgstr "获取最近一代的适应度值。"

#~ msgid "Get the solution from the latest iteration."
#~ msgstr "获取最近一代的解。"

#~ msgid ""
#~ "Get the approximate pareto front solutions and fitness values of all the "
#~ "solutions evaluated so far. Requires enabling both `full_sol_history` and "
#~ "`full_sol_history`. If `deduplicate` is set to True, the duplicated "
#~ "solutions will be removed."
#~ msgstr ""
#~ "获取当前的近似帕勒托前沿的解集和对应的适应度值。需要同时启用`full_sol_history`和`full_sol_history`选项。如果`deduplicate`为True，则会对解集进行去重。"

#~ msgid ""
#~ "Get the approximate pareto front fitness values of all the solutions "
#~ "evaluated so far. Requires enabling `full_fit_history`."
#~ msgstr "获取当前的近似帕勒托前沿的适应度值部分。需要启用`full_fit_history`。"

#~ msgid ""
#~ "Get the approximate pareto front solutions of all the solutions evaluated so"
#~ " far. Requires enabling both `full_sol_history` and `full_sol_history`. If "
#~ "`deduplicate` is set to True, the duplicated solutions will be removed."
#~ msgstr ""
#~ "获取当前的近似帕勒托前沿的解集部分。需要同时启用`full_sol_history`和`full_sol_history`。如果`deduplicate`为True，则会对解集进行去重。"

#~ msgid "Get the full history of solutions."
#~ msgstr "获取完整的解集历史记录。"

#~ msgid "Get the topk fitness values so far."
#~ msgstr "获取当前前k优的适应度值。"

#~ msgid "Get the topk solutions so far."
#~ msgstr "获取当前前k优的解。"

#~ msgid "EvoXVis Monitor"
#~ msgstr "EvoXVis 监视器"

#~ msgid ""
#~ "This class serialize data to apache arrow format, which can be picked up and"
#~ " used in EvoXVis. The tensors are stored as fixed size binary and the dtype "
#~ "is recorded in the metadata."
#~ msgstr ""
#~ "这个类将数据序列化为可以在EvoXVis中提取和使用的apache arrow格式。张量被存储为固定大小的二进制，并且数据类型被记录在元数据中。"

#~ msgid ""
#~ "The base filename of the log file, the final filename will be "
#~ "``<base_filename>_<i>.arrow``, where i is an incrementing number."
#~ msgstr "日志文件的基本文件名，最终文件名将是``<base_filename>_<i>.arrow``，其中i是递增的数字。"

#~ msgid ""
#~ "This directory to write the log file into. When set to None, the default "
#~ "directory will be used. The default is ``<TEMP_DIR>/evox``, on Windows, it's"
#~ " usually ``C:\\TEMP\\evox``, and on MacOS/Linux/BSDs it's ``/tmp/evox``."
#~ msgstr ""
#~ "将日志文件写入的目录。当设置为None时，将使用默认目录。默认为``<TEMP_DIR>/evox``，在Windows上通常为``C：\\temp\\evox``，在MacOS/Linux/BSD上为``/tMP/evox``。"

#~ msgid ""
#~ "\"stream\" or \"file\", For more information, please refer to "
#~ "https://arrow.apache.org/docs/python/ipc.html"
#~ msgstr "\"stream\" 或\"file\"，更多信息，请参考 https://arrow.apache.org/docs/python/ipc.html"

#~ msgid ""
#~ "The monitor will buffer the data in memory and write out every `batch size`."
#~ " Choose a larger value may improve I/O performance and improve compression "
#~ "ratio, if compression is enabled. Default to 64."
#~ msgstr ""
#~ "监控器会将数据缓存在内存中，并写出每个`batch size`。如果启用了压缩，则选择较大的值可能会提高I/O性能并提高压缩比。默认为64。"

#~ msgid ""
#~ "Controls the compression algorithm used when writing to the file. Available "
#~ "options are None, \"lz4\", \"zstd\", \"lz4\" is extremely fast, with poor "
#~ "compression ratio, \"zstd\" is fast, but also with good compression ratio."
#~ msgstr ""
#~ "控制写入文件时使用的压缩算法。可供选择的有None、“lz4”、“zstd”，“lz4”速度极快，压缩比差，“zstd”速度快，同时压缩比也很好。"

#~ msgid "Monitors"
#~ msgstr "监视器"

#~ msgid "Population Monitor"
#~ msgstr "种群监控器"

#~ msgid ""
#~ "Population monitor, used to monitor the population inside the genetic "
#~ "algorithm."
#~ msgstr "种群监视器，用于监视演化算法内部的种群。"

#~ msgid ""
#~ "Whether to move the population and fitness to host memory (ram). Doing so "
#~ "can reduce memory usage on device (vram), but also introduces overhead of "
#~ "data transfer. Default to False."
#~ msgstr "是否将种群和适应度移动到内存（RAM）。这样做可以减少显存（VRAM）使用，但也会引入数据传输的开销。默认值为 False。"

#~ msgid ""
#~ "Whether to only record the fitness. Setting it to True will disable the "
#~ "recording of population (decision space), only the fitness (objective space)"
#~ " will be recorded. This can reduce memory usage if you only care about the "
#~ "fitness. Default to False."
#~ msgstr ""
#~ "是否仅记录适应度。将其设置为 `True` "
#~ "将禁用种群（决策空间）的记录，只有适应度（目标空间）会被记录。如果您只关心适应度，这可以减少内存使用。默认值为 `False`。"

#~ msgid "Problems"
#~ msgstr "问题"

#~ msgid "The module that contains all pre-defined problems"
#~ msgstr "包含所有预定义的问题的模块"

#~ msgid "Neuroevolution"
#~ msgstr "神经演化"

#~ msgid ""
#~ "A callable if stateful: :code:`fn(state, weight, obs) -> action, state` "
#~ "otherwise :code:`fn(weights, obs) -> action`"
#~ msgstr ""
#~ "一个可调用的对象，如果是有状态的，签名为：:code:`fn(state, weight, obs) -> action, state` "
#~ "否则为：:code:`fn(weights, obs) -> action`"

#~ msgid ""
#~ "Indicates whether to rotate the random key for each iteration (default is "
#~ "True)."
#~ msgstr "指示是否在每次迭代后轮换随机键（默认值为 True）。"

#~ msgid ""
#~ "If True, the random key will rotate after each iteration, resulting in non-"
#~ "deterministic and potentially noisy fitness evaluations. This means that "
#~ "identical policy weights may yield different fitness values across "
#~ "iterations."
#~ msgstr ""
#~ "如果为 True，则在每次迭代后随机键会轮换，从而导致非确定性且可能带有噪声的适应度评估。这意味着相同的策略权重在不同迭代中可能会产生不同的适应度值。"

#~ msgid ""
#~ "If False, the random key remains the same for all iterations, ensuring "
#~ "consistent fitness evaluations."
#~ msgstr "如果为 False，则随机键在所有迭代中保持不变，从而确保适应度评估的一致性。"

#~ msgid ""
#~ "Whether the policy is stateful (for example, RNN). Default to False. If "
#~ "False, the policy should be a pure function with signature "
#~ ":code:`fn(weights, obs) -> action`. If True, the policy should be a stateful"
#~ " function with signature :code:`fn(state, weight, obs) -> action, state`."
#~ msgstr ""
#~ "指示策略是否为有状态的（例如 RNN）。默认为 False。如果为 False，则策略应为具有签名 :code:`fn(weights, obs) ->"
#~ " action` 的纯函数。如果为 True，则策略应为具有签名 :code:`fn(state, weight, obs) -> action, "
#~ "state` 的有状态函数。"

#~ msgid ""
#~ "The initial state of the stateful policy. Default to None. Only used when "
#~ "stateful_policy is True."
#~ msgstr "有状态策略的初始状态。默认为 None，仅在 `stateful_policy` 为 True 时使用。"

#~ msgid ""
#~ "Brax's backend, one of \"generalized\", \"positional\", \"spring\". Default "
#~ "to \"generalized\"."
#~ msgstr "Brax的后端，是“generalized”、“positional”、“spring”中的其中一个。默认为“generalized”。"

#~ msgid ""
#~ "When rotating keys, fitness evaluation is non-deterministic and may "
#~ "introduce noise."
#~ msgstr "在轮换随机键时，适应度评估是非确定性的，可能会引入噪声。"

#~ msgid "The random key."
#~ msgstr "随机键。"

#~ msgid "The weights of the policy."
#~ msgstr "策略的权重。"

#~ msgid "The output type, either \"HTML\" or \"rgb_array\"."
#~ msgstr "输出类型，可以是 \"HTML\" 或 \"rgb_array\"。"

#~ msgid "Whether to respect the done signal."
#~ msgstr "是否遵循环境的完成（done）信号。"

#~ msgid ""
#~ "The number of episodes to visualize, used to override the num_episodes in "
#~ "the constructor. If None, use the num_episodes in the constructor."
#~ msgstr ""

#~ msgid "Env Pool"
#~ msgstr "环境池"

#~ msgid "Gym"
#~ msgstr "Gym"

#~ msgid "Construct a gym problem"
#~ msgstr "构建一个gym 问题"

#~ msgid ""
#~ "A function that accept two arguments the first one is the parameter and the "
#~ "second is the input."
#~ msgstr "一个接受两个参数的函数，第一个参数是参数本身，第二个是输入。"

#~ msgid "Number of worker actors."
#~ msgstr "工作者（worker）actor的数量。"

#~ msgid "The name of the gym environment."
#~ msgstr "Gym环境的名称。"

#~ msgid "The options of the gym environment."
#~ msgstr "gym 环境的选项。"

#~ msgid "A function with zero argument that returns an environment when called."
#~ msgstr "一个调用时返回一个环境的零参数函数。"

#~ msgid ""
#~ "Optional, a list of strings. If set, the environment is treated as a multi-"
#~ "objective problem, and different objective values are obtained through the "
#~ "`info` term returned by Gym. The `mo_keys` parameter provides the keys for "
#~ "accessing the objective values in the info dictionary. The objective values "
#~ "will be returned in the same order as specified in `mo_keys`."
#~ msgstr ""
#~ "可选参数，一个字符串列表。如果设置，环境被视为一个多目标问题，不同的目标值通过Gym返回的`info`项获取。`mo_keys`参数提供了在info字典中访问目标值的键。目标值将按照在`mo_keys`中指定的顺序返回。"

#~ msgid ""
#~ "The runtime options for controller actor. This actor is used to control "
#~ "workers and run the policy at each step. For example, to enable GPU "
#~ "acceleration on the policy network, set this field to::      {\"num_gpus\": "
#~ "1}"
#~ msgstr ""
#~ "控制器 `actor` 的运行时选项。该 `actor` 用于控制工作者并在每一步运行策略。例如，要在策略网络上启用 GPU "
#~ "加速，可将此字段设置为：{\"num_gpus\": 1}"

#~ msgid ""
#~ "The runtime options for controller actor. This actor is used to control "
#~ "workers and run the policy at each step. For example, to enable GPU "
#~ "acceleration on the policy network, set this field to::"
#~ msgstr ""
#~ "控制器actor的运行时选项。这个actor用于控制工作者worker，并在每一步运行策略。例如，要启用策略网络的GPU加速功能，请将此字段设置为::"

#~ msgid "The runtime options for worker actors."
#~ msgstr "工作者（actor）的运行时选项。"

#~ msgid ""
#~ "Visualize your policy, passin a single set of weights, and it will be put in"
#~ " the environment for interaction."
#~ msgstr "可视化您的策略，通过传递一组权重，该策略将会被置于环境中进行互动展示。"

#~ msgid "This key will be used to seed the test environment."
#~ msgstr "此密钥将会作为测试环境的随机数种子。"

#~ msgid "A single set of weights for your policy."
#~ msgstr "策略的一组权重。"

#~ msgid ""
#~ "'rgb_array' or 'human'.  In 'rgb_array' mode, this function will return a "
#~ "list of frames, each frame is a numpy array.  In 'human' mode, the frame "
#~ "should be displayed directly onto your screen. However, if your using remote"
#~ " python environment, for example vscode ssh or jupyter notebook, this method"
#~ " may fail to find a valid display. Default to 'rgb_array'."
#~ msgstr ""
#~ "'rgb_array' 或 'human'。在 'rgb_array' 模式下，此函数将返回一个帧列表，每个帧是一个 numpy 数组。在 "
#~ "'human' 模式下，画面将直接显示在屏幕上。然而，如果您使用的是远程 Python 环境，例如 VSCode SSH 或 Jupyter "
#~ "Notebook，此方法可能无法找到的显示器。默认值为 'rgb_array'。"

#~ msgid "'rgb_array' or 'human'."
#~ msgstr "'rgb_array' 或 'human'。"

#~ msgid ""
#~ "In 'rgb_array' mode, this function will return a list of frames, each frame "
#~ "is a numpy array."
#~ msgstr "在\"rgb_array\"模式下，该函数将返回一个帧列表，每个帧都是一个numpy数组。"

#~ msgid ""
#~ "In 'human' mode, the frame should be displayed directly onto your screen. "
#~ "However, if your using remote python environment, for example vscode ssh or "
#~ "jupyter notebook, this method may fail to find a valid display. Default to "
#~ "'rgb_array'."
#~ msgstr ""
#~ "在\"human\"模式下，帧应直接显示在屏幕上。但是，如果您正在使用远程Python环境（例如VSCode SSH或Jupyter "
#~ "Notebook），这种方法可能无法找到有效的显示器，因此默认设置为\"rgb_array\"模式。"

#~ msgid "Reinforcement Learning"
#~ msgstr "强化学习"

#~ msgid "Tensorflow Dataset"
#~ msgstr "Tensorflow 数据集"

#~ msgid "Wrap a tensorflow dataset as a problem."
#~ msgstr "将 TensorFlow 数据集包装为一个问题。"

#~ msgid ""
#~ "TensorFlow Datasets (TFDS) directly depends on the package `tensorflow-"
#~ "datasets` and `grain`. Additionally, when downloading the dataset for the "
#~ "first time, it requires `tensorflow` to be installed and a active internet "
#~ "connection. If you want to avoid installing `tensorflow`, you can prepare "
#~ "the dataset beforehand in another environment with `tensorflow` installed, "
#~ "run:"
#~ msgstr ""
#~ "TensorFlow Datasets（TFDS）直接依赖于 `tensorflow-datasets` 和 `grain` "
#~ "包。此外，首次下载数据集时，需要安装 `tensorflow` 并具备有效的互联网连接。如果您想避免安装 `tensorflow`，可以在另一个已安装 "
#~ "`tensorflow` 的环境中预先准备好数据集，运行以下命令："

#~ msgid ""
#~ "and then copy the dataset to the target machine. The default location "
#~ "is`~/tensorflow_datasets`. `~/` means the home directory of the user."
#~ msgstr "然后将数据集复制到目标机器。默认位置是 `~/tensorflow_datasets`。`~/` 表示用户的主目录。"

#~ msgid ""
#~ "Please notice that the data is loaded under JAX's jit context, so the data "
#~ "should be valid JAX data type, namely JAX or Numpy arrays, or Python's int, "
#~ "float, list, and dict. If the data contains other types like strings, you "
#~ "should convert them into arrays using the `operations` parameter."
#~ msgstr ""
#~ "请注意，数据是在 JAX 的 `jit` 环境中加载的，所以数据应为有效的 JAX 数据类型，即 JAX / Numpy 数组，或 Python 的 "
#~ "`int`、`float`、`list` 和 `dict`。如果数据包含其他类型（例如字符串），则应使用 `operations` 参数将其转换为数组。"

#~ msgid ""
#~ "You can also download the dataset through a proxy server by setting the "
#~ "environment variable `TFDS_HTTP_PROXY` and `TFDS_HTTPS_PROXY`, for http and "
#~ "https proxy respectively."
#~ msgstr ""
#~ "您还可以通过设置环境变量 `TFDS_HTTP_PROXY` 和 `TFDS_HTTPS_PROXY` 来通过代理服务器下载数据集，分别用于 HTTP "
#~ "和 HTTPS 代理。"

#~ msgid ""
#~ "The details of the dataset can be found at "
#~ "https://www.tensorflow.org/datasets/catalog/overview The details about "
#~ "operations/transformations can be found at "
#~ "https://github.com/google/grain/blob/main/docs/transformations.md"
#~ msgstr ""
#~ "数据集的详细信息可以在 https://www.tensorflow.org/datasets/catalog/overview "
#~ "找到。关于operations/transformations的详细信息可以在 "
#~ "https://github.com/google/grain/blob/main/docs/transformations.md 找到"

#~ msgid ""
#~ "The loss function. The function signature is loss(weights, data) -> "
#~ "loss_value, and it should be jittable. The `weight` is the weight of the "
#~ "neural network, and the `data` is the data from TFDS, which is a dictionary."
#~ msgstr ""
#~ "损失函数。函数签名为 `loss(weights, data) -> loss_value`，并且应支持 `jit` 编译。`weights` "
#~ "是神经网络的权重，`data` 是来自 TFDS 的数据，为一个字典。"

#~ msgid ""
#~ "The list of transformations to apply to the data. Default to []. After the "
#~ "transformations, we will always apply a batch operation to create a batch of"
#~ " data."
#~ msgstr "要应用于数据的转换列表。默认值为 []。在这些转换之后，我们始终会应用批处理操作来创建一个数据批次。"

#~ msgid ""
#~ "The directory to store the dataset. Default to None, which means tensorflow-"
#~ "datasets will automatically determine the directory."
#~ msgstr "存储数据集的目录。默认值为 `None`，表示 tensorflow-datasets 将自动确定目录。"

#~ msgid ""
#~ "The random seed used to seed the dataloader. Given the same seed, the "
#~ "dataloader should data in the same order. Default to 0."
#~ msgstr "用于为数据加载器设置种子的随机数种子。给定相同的种子，数据加载器应以相同的顺序加载数据。默认值为 0。"

#~ msgid ""
#~ "Whether to try to download the dataset from Google Cloud Storage. Usually "
#~ "Google's storage server is faster than the original server of the dataset."
#~ msgstr ""
#~ "是否尝试从 Google Cloud Storage 下载数据集。通常来说，Google 的存储服务器的速度比数据集的原始服务器更快，但是如果您访问 "
#~ "Google Cloud 本身很慢的话则会得不偿失。"

#~ msgid "Numerical Benchmarks"
#~ msgstr "数值基准测试"

#~ msgid "Ackley"
#~ msgstr "Ackley"

#~ msgid "Ackley(a: float = 20, b: float = 0.2, c: float = 6.283185307179586)"
#~ msgstr ""

#~ msgid "Griewank"
#~ msgstr "Griewank"

#~ msgid "Rastrigin"
#~ msgstr "Rastrigin"

#~ msgid "Schwefel"
#~ msgstr "Schwefel"

#~ msgid "Sphere"
#~ msgstr "Sphere"

#~ msgid "CEC2022 Test Suit"
#~ msgstr "CEC2022 测试套件"

#~ msgid ""
#~ "Instantiation format: problem_instance = CEC2022.create(1) i.e., "
#~ "problem_instance = F1_CEC2022()"
#~ msgstr ""
#~ "实例化格式：problem_instance = CEC2022.create(1)，即 problem_instance = F1_CEC2022()"

#~ msgid "Test problems of CEC2022"
#~ msgstr "CEC2022测试问题集"

#~ msgid "DTLZ Test Suit"
#~ msgstr "DTLZ测试套件"

#~ msgid "Test suits"
#~ msgstr "测试套件"

#~ msgid "LSMOP Test Suit"
#~ msgstr "LSMOP测试套件"

#~ msgid "init"
#~ msgstr "init"

#~ msgid "the dimension of decision space"
#~ msgstr "决策空间的维度"

#~ msgid "ref_num * m is the Population of PF"
#~ msgstr "ref_num * m 是 Pareto 前沿（PF）的种群数量"

#~ msgid "MaF Test Suit"
#~ msgstr "MaF测试套件"

#~ msgid "ZDT Test Suit"
#~ msgstr "ZDT测试套件"

#~ msgid "Workflows"
#~ msgstr "工作流"

#~ msgid ""
#~ "Experimental unified workflow, designed to provide unparallel performance "
#~ "for EC workflow."
#~ msgstr "实验中的统一workflow，设计目的是大幅提升EC的性能."

#~ msgid ""
#~ "Provide automatic multi-device (e.g. multiple gpus) computation as well as "
#~ "distributed computation using JAX's native components."
#~ msgstr "提供自动多设备（例如，多个GPU）计算以及使用JAX的原生组件进行分布式计算。"

#~ msgid "Monitor is called using JAX's asynchronous host callback, thus closing"
#~ msgstr "监视器是使用JAX的异步主机回调调用的，因此需要关闭监视器以等待回调完成。"

#~ msgid ""
#~ "Optional monitor(s). Configure a single monitor or a list of monitors. The "
#~ "monitors will be called in the order of the list."
#~ msgstr ""

#~ msgid ""
#~ "The optimization direction, can be either \"min\" or \"max\" or a list of "
#~ "\"min\"/\"max\" to specific the direction for each objective."
#~ msgstr "优化方向，可以是\"min\"（最小化）或\"max\"（最大化），也可以是一个包含\"min\"/\"max\"的列表来指定每个目标的具体优化方向。"

#~ msgid ""
#~ "Optional candidate solution transform function, usually used to decode the "
#~ "candidate solutions into the format that can be understood by the problem. "
#~ "Should be a list of functions, and the functions will be applied in the "
#~ "order of the list. Each function should have the signature "
#~ ":code:`fn(solutions) -> solutions`, where solutions outputed by the EC "
#~ "algorithm."
#~ msgstr ""
#~ "可选的候选解转换函数，通常用于将候选解解码为问题可以理解的格式。应为函数列表，函数将按列表中的顺序依次应用。每个函数的签名应为 "
#~ "`fn(solutions) -> solutions`，其中 `solutions` 是进化计算（EC）算法输出的候选解。"

#~ msgid ""
#~ "Optional fitness transform function. usually used to apply fitness shaping. "
#~ "Should be a list of functions, and the functions will be applied in the "
#~ "order of the list. Each function should have the signature "
#~ ":code:`fn(fitness) -> fitness`, where fitness outputed by the problem."
#~ msgstr ""
#~ "可选的适应度转换函数，通常用于应用适应度整形。应为函数列表，函数将按列表中的顺序依次应用。每个函数的签名应为 `fn(fitness) -> "
#~ "fitness`，其中 `fitness` 是问题输出的适应度。"

#~ msgid ""
#~ "Tell workflow whether the problem is external that cannot be jitted. Default"
#~ " to False."
#~ msgstr "告知工作流问题是否为无法进行 `jit` 编译的外部问题。默认值为 `False`。"

#~ msgid ""
#~ "Whether to automatically call `execute_callbacks` on the state at the end of"
#~ " each step. Default to True."
#~ msgstr "是否在每个步骤结束时自动调用 `execute_callbacks` 处理状态。默认值为True。"

#~ msgid ""
#~ "Number of objectives. Used when external_problem=True. When the problem "
#~ "cannot be jitted, JAX cannot infer the shape, and this field should be "
#~ "manually set. the monitor is needed to wait for the callback to complete."
#~ msgstr ""
#~ "目标数。用于 `external_problem=True` 的情况。当问题无法进行 `jit` 编译时，JAX "
#~ "无法推断目标数，因此应手动设置此字段。监视器需要等待回调完成。"

#~ msgid ""
#~ "Running this notebook requires installing evox, gymnasium, ale-py as well as"
#~ " Pong's image. Due to copy right issues, we cannot distribute the image "
#~ "here. Please follow the instructions [here](https://github.com/Farama-"
#~ "Foundation/AutoROM) to install the image."
#~ msgstr ""
#~ "运行这个文档需要先安装 evox，gymnasium，ale-"
#~ "py以及Pong这个游戏的镜像文件。由于版权问题，我们无法在这里给出游戏镜像文件。请按照这里[AutoROM](https://github.com/Farama-"
#~ "Foundation/AutoROM)的教程安装游戏镜像。"

#~ msgid ""
#~ "This this notebook, we will show how to use the `Algorithm` and `Problem` "
#~ "classes to create a custom algorithm and problem. We will use the one-max "
#~ "problem as an example. The one-max problem is a simple problem where the "
#~ "goal is to maximize the number of ones in a binary string. For example, the "
#~ "string `01011` has a fitness of 3."
#~ msgstr ""
#~ "在这个文档中，我们将会展示如何通过`Algorithm`和`Problem`两个类来写一个自定义的算法和问题。我们将会以one-max问题为例。one-"
#~ "max问题是一个非常简单的问题，这个问题的目标是最大化一个由0或1组成的字符串中1的数量。比如说字符串`01011`的适应度值是3。"

#~ msgid "Classic control with Gym"
#~ msgstr "基于Gym的经典控制问题"

#~ msgid ""
#~ "In this notebook, we will use the Gym to train an agent that solves classic "
#~ "control problems."
#~ msgstr "在这个文档里，我们会借助Gym来训练一个解决经典控制问题的智能体。"

#~ msgid "Now run the workflow. You may see warnings like"
#~ msgstr "现在运行workflow。你可能会看到这样的警报"

#~ msgid ""
#~ "This is expected behaivor, because we have a controller thread that manages "
#~ "a group of Gym workers, and the controller thread does not use GPU."
#~ msgstr "这是预期的行为，因为我们有一个控制器线程来管理一组Gym工作线程，而控制器线程并不使用GPU。"

#~ msgid ""
#~ "If the program stucks, you may want to check whether is `num_workers` is "
#~ "larger than the number of available cores on your computer."
#~ msgstr "如果程序卡住了，你可能需要检查 num_workers 设置的值是否大于你电脑上可用核心的数量。"

#~ msgid "Meta Optimization"
#~ msgstr "数值优化"

#~ msgid ""
#~ "In this notebook, we will use the meta optimization to optimize the "
#~ "hyperparameters of PSO. We will have an outer loop that will optimize the "
#~ "hyperparameters of PSO, and an inner loop that accepts the hyperparameters "
#~ "and runs the PSO algorithm to optimize the Ackley function, the result (cost"
#~ " on the ackley function) will be used as an indicator of how good the "
#~ "hyperparameters are, and this information will be feed to the outer loop to "
#~ "optimize the hyperparameters."
#~ msgstr ""

#~ msgid "Setup the inner loop"
#~ msgstr ""

#~ msgid ""
#~ "The inner loop will be the PSO algorithm that will optimize the Ackley "
#~ "function."
#~ msgstr "我们将创建一个PSO算法和一个Ackley函数来进行证明。"

#~ msgid "Tensorflow datasets in EvoX"
#~ msgstr ""

#~ msgid ""
#~ "Use tensorflow-datasets to load machine learning dataset and train a model "
#~ "in EvoX."
#~ msgstr "使用 `tensorflow-datasets` 加载机器学习数据集并在 EvoX 中训练模型。"

#~ msgid "EvoX is designed around stateful computation."
#~ msgstr "EvoX是围绕着有状态计算设计的。"

#~ msgid ""
#~ "There are two most fundamental classes, namely {class}`Stateful "
#~ "<evox.Stateful>` and {class}`State <evox.State>`."
#~ msgstr ""
#~ "有两个最基本的类，即 {class}`Stateful <evox.Stateful>` 和 {class}`State <evox.State>`。"

#~ msgid ""
#~ "All class that involves stateful computation are inherited from `Stateful`. "
#~ "In EvoX, `Algorithm`, `Problem`, `Operator` and workflows are all stateful."
#~ msgstr ""
#~ "所有涉及状态计算的类都继承自 "
#~ "Stateful。在EvoX中，Algorithm（算法）、Problem（问题）、Operator（操作符）和Workflow（工作流）都是有状态的。"

#~ msgid "The idea behind the design"
#~ msgstr "设计背后的想法"

#~ msgid "hierarchical state"
#~ msgstr "分层状态"

#~ msgid ""
#~ "Here we have five different objects, and notice that they have a "
#~ "hierarchical structure. To work with such structures, at each level, we must"
#~ " \"lift the state\" by managing the states of child components. So, the "
#~ "state at the `workflow` level must contain the state of both `algorithm` and"
#~ " `problem`, and since the state at the `algorithm` level must contain the "
#~ "state of both operators, the state `workflow` level actually needs to handle"
#~ " states from all 5 components."
#~ msgstr ""
#~ "这里我们有五个不同的对象，注意它们具有层次结构。为了处理这种结构，在每个层级我们必须通过管理子组件的状态来“提升状态”。因此，workflow "
#~ "层级的状态必须包含 algorithm（算法）和 problem（问题）的状态，由于 algorithm 层级的状态必须包含所有操作符的状态，所以 "
#~ "workflow 层级的状态实际上需要处理来自所有5个组件的状态。"

#~ msgid ""
#~ "However, it is frustrating to manage the hierarchy manually, and it is not "
#~ "good for modular design. To solve this problem, we introduce `Stateful` and "
#~ "`State`."
#~ msgstr "然而，手动管理这种层次结构是令人沮丧的，而且不利于模块化设计。为了解决这个问题，我们引入了 Stateful 和 State。"

#~ msgid "An Overview of Stateful"
#~ msgstr "关于状态的概述"

#~ msgid ""
#~ "In a `Stateful` class, all immutable data are initialized in `__init__`, or "
#~ "with dataclass, the initial mutable state is generated in `setup`."
#~ msgstr "在 Stateful 类中，所有不可变数据都在 __init__ 中初始化，可变的状态在 setup 中初始化。"

#~ msgid ""
#~ "Notice that all stateful functions should have the following signature:"
#~ msgstr "注意所有的有状态函数需要有以下函数签名："

#~ msgid "which is a common pattern in stateful computation."
#~ msgstr "这是状态计算中常见的模式。"

#~ msgid ""
#~ "Stateful defines the standard for stateful modules in EvoX. All other "
#~ "classes, such as `Algorithm`, `Problem`, and `Workflow`, are inherited from "
#~ "`Stateful`. Then Stateful will provide a `init` method, which we will "
#~ "discuss later."
#~ msgstr ""
#~ "`Stateful` 定义了 EvoX 中有状态模块的标准。所有其他类（如 `Algorithm`、`Problem` 和 "
#~ "`Workflow`）均继承自 `Stateful`。然后，`Stateful` 将提供一个 `init` 方法，我们稍后会讨论。"

#~ msgid "An overview of State"
#~ msgstr "关于状态的概述"

#~ msgid ""
#~ "In EvoX `State` represents a tree of states, which stores the state of the "
#~ "current object and all child objects."
#~ msgstr "在EvoX中，“State”代表一个状态树，它存储当前对象和所有子对象的状态。"

#~ msgid "The structure of `State` is roughly like this:"
#~ msgstr "`State` 的结构大概如如下所示："

#~ msgid ""
#~ "Where `self_state` stores the state of the current object (the one returned "
#~ "by `setup`), and `child_states` stores the states of all child objects. "
#~ "Besides normal dicts as `self_state`, we also support the use of `dataclass`"
#~ " to define the state of the object."
#~ msgstr ""
#~ "其中，`self_state` 存储当前对象的状态（由 setup 返回的对象），而 child_states 存储所有子对象的状态。除了字典作为 "
#~ "self_state 外，我们还支持使用数据类（dataclass）来定义对象的状态。"

#~ msgid "Combined together"
#~ msgstr "结合一起"

#~ msgid ""
#~ "To initialize a hierarchy of Stateful objects, and initialize the state of "
#~ "each object, you could write code like this. You can to call `init` method "
#~ "of the top module. `init` will recursively call the `setup` method of each "
#~ "module, and construct the complete state."
#~ msgstr ""
#~ "要初始化 `Stateful` 对象的层级结构并初始化每个对象的状态，可以编写如下代码。您可以调用顶层模块的 `init` 方法。`init` "
#~ "将递归调用每个模块的 `setup` 方法，并构建完整的状态。"

#~ msgid ""
#~ "When combined together, they will automatically go 1 level down in the tree "
#~ "of states, and merge the subtree back to the current level."
#~ msgstr "当它们组合在一起时，将自动下降到状态树的下一层，并将子树合并回当前层。"

#~ msgid "So you could write code like this."
#~ msgstr "所以你可以这样写代码。"

#~ msgid ""
#~ "Notice that, when calling the method `step`, `state` is the state of the "
#~ "workflow, but when calling `self.algorithm.ask`, `state` behaves like the "
#~ "state of the algorithm, and after the call, the state of the algorithm is "
#~ "automatically merged back into the state of the workflow."
#~ msgstr ""
#~ "请注意，当调用 step 方法时，state 是工作流的状态，但是当调用 self.algorithm.ask 时，state "
#~ "的行为就像是算法的状态，调用之后，算法的状态会自动合并回工作流的状态。"

#~ msgid "Jit-able components"
#~ msgstr "Jit-able 组件"

#~ msgid "A common pitfall in jit"
#~ msgstr "jit中常见的一个陷阱"

#~ msgid ""
#~ "In JAX, it's hard to jump out of a jit-compiled function, meaning if you "
#~ "jit-compile one function, then all other functions used within this function"
#~ " must also be jit-compiled."
#~ msgstr ""
#~ "在 JAX 中，跳出一个 JIT 编译的函数是困难的，这意味着如果你 JIT 编译了一个函数，那么在这个函数内部使用的所有其他函数也必须被 JIT "
#~ "编译。"

#~ msgid "For example, the following code will result in a compilation error."
#~ msgstr "例如，下面的代码将导致编译错误"

#~ msgid ""
#~ "Even though `bar` is not marked with `jax.jit`, it is still compiled as "
#~ "`foo` calls `bar`. And since `bar` uses the dynamic index, which is not "
#~ "compatible with `jax.jit`, an error will occur."
#~ msgstr ""
#~ "尽管 bar 没有被标记为 jax.jit，但由于 foo 调用了 bar，它仍然会被编译。由于 bar 使用了动态索引，这与 jax.jit "
#~ "不兼容，因此会发生错误。"

#~ msgid "Solution"
#~ msgstr "解决方案"

#~ msgid ""
#~ "jit-compile low-level components, and give high-level components more "
#~ "freedom."
#~ msgstr ""

#~ msgid ""
#~ "Use [`host "
#~ "callback`](https://jax.readthedocs.io/en/latest/notebooks/external_callbacks.html)"
#~ " to call a function on CPU in a jit context."
#~ msgstr ""
#~ "在 `jit` 上下文中使用 [`host "
#~ "callback`](https://jax.readthedocs.io/en/latest/notebooks/external_callbacks.html)"
#~ " 在 CPU 上调用函数。"

#~ msgid ""
#~ "In EvoX, we almost guarantee that all low-level components are jit-compiled "
#~ "(all operators), and high-level components (`Workflow`) can have both jit-"
#~ "compiled variants (e.g. {doc}`StdWorkflow </api/workflows/standard>`)."
#~ msgstr ""
#~ "在 EvoX 中，我们几乎可以保证所有低级组件都经过 `jit` 编译（所有操作符），而高级组件（`Workflow`）可以有 `jit` "
#~ "编译的变体（例如 {doc}`StdWorkflow </api/workflows/standard>`）。"

#~ msgid ""
#~ "Please be aware that using callbacks to jump out of the jit context is not "
#~ "free. Data needs to be transferred between CPU and GPU, which can be an "
#~ "overhead."
#~ msgstr "请注意，使用回调跳出 `jit` 上下文并非没有代价。数据需要在 CPU 和 GPU 之间传输，这可能会带来一定的开销。"

#~ msgid "The Algorithm Class"
#~ msgstr "算法类"

#~ msgid ""
#~ "The {class}`Algorithm <evox.Algorithm>` class is inherited from "
#~ "{class}`Stateful <evox.Stateful>`. Besides the things in `Stateful`, you "
#~ "should also implement an `ask` and a `tell` method. In total, there are four"
#~ " methods one needs to implement."
#~ msgstr ""
#~ "{class}`Algorithm <evox.Algorithm>` 类继承自 {class}`Stateful "
#~ "<evox.Stateful>`。除了 Stateful 中的内容外，您还应该实现一个 ask 方法和一个 tell 方法。总共有四个方法需要实现。"

#~ msgid "\\_\\_init\\_\\_"
#~ msgstr "\\_\\_init\\_\\_"

#~ msgid ""
#~ "Initialize hyperparameters that are fixed though out the optimization "
#~ "process, for example, the `population size`."
#~ msgstr "初始化在整个优化过程中固定的超参数，例如，`population size`。"

#~ msgid "{python}`(self, RRNGKey) -> State`"
#~ msgstr "{python}`(self, RRNGKey) -> State`"

#~ msgid "Initialize mutable state, for example the `momentum`."
#~ msgstr "初始化可变状态，例如`momentum`。"

#~ msgid "ask"
#~ msgstr "ask"

#~ msgid "{python}`(self, State) -> Array, State`"
#~ msgstr "{python}`(self, State) -> Array, State`"

#~ msgid "tell"
#~ msgstr "tell"

#~ msgid "{python}`(self, State, Array) -> State`"
#~ msgstr "{python}`(self, State, Array) -> State`"

#~ msgid ""
#~ "Receive the fitness for the candidate population and update the algorithm's "
#~ "state."
#~ msgstr "接收候选种群的适应度并更新算法的状态。"

#~ msgid ""
#~ "Gives initial population for evaluation. The population can have different "
#~ "shape than `ask`."
#~ msgstr "提供用于评估的初始种群。种群的形状可以与`ask`不同。"

#~ msgid ""
#~ "Receive the fitness for the initial population and update the algorithm's "
#~ "state."
#~ msgstr "接收初始种群的适应度并更新算法的状态。"

#~ msgid "Migrate from traditional EC libraries"
#~ msgstr "迁移自传统的EC库"

#~ msgid ""
#~ "There is one thing to notice here, `evaluate` is a stateful function, "
#~ "meaning it should accept a state and return a new state. So, if you are "
#~ "working with numerical benchmark functions, which don't need to be stateful,"
#~ " you can simply ignore the state, but remember that you still have to use "
#~ "this stateful interface."
#~ msgstr ""
#~ "这里有一点需要注意，`evaluate` "
#~ "是一个有状态的函数，这意味着它应该接受一个状态并返回一个新状态。所以，如果你正在处理不需要有状态的数值基准函数，你可以简单地忽略状态，但请记住，你仍然需要使用这个有状态的接口。"

#~ msgid ":python:`(self, ...)`"
#~ msgstr ":python:`(self, ...)`"

#~ msgid ":python:`(self, RRNGKey) -> State`"
#~ msgstr ":python:`(self, RRNGKey) -> State`"

#~ msgid "Initialize mutable state of this problem."
#~ msgstr "初始化这个问题的可变状态。"

#~ msgid ":python:`(self, State, Array) -> Array, State`"
#~ msgstr ":python:`(self, State, Array) -> Array, State`"

#~ msgid "More on the problem's state"
#~ msgstr "关于问题的状态的更多信息"

#~ msgid ""
#~ "If you still wonder what the problem's state actually does, here are the "
#~ "explanations."
#~ msgstr "如果您仍然想知道问题的状态实际上是做什么的，以下是解释。"

#~ msgid ""
#~ "Unlike numerical benchmark functions, real-life problems are more complex "
#~ "and may require stateful computations. Here are some examples:"
#~ msgstr "与数值基准函数不同，现实生活中的问题更加复杂，可能需要有状态的计算。以下是一些例子："

#~ msgid ""
#~ "When dealing with ANN training, we often have the training, validation and "
#~ "testing phases. This implies that the same solution could have different "
#~ "fitness values during different phases. So clearly, we can't model the "
#~ "`evaluate` as a stateless pure function anymore. To implement this "
#~ "mechanism, simply put a value in the state to indicate the phase."
#~ msgstr ""
#~ "在处理人工神经网络(ANN)训练时，我们通常有训练、验证和测试阶段。这意味着同一个解决方案在不同阶段可能有不同的适应度值。因此，显然我们不能再将`evaluate`建模为一个无状态的纯函数。要实现这种机制，只需在状态中放置一个值来指示阶段。"

#~ msgid ""
#~ "Virtual batch norm is an effective trick especially when dealing with RL "
#~ "tasks. To implement this mechanism, the problem must be stateful, as the "
#~ "problem has to remember the initial batch norm parameters during the first "
#~ "run."
#~ msgstr ""
#~ "虚拟批量归一化是一个有效的技巧，特别是在处理强化学习(RL)任务时。要实现这种机制，问题必须是有状态的，因为问题需要记住第一次运行时的初始批量归一化参数。"

#~ msgid ""
#~ "Here we give an example of implementing the OneMax problem, along with a "
#~ "genetic algorithm that solves this problem. The problem itself is "
#~ "straightforward, the fitness is defined as the sum of every digit in a "
#~ "fixed-length bitstring. For example, \"100111\" gives 4 and \"000101\" gives"
#~ " 2."
#~ msgstr ""
#~ "这里我们给出了一个实现 OneMax "
#~ "问题的例子，以及解决这个问题的遗传算法。这个问题本身很直接，适应度定义为固定长度比特串中每个数字的总和。例如，\"100111\" 的适应度是 4，而 "
#~ "\"000101\" 的适应度是 2。"

#~ msgid ""
#~ "Let's start with implementing the OneMax problem. In JAX a bitstring can be "
#~ "easily represented with a tensor of type bool."
#~ msgstr "让我们从实现 OneMax 问题开始。在 JAX 中，比特串可以很容易地用布尔类型的张量来表示。"

#~ msgid ""
#~ "Then we implement a genetic algorithm that uses bitflip mutation and one-"
#~ "point crossover."
#~ msgstr "然后我们实现了一个遗传算法，使用位翻转变异和单点交叉。"

#~ msgid "Write & Build the Documentation"
#~ msgstr "编写并构建文档"

#~ msgid ""
#~ "This documentation is about how to write and build EvoX's documentation."
#~ msgstr "这个文档是关于编写和构建EvoX的文档的。"

#~ msgid ""
#~ "There are mainly two types of documentation in EvoX: **Guide** and **API**. "
#~ "**Guide** is for users who want to learn how to use EvoX, mainly written in "
#~ "jupyter notebook format. **API** is for users/developers who want to know "
#~ "the details of EvoX's code, mainly written as docstrings in the code."
#~ msgstr ""
#~ "在 EvoX 中主要有两种类型的文档：教程（Guide）和API。教程适用于想要学习如何使用 EvoX 的用户，主要以 Jupyter Notebook"
#~ " 的格式编写。API适用于想要了解 EvoX 代码细节的用户/开发者，主要作为代码中的文档字符串（docstring）编写。"

#~ msgid "Multi-language support"
#~ msgstr "多语言支持"

#~ msgid ""
#~ "EvoX's documentation supports multiple languages. Currently, we support "
#~ "English and Chinese."
#~ msgstr "EvoX的文档支持多种语言。目前我们支持英语和中文。"

#~ msgid "Build the documentation in another language"
#~ msgstr "构建此文档的多语言版本"

#~ msgid "You will need to install `sphinx-intl`."
#~ msgstr "您需要安装 `sphinx-intl`。"

#~ msgid "Translate the documentation"
#~ msgstr "翻译文档"

#~ msgid ""
#~ "The translation is hosted on "
#~ "[Weblate](https://hosted.weblate.org/projects/evox/evox/). You can "
#~ "contribute to the translation there."
#~ msgstr ""
#~ "翻译的入口在[Weblate](https://hosted.weblate.org/projects/evox/evox/)。你可以在这里帮助我们翻译文档。"

#~ msgid ""
#~ "`JAX` itself is pure Python, and `jaxlib` provides the C/C++ code. To "
#~ "utilize JAX's hardware acceleration ability, make sure to install the "
#~ "correct `jaxlib` version."
#~ msgstr ""
#~ "`JAX`本身是纯 Python 库，而`jaxlib`则提供了支持加速器的 C/C++ "
#~ "代码。要充分利用JAX的硬件加速能力，必须确保安装了正确的`jaxlib`版本。"

#~ msgid "The correct jaxlib version (the one with accelerator support)."
#~ msgstr "正确的jaxlib版本（有加速器支持的版本）。"

#~ msgid ""
#~ "For more information, e.g. other platforms, please check out JAX's [official"
#~ " installation guide](https://github.com/google/jax/?tab=readme-ov-"
#~ "file#installation)."
#~ msgstr ""
#~ "想要了解更多信息，比如在其他平台上安装的教程，请查阅JAX的[官方安装指南](https://github.com/google/jax/?tab=readme-"
#~ "ov-file#installation)。"

#~ msgid "Video Installation Guide"
#~ msgstr "视频安装教程"

#~ msgid "🎥 [EvoX Installation Guide (Linux)](https://youtu.be/fa2s1Jl-Fy0)"
#~ msgstr "🎥 [EvoX 安装指南 (Linux)](https://www.bilibili.com/video/BV1Zt421c7GN)"

#~ msgid "🎥 [EvoX Installation Guide (Windows)](https://youtu.be/7f8Uz1rqvn8)"
#~ msgstr "🎥 [EvoX 安装指南 (Windows)]( https://www.bilibili.com/video/BV1Bb421h7bG)"

#~ msgid ""
#~ "Currently the easiest way to install JAX with GPU acceleration on Windows is"
#~ " to use the `WSL 2`."
#~ msgstr "目前最简单的在Windows上安装GPU加速版的JAX的方式是使用`WSL 2`。"

#~ msgid ""
#~ "In this notebook, we will guide you through the basic steps of using EvoX."
#~ msgstr "在这个文档中，我们将介绍EvoX的基本使用方法。"

#~ msgid "To demostrate, we will create a PSO algorithm and an Ackley function."
#~ msgstr "我们将创建一个PSO算法和一个Ackley函数来进行证明。"

#~ msgid ""
#~ "Now we want to run the algorithm against the problem. To accomplish this, we"
#~ " need to create a `workflow` which represents the overall process of "
#~ "evolutionary computation."
#~ msgstr "现在我们想要运行针对问题的算法。为了实现这一点，我们需要创建一个代表进化计算整体过程的`workflow`。"

#~ msgid ""
#~ "Since we adopt the functional programming paradigm. We must explicitly "
#~ "initialize and use the state of a module. To initialize, call `init` with a "
#~ "pseudorandom number generators key (PRNGKey)."
#~ msgstr ""
#~ "由于我们采用了函数式编程范式。我们必须显式地初始化并使用模块的状态。要进行初始化，使用伪随机数生成器的键（PRNGKey）调用`init`。"

#~ msgid ""
#~ "The `state` represents the mutatable variables within the whole workflow, "
#~ "including those inside the algorithm and the problem. For example, the "
#~ "`population` in an algorithm is part of the `state`, because it will be "
#~ "changing across iterations."
#~ msgstr ""
#~ "`state`代表整个工作流中的可变变量，包括算法和问题内部的变量。例如，算法中的`population`（种群）是 state "
#~ "的一部分，因为它会在迭代过程中发生变化。"

#~ msgid "Now, call `step` on the workflow to execute one iteration."
#~ msgstr "现在，调用工作流上的 `step` 来执行一个迭代。"

#~ msgid "To run multiple iterations, wrap it inside a for-loop."
#~ msgstr "想要执行多次迭代，只要在这外面套一个for循环即可。"

#~ msgid ""
#~ "Notice that we are passing `state` as an argument of `step` and it returns a"
#~ " new `state`. This is exactly how the stateful computation works in "
#~ "functional programming."
#~ msgstr ""
#~ "请注意，我们将 `state` 作为 `step` 的一个参数传递，并且它返回一个新的 `state`。这正是函数式编程中有状态计算的工作方式。"

#~ msgid ""
#~ "And you may also notice that the `step` doesn't give any feedback, like the "
#~ "result of the optimization. This is because we are missing another component"
#~ " in our workflow. Introducing `monitor`."
#~ msgstr ""
#~ "你可能还会注意到，`step` 并没有提供任何反馈，比如优化的结果。这是因为我们的工作流中缺少另一个组件。这里介绍 `monitor`（监视器）。"

#~ msgid "Monitor"
#~ msgstr "监控器"

#~ msgid "Now, create a \"Evalution monitor\""
#~ msgstr "现在，创建一个“评估监视器”"

#~ msgid ""
#~ "To access the minimum fitness achieved, we use the `monitor` submodule. "
#~ "However, since the `state` variable belongs to the `workflow` variable, it "
#~ "cannot be accessed directly by its submodule, `monitor`. Instead, we need to"
#~ " use the `use_state` wrapper."
#~ msgstr ""
#~ "要访问达到的最小适应度值，我们使用 `monitor` 子模块。然而，由于 `state` 变量属于 `workflow` "
#~ "变量，因此无法直接通过其子模块 `monitor` 访问。所以，我们需要使用 `use_state` 包装器。"

#~ msgid ""
#~ "In EvoX, whenever you want to call a method from a submodule, the "
#~ "`use_state` wrapper is required. This wrapper handles nested submodules at "
#~ "any depth, so you don’t need to worry about the module structure."
#~ msgstr ""
#~ "在 EvoX 中，每当您想从子模块调用方法时，都需要使用 `use_state` 包装器。该包装器能够处理任意深度的嵌套子模块，因此您不必担心模块结构。"

#~ msgid ""
#~ "Execute another 5 iterations, and the minimum fitness will change "
#~ "accordingly."
#~ msgstr "再执行5次迭代，最小适应度将相应改变。"

#~ msgid ""
#~ "It shows the best solution is (-8.6565415e-05,  5.9473794e-05), which is "
#~ "close to the global minimum at (0,0). 🥳"
#~ msgstr "它显示最佳解为 (-8.6565415e-05,  5.9473794e-05)，这接近于全局最小值 (0,0)。🥳"

#~ msgid ""
#~ "Additionally, please note that the best fitness remains the same as last "
#~ "time. This is because we are using the same `key` when initializing the "
#~ "workflow as before. This deterministic behavior in EvoX allows others to "
#~ "easily reproduce your results."
#~ msgstr ""
#~ "另外，请注意最佳适应度与上次相同。这是因为我们在初始化工作流程时使用了与之前相同的 `key`。EvoX中的这种确定性行为使其他人可以轻松复现你的结果。"

#~ msgid ""
#~ "finally, we can use the built-in `plot` function to plot the loss curve."
#~ msgstr "最后，我们可以用自带的`plot`函数绘制损失曲线。"

#~ msgid "Working with extended applications in EvoX is easy."
#~ msgstr "在EvoX中处理扩展应用很简单。"

#~ msgid ""
#~ "Here we will be focusing on neuroevolution tasks, where one need to evolve a"
#~ " neural network that suits a certain tasks."
#~ msgstr "在这里，我们将专注于神经进化任务，其中需要进化出适合特定任务的神经网络。"

#~ msgid "Brax"
#~ msgstr "Brax"

#~ msgid ""
#~ "To begin with we will be using Brax, a GPU accelerated physical engine that "
#~ "is also written in JAX. Since Brax is also using JAX, running EvoX with Brax"
#~ " is quite easy."
#~ msgstr "首先，我们将使用Brax，这是一个用JAX编写的GPU加速物理引擎。由于Brax也使用JAX，因此将EvoX与Brax一起运行相当容易。"

#~ msgid ""
#~ "First we will need to decide how we are going to evolve a neural network. In"
#~ " this case, we will be using a fixed-size ANN, and only evolve it's weights."
#~ msgstr "首先，我们需要决定如何进化神经网络。在这种情况下，我们将使用固定大小的人工神经网络（ANN），并仅进化其权重。"

#~ msgid "`to_vector` can convert a tree into a vector."
#~ msgstr "`to_vector` 可以将树转化成向量形式。"

#~ msgid ""
#~ "`batched_to_tree` can convert a batch of vectors into a batch of trees."
#~ msgstr "`batched_to_tree` 可以将一批向量转换为一批树状结构。"

#~ msgid "Now we can create an algorithm object."
#~ msgstr "现在我们可以创建一个算法对象。"

#~ msgid "Assemble our workflow and fire it!"
#~ msgstr "组装我们的工作流程并启动它！"

#~ msgid ""
#~ "Notice the `solution_transforms` option. It's used to convert the candidate "
#~ "solutions into the tree-like structure that representing a neural network's "
#~ "weight."
#~ msgstr "请注意 `solution_transforms` 选项。该选项用于将候选解转换为表示神经网络权重的树状结构。"

#~ msgid ""
#~ "The algorithm is making progress in optimizing the policy; however, the "
#~ "results are still far from ideal. It's important to remember that this is "
#~ "just a demonstration, and vanilla PSO wasn’t designed for this type of task,"
#~ " so its performance limitations here are expected."
#~ msgstr ""
#~ "该算法在优化策略方面有所进展，但结果仍然远未达到理想状态。需要记住，这只是一个演示，而基础 PSO 并非为此类任务设计，因此在这里性能受限是预料之中的。"

#~ msgid "Distributed Training"
#~ msgstr "分布式训练"

#~ msgid "Parallel Model"
#~ msgstr "MOEA/D算法"

#~ msgid ""
#~ "All states are replicated across all devices including population. Then, on "
#~ "every device, a sharded candidates are passed to `problem.evaluate()`, and "
#~ "the fitnesses are shared across all device (by `all_gather`). This ensures "
#~ "all devices share the same state data without explicit synchronization. In "
#~ "other word, this parallel model only accelerate the problem's evaluation "
#~ "part, and cannot reduce the memory consumption. We use it as our default "
#~ "distributed strategy, as it offers EC algorithms maximum flexibility."
#~ msgstr ""
#~ "所有状态（包括种群）都会在所有设备上进行复制。然后，在每个设备上，将分片的候选解传递给 `problem.evaluate()`，适应度值通过 "
#~ "`all_gather` "
#~ "在所有设备间共享。这确保了所有设备共享相同的状态数据而无需显式同步。换句话说，这种并行模型仅加速了问题的评估部分，无法减少内存消耗。我们将其作为默认的分布式策略，因为它为进化计算（EC）算法提供了最大的灵活性。"

#~ msgid "Multiple devices on a single node"
#~ msgstr ""

#~ msgid "Example:"
#~ msgstr "例子："

#~ msgid "Multiple devices on multiple nodes"
#~ msgstr ""

#~ msgid "Example of script `dist_train.py`"
#~ msgstr "以下是 `dist_train.py` 脚本的示例"

#~ msgid "Run script on each node:"
#~ msgstr "在每个节点上执行此脚本："

#~ msgid ""
#~ "EvoX provides two distributed workflow implementation, one is based on Ray, "
#~ "and the other one is based on jax.distribute."
#~ msgstr "EvoX 提供了两种分布式工作流实现，一种基于 Ray，另一种基于 jax.distribute。"

#~ msgid "RayDistributedWorkflow"
#~ msgstr "RayDistributedWorkflow"

#~ msgid ""
#~ "RayDistributedWorkflow is built upon Ray. It can be used on any ray cluster."
#~ " The Ray cluster should be setup before running the EvoX program."
#~ msgstr ""
#~ "RayDistributedWorkflow是基于Ray构建的。它可以在任何Ray集群上使用。在运行EvoX程序之前，应该先设置Ray集群。"

#~ msgid "Setup Ray cluster"
#~ msgstr "设置Ray集群"

#~ msgid ""
#~ "Please refer to [Ray's official "
#~ "documentation](https://docs.ray.io/en/latest/cluster/getting-started.html) "
#~ "for guide on setting up an Ray cluster."
#~ msgstr ""
#~ "请参考[Ray的官方文档](https://docs.ray.io/en/latest/cluster/getting-"
#~ "started.html)来获取关于设置Ray集群的指南。"

#~ msgid "Here is a simple way to setup the cluster locally."
#~ msgstr "这里有一个简单的本地集群搭建方法。"

#~ msgid "On the head node"
#~ msgstr "在头节点上"

#~ msgid "On worker nodes"
#~ msgstr "在工作节点上"

#~ msgid ""
#~ "If you only have 1 machine, but multiple devices, then there is nothing "
#~ "needs to be done. Ray will setup itself in this case."
#~ msgstr "如果你只有一台机器但是有多个设备，这种情况下，不需要进行别的设置，Ray会自行进行配置。"

#~ msgid "Setup EvoX"
#~ msgstr "设置 EvoX"

#~ msgid ""
#~ "To scale the workflow using multiple machines through Ray, use the "
#~ "{class}`RayDistributedWorkflow <evox.workflows.RayDistributedWorkflow>` "
#~ "instead of StdWorkflow."
#~ msgstr ""
#~ "要通过Ray使用多台机器扩展工作流，请使用 {class}`RayDistributedWorkflow "
#~ "<evox.workflows.RayDistributedWorkflow>` 类替代标准工作流StdWorkflow。"

#~ msgid "First, import `workflows` from evox"
#~ msgstr "首先，从evox中导入'workflows'"

#~ msgid "Now use `RayDistributedWorkflow`"
#~ msgstr "现在使用 `RayDistributedWorkflow`"

#~ msgid ""
#~ "The `RayDistributedWorkflow` also uses the `workflow.step` function to "
#~ "execute iterations. However, under the hood, it employs a distinct approach "
#~ "that allows for the utilization of multiple devices across different "
#~ "machines."
#~ msgstr ""
#~ "`RayDistributedWorkflow`同样运用 "
#~ "`workflow.step`函数来执行迭代过程。然而，在底层实现上，它采用了一种独特的方法，能够跨多台机器利用多个设备。"

#~ msgid ""
#~ "It is recommanded that one set the environment variable "
#~ "`XLA_PYTHON_CLIENT_PREALLOCATE=false`. By default JAX will pre-allocate 80% "
#~ "of the device's memory. This variable disables the GPU memory preallocation,"
#~ " otherwise running multiple JAX processes may cause OOM. For more "
#~ "information, please refer to [JAX's "
#~ "documentation](https://jax.readthedocs.io/en/latest/gpu_memory_allocation.html)"
#~ " on this matter."
#~ msgstr ""
#~ "建议设置环境变量XLA_PYTHON_CLIENT_PREALLOCATE=false。默认情况下，JAX会预先分配设备内存的80%。此变量用于禁用GPU内存预分配，否则运行多个JAX进程可能会导致内存不足（OOM）。有关此事项的更多信息，请参考JAX的文档(https://jax.readthedocs.io/en/latest/gpu_memory_allocation.html)"
#~ " 。"

#~ msgid "StdWorkflow"
#~ msgstr "工作流"

#~ msgid ""
#~ "StdWorkflow is short for \"Universal Workflow\", which aims to use pure JAX "
#~ "to build a workflow that fits any requirement. Since `StdWorkflow` is "
#~ "written in pure JAX, it has less overhead and don't need any additional "
#~ "dependencies."
#~ msgstr ""
#~ "\"StdWorkflow\"是“Standard "
#~ "Workflow”的缩写，其目的是使用纯JAX构建一个适应任何需求的工作流。由于StdWorkflow是用纯JAX编写的，它的开销较小，不需要任何额外的依赖。"

#~ msgid ""
#~ "Use `StdWorkflow` to create an workflow, and use `enable_distributed` and "
#~ "pass in the state to enable this feature."
#~ msgstr "使用`StdWorkflow`创建一个工作流然后使用`enable_distributed`并且传入相应状态来启用此功能。"

#~ msgid ""
#~ "Then, at the start of your program, before any JAX function is called, do "
#~ "this:"
#~ msgstr "在你的程序开始之前进行的任何JAX函数调用，需要做这些操作："

#~ msgid ""
#~ "In this system, the `coordinator` serves as the primary or head node. The "
#~ "total number of participating processes is indicated by `num_process`. The "
#~ "process with `process_id=0` acts as the coordinator."
#~ msgstr ""
#~ "在这个系统中，“coordinator”（协调器）充当主节点或头节点的角色。参与进程的总数由num_process指示。具有process_id=0的进程充当协调器。"

#~ msgid ""
#~ "From more information, please refer to "
#~ "[jax.distributed.initialize](https://jax.readthedocs.io/en/latest/_autosummary/jax.distributed.initialize.html)"
#~ " and [Using JAX in multi-host and multi-process "
#~ "environments](https://jax.readthedocs.io/en/latest/multi_process.html)."
#~ msgstr ""
#~ "有关更多信息，请参考jax.distributed.initialize(https://jax.readthedocs.io/en/latest/_autosummary/jax.distributed.initialize.html)和在多主机和多进程环境中使用JAX的文档(https://jax.readthedocs.io/en/latest/multi_process.html)。"

#~ msgid "Run in a cluster"
#~ msgstr "在一个集群中运行"

#~ msgid ""
#~ "Unlike Ray, JAX's doesn't have the concept of cluster or scheduler. Instead,"
#~ " it offers tools for enabling distributed interactions among multiple JAX "
#~ "instances. JAX follows the SPMD (single program multiple data) paradigm. To "
#~ "initiate a distributed program in JAX, you simply need to run the same "
#~ "script on different machines. For instance, if your program is named "
#~ "`main.py`, you should execute the following command on all participating "
#~ "machines with different `process_id` argument in "
#~ "`jax.distributed.initialize`:"
#~ msgstr ""
#~ "不同于Ray，JAX没有集群或调度器的概念。相反，它提供了工具来实现多个JAX实例之间的分布式交互。JAX遵循SPMD（单程序多数据）范式。要在JAX中启动一个分布式程序，你只需在不同的机器上运行相同的脚本。例如，如果你的程序名为main.py，你应该在所有参与的机器上执行以下命令，并在jax.distributed.initialize中为不同的机器设置不同的process_id参数："

#~ msgid ""
#~ "To have `process_id` in the argument, one can use `argparse` to parse the "
#~ "argument from the commandline. For example:"
#~ msgstr "为了在参数中包含process_id，可以使用argparse库从命令行解析参数。例如："

#~ msgid ""
#~ "Then call `python main.py 0` on the first machine, `python main 1` on the "
#~ "second machine and so on."
#~ msgstr "然后在第一台机器上调用'python main.py 0'，在第二台机器上调用'python main.py 1'，依此类推。"

#~ msgid "Container Algorithms"
#~ msgstr "容器算法"

#~ msgid ""
#~ "Container algorithms are a special type of algorithms that work by "
#~ "containing other algorithms and cannot work on their own. Container "
#~ "algorithms can be used to compose a series of normal algorithms together."
#~ msgstr "容器算法是一种特殊类型的算法，通过包含其他算法来工作，不能单独工作。容器算法可以用来将一系列普通算法组合在一起。"

#~ msgid ""
#~ "We offer Cooperative Coevolution (CC) framework for all algorithms. "
#~ "Currently, there are two types of CC container in EvoX, "
#~ "{class}`evox.algorithms.Coevolution` and "
#~ "{class}`evox.algorithms.VectorizedCoevolution`. The difference is that "
#~ "`VectorizedCoevolution` updates all sub-populations at the same time in each"
#~ " generation, but `Coevolution` follows the traditional approach that updates"
#~ " a single sub-populations at each generation."
#~ msgstr ""
#~ "我们为所有的算法提供了协同演化（CC）框架。目前，再EvoX中有两种类型的CC容器，分别是{class}`evox.algorithms.Coevolution`"
#~ " 和 "
#~ "{class}`evox.algorithms.VectorizedCoevolution`。它们的区别在于，`VectorizedCoevolution`"
#~ " 在每一代中同时更新所有子种群，而 `Coevolution` 则遵循传统方法，在每一代中更新单个子种群。"

#~ msgid ""
#~ "The difference can be illustrated as follows, where $pop1$ and $pop2$ are "
#~ "two sub-populations, and together they form the whole population."
#~ msgstr "区别可以如下所示，其中 $pop1$ 和 $pop2$ 是两个子种群，它们一起组成整个种群。"

#~ msgid "Coevolution:"
#~ msgstr "协同演化："

#~ msgid "VectorizedCoevolution:"
#~ msgstr ""

#~ msgid ""
#~ "Coevolution will update each sub-population one by one, so later sub-"
#~ "population can utilize the most up-to-date information from the previous "
#~ "sub-populations. Vectorized Coevolution on the other hand, updates all sub-"
#~ "populations at the same time, thus gives a more parallelized computation. In"
#~ " conclusion `VectorizedCoevolution` is faster, but `Coevolution` could be "
#~ "better in terms of optimization result with a limited number of evaluations."
#~ msgstr ""
#~ "协同进化将逐个更新每个子种群，因此后续子种群可以利用前面子种群的最新信息。另一方面，向量化协同进化同时更新所有子种群，因此提供了更并行化的计算。总的来说，`VectorizedCoevolution`"
#~ " 更快，但在有限次数的评估中，`Coevolution` 在优化结果方面可能更好。"

#~ msgid "In summary to apply the container algorithm, you need to:"
#~ msgstr "总结来说，应用容器算法的步骤如下："

#~ msgid "Use `Stateful.stack` to stack the base algorithms."
#~ msgstr "使用`Stateful.stack`来堆叠基础算法。"

#~ msgid "Create a container algorithm with the stacked base algorithms."
#~ msgstr "通过一个堆叠的基础算法创建容器算法。"

#~ msgid ""
#~ "Please notice that the coevolution implementation in EvoX is still under "
#~ "development, so there might be some rough edges, and does not reflect the "
#~ "latest research results in the coevolution field."
#~ msgstr "请注意，EvoX 中的协同进化实现仍在开发中，因此可能存在一些不完善之处，并且可能不反映协同进化领域的最新研究结果。"

#~ msgid "High VRAM usage"
#~ msgstr "高显存占用"

#~ msgid ""
#~ "By default, JAX will allocate 75% of the GPU memory regardless of the "
#~ "program you run. This preallocate is used to avoid memory fragmentation and "
#~ "improve performance."
#~ msgstr "默认情况下，无论运行哪个程序，JAX 都将分配 75%的显存。这种预分配是为了避免内存碎片化并提高性能。"

#~ msgid ""
#~ "To disable this behavior, you can use the "
#~ "`XLA_PYTHON_CLIENT_PREALLOCATE=false` environment variable."
#~ msgstr "要禁用此行为，您可以使用 `XLA_PYTHON_CLIENT_PREALLOCATE=false` 环境变量。"

#~ msgid ""
#~ "For more information, please refer to the [JAX "
#~ "documentation](https://jax.readthedocs.io/en/latest/gpu_memory_allocation.html)."
#~ msgstr ""
#~ "更多信息，请参考[JAX文档](https://jax.readthedocs.io/en/latest/gpu_memory_allocation.html)."

#~ msgid ""
#~ "['DE', 'ODE', 'JaDE', 'OpenES', 'CMAES', 'CLPSO', 'CSO', 'DMSPSOEL', "
#~ "'FSPSO', 'PSO', 'SLPSOGS', 'SLP..."
#~ msgstr ""

#~ msgid "['DE', 'ODE', 'JaDE']"
#~ msgstr ""

#~ msgid ""
#~ "Class Methods/home/bill/Source/evoxtorch-"
#~ "main/src/evox/algorithms/de_variants/de.py:35: (INFO/1) Duplicate implicit "
#~ "target name: \"class methods\"."
#~ msgstr ""

#~ msgid ""
#~ "Class Methods/home/bill/Source/evoxtorch-"
#~ "main/src/evox/algorithms/de_variants/jade.py:35: (INFO/1) Duplicate implicit"
#~ " target name: \"class methods\"."
#~ msgstr ""

#~ msgid ""
#~ "Class Methods/home/bill/Source/evoxtorch-"
#~ "main/src/evox/algorithms/de_variants/ode.py:35: (INFO/1) Duplicate implicit "
#~ "target name: \"class methods\"."
#~ msgstr ""

#~ msgid "['OpenES', 'CMAES']"
#~ msgstr ""

#~ msgid ""
#~ "Class Methods/home/bill/Source/evoxtorch-"
#~ "main/src/evox/algorithms/pso_variants/clpso.py:35: (INFO/1) Duplicate "
#~ "implicit target name: \"class methods\"."
#~ msgstr ""

#~ msgid ""
#~ "Class Methods/home/bill/Source/evoxtorch-"
#~ "main/src/evox/algorithms/pso_variants/cso.py:35: (INFO/1) Duplicate implicit"
#~ " target name: \"class methods\"."
#~ msgstr ""

#~ msgid ""
#~ "Class Methods/home/bill/Source/evoxtorch-"
#~ "main/src/evox/algorithms/pso_variants/dms_pso_el.py:35: (INFO/1) Duplicate "
#~ "implicit target name: \"class methods\"."
#~ msgstr ""

#~ msgid ""
#~ "Class Methods/home/bill/Source/evoxtorch-"
#~ "main/src/evox/algorithms/pso_variants/pso.py:35: (INFO/1) Duplicate implicit"
#~ " target name: \"class methods\"."
#~ msgstr ""

#~ msgid ""
#~ "Class Methods/home/bill/Source/evoxtorch-"
#~ "main/src/evox/algorithms/pso_variants/sl_pso_gs.py:35: (INFO/1) Duplicate "
#~ "implicit target name: \"class methods\"."
#~ msgstr ""

#~ msgid ""
#~ "Class Methods/home/bill/Source/evoxtorch-"
#~ "main/src/evox/algorithms/pso_variants/sl_pso_us.py:35: (INFO/1) Duplicate "
#~ "implicit target name: \"class methods\"."
#~ msgstr ""

#~ msgid ""
#~ "Usage:/home/bill/Source/evoxtorch-main/src/evox/core/_vmap_fix.py:247: "
#~ "(INFO/1) Duplicate implicit target name: \"usage:\"."
#~ msgstr ""

#~ msgid ""
#~ "Notice/home/bill/Source/evoxtorch-main/src/evox/core/components.py:47: "
#~ "(INFO/1) Duplicate implicit target name: \"notice\"."
#~ msgstr ""

#~ msgid ""
#~ "Notice/home/bill/Source/evoxtorch-main/src/evox/core/components.py:105: "
#~ "(INFO/1) Duplicate implicit target name: \"notice\"."
#~ msgstr ""

#~ msgid ""
#~ "Vectorize map the given function to its mapped version, see "
#~ "[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html) for "
#~ "more information."
#~ msgstr ""

#~ msgid ""
#~ "Just-In-Time (JIT) compile the given `func` via "
#~ "[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
#~ " (`trace=True`) and "
#~ "[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
#~ " (`trace=False`)."
#~ msgstr ""

#~ msgid ""
#~ "Notice/home/bill/Source/evoxtorch-main/src/evox/core/jit_util.py:123: "
#~ "(INFO/1) Duplicate implicit target name: \"notice\"."
#~ msgstr ""

#~ msgid ""
#~ "Usage:/home/bill/Source/evoxtorch-main/src/evox/core/module.py:220: (INFO/1)"
#~ " Duplicate implicit target name: \"usage:\"."
#~ msgstr ""

#~ msgid ""
#~ "Notice/home/bill/Source/evoxtorch-main/src/evox/core/module.py:228: (INFO/1)"
#~ " Duplicate implicit target name: \"notice\"."
#~ msgstr ""

#~ msgid ""
#~ "Usage/home/bill/Source/evoxtorch-main/src/evox/core/module.py:234: (INFO/1) "
#~ "Duplicate implicit target name: \"usage\"."
#~ msgstr ""

#~ msgid ""
#~ "Notice/home/bill/Source/evoxtorch-main/src/evox/core/module.py:249: (INFO/1)"
#~ " Duplicate implicit target name: \"notice\"."
#~ msgstr ""

#~ msgid ""
#~ "Usage/home/bill/Source/evoxtorch-main/src/evox/core/module.py:266: (INFO/1) "
#~ "Duplicate implicit target name: \"usage\"."
#~ msgstr ""

#~ msgid ""
#~ "Usage/home/bill/Source/evoxtorch-main/src/evox/core/module.py:270: (INFO/1) "
#~ "Duplicate implicit target name: \"usage\"."
#~ msgstr ""

#~ msgid ""
#~ "Examples:/home/bill/Source/evoxtorch-main/src/evox/core/module.py:389: "
#~ "(INFO/1) Duplicate implicit target name: \"examples:\"."
#~ msgstr ""

#~ msgid ""
#~ "Examples:/home/bill/Source/evoxtorch-main/src/evox/core/module.py:396: "
#~ "(INFO/1) Duplicate implicit target name: \"examples:\"."
#~ msgstr ""

#~ msgid ""
#~ "Notice/home/bill/Source/evoxtorch-main/src/evox/core/module.py:581: (INFO/1)"
#~ " Duplicate implicit target name: \"notice\"."
#~ msgstr ""

#~ msgid ""
#~ "Usage:/home/bill/Source/evoxtorch-main/src/evox/core/module.py:584: (INFO/1)"
#~ " Duplicate implicit target name: \"usage:\"."
#~ msgstr ""

#~ msgid ""
#~ "Notice/home/bill/Source/evoxtorch-main/src/evox/core/module.py:619: (INFO/1)"
#~ " Duplicate implicit target name: \"notice\"."
#~ msgstr ""

#~ msgid ""
#~ "Usage:/home/bill/Source/evoxtorch-main/src/evox/core/module.py:623: (INFO/1)"
#~ " Duplicate implicit target name: \"usage:\"."
#~ msgstr ""

#~ msgid ""
#~ "Notice/home/bill/Source/evoxtorch-main/src/evox/core/module.py:636: (INFO/1)"
#~ " Duplicate implicit target name: \"notice\"."
#~ msgstr ""

#~ msgid ""
#~ "Usage:/home/bill/Source/evoxtorch-main/src/evox/core/module.py:640: (INFO/1)"
#~ " Duplicate implicit target name: \"usage:\"."
#~ msgstr ""

#~ msgid ""
#~ "Notice/home/bill/Source/evoxtorch-main/src/evox/core/module.py:663: (INFO/1)"
#~ " Duplicate implicit target name: \"notice\"."
#~ msgstr ""

#~ msgid ""
#~ "Usage:/home/bill/Source/evoxtorch-main/src/evox/core/module.py:668: (INFO/1)"
#~ " Duplicate implicit target name: \"usage:\"."
#~ msgstr ""

#~ msgid "['simulated_binary', 'simulated_binary_half']"
#~ msgstr ""

#~ msgid "['grid_sampling', 'uniform_sampling']"
#~ msgstr ""

#~ msgid ""
#~ "The indicator to use for multi-objective optimization, unused in single-"
#~ "objective optimization. Currently we only support \"IGD\" or \"HV\" for "
#~ "multi-objective optimization. Defaults to None."
#~ msgstr ""

#~ msgid ""
#~ "Usage/home/bill/Source/evoxtorch-main/src/evox/problems/hpo_wrapper.py:99: "
#~ "(INFO/1) Duplicate implicit target name: \"usage\"."
#~ msgstr ""

#~ msgid ""
#~ "['switch', 'clamp', 'clamp_int', 'clamp_float', 'clip', 'maximum', "
#~ "'minimum', 'TracingWhile', 'Traci..."
#~ msgstr ""

#~ msgid ""
#~ "Notice/home/bill/Source/evoxtorch-"
#~ "main/src/evox/utils/jit_fix_operator.py:78: (INFO/1) Duplicate implicit "
#~ "target name: \"notice\"."
#~ msgstr ""

#~ msgid ""
#~ "Notice/home/bill/Source/evoxtorch-"
#~ "main/src/evox/utils/jit_fix_operator.py:84: (INFO/1) Duplicate implicit "
#~ "target name: \"notice\"."
#~ msgstr ""

#~ msgid ""
#~ "Notice/home/bill/Source/evoxtorch-"
#~ "main/src/evox/utils/jit_fix_operator.py:91: (INFO/1) Duplicate implicit "
#~ "target name: \"notice\"."
#~ msgstr ""

#~ msgid ""
#~ "Example/home/bill/Source/evoxtorch-"
#~ "main/src/evox/utils/jit_fix_operator.py:129: (INFO/1) Duplicate implicit "
#~ "target name: \"example\"."
#~ msgstr ""

#~ msgid ""
#~ "Example/home/bill/Source/evoxtorch-"
#~ "main/src/evox/utils/jit_fix_operator.py:142: (INFO/1) Duplicate implicit "
#~ "target name: \"example\"."
#~ msgstr ""

#~ msgid ""
#~ "Example/home/bill/Source/evoxtorch-"
#~ "main/src/evox/utils/jit_fix_operator.py:149: (INFO/1) Duplicate implicit "
#~ "target name: \"example\"."
#~ msgstr ""

#~ msgid ""
#~ "where <type> represents the data type of the field, available types are: "
#~ "\"u8\", \"u16\", \"u32\", \"u64\", \"i16\", \"i32\", \"i64\", \"f16\", "
#~ "\"f32\", \"f64\" The size and offset are in bytes. Note: The magic number is"
#~ " used to identify the file format. 0x65787631 is the byte code for \"exv1\"."
#~ " The binary data blob is a sequence of binary data chunks. In EvoX, the "
#~ "algorithm is allowed to have a different behavior in the first iteration "
#~ "(initialization phase), which can have a different chunk size than the rest "
#~ "of the iterations. Therefore it contains two different schemas for the "
#~ "initial iteration and the rest of the iterations."
#~ msgstr ""

#~ msgid ""
#~ "Usage:/home/bill/Source/evoxtorch-"
#~ "main/src/evox/workflows/std_workflow.py:52: (INFO/1) Duplicate implicit "
#~ "target name: \"usage:\"."
#~ msgstr ""

#~ msgid ""
#~ "Hope you can have fun solving Brax problems in EvoX and enjoy your time!"
#~ msgstr ""

#~ msgid ""
#~ "In this notebook, we will provide a step-by-step tutorial on how to use EvoX"
#~ " to optimize the Ackley function with the Particle Swarm Optimization (PSO) "
#~ "algorithm. Both algorithm and problem are built-in."
#~ msgstr ""

#~ msgid "[`Problem`](#evox.core.components.Problems)"
#~ msgstr ""

#~ msgid ""
#~ "To ensure the function is JIT-compilable, it must meet the conditions "
#~ "outlined in [JIT compoents](#/guide/developer/2-jit-able). In addition to "
#~ "these requirements, the algorithm must also satisfy the following two "
#~ "constraints:"
#~ msgstr ""

#~ msgid ""
#~ "The algorithm should have no methods with in-place operations on the "
#~ "attributes of the algotirhm itself."
#~ msgstr ""

#~ msgid ""
#~ "Here, we'll demonstrate a simple example of how to use HPO with EvoX. We "
#~ "will use the [`PSO`](#PSO) algorithm to search for the optimal "
#~ "hyperparameters of a basic algorithm to solve the sphere problem."
#~ msgstr ""

#~ msgid ""
#~ "We can test whether the [`HPOProblemWrapper`](#HPOProblemWrapper) correctly "
#~ "recognizes the hyperparameters we defined. Since we have made no "
#~ "modifications to the hyperparameters for the 7 instances, they should be "
#~ "identical across all instances."
#~ msgstr ""

#~ msgid ""
#~ "We can also specify our own set of hyperparameter values. Note that the "
#~ "number of hyperparameter sets must match the number of instances in the "
#~ "[`HPOProblemWrapper`](#HPOProblemWrapper). The custom hyperparameters should"
#~ " be provided as a dictionary whose values are wrapped in the "
#~ "[`Parameter`](#Parameter)."
#~ msgstr ""

#~ msgid ""
#~ "Now, we use the [`PSO`](#PSO) algorithm to optimize the hyperparameters of "
#~ "`ExampleAlgorithm`. Note that the population size of the [`PSO`](#PSO) must "
#~ "match the number of instances; otherwise, unexpected errors may occur. In "
#~ "this case, we need to transform the solution in the outer workflow, as the "
#~ "[`HPOProblemWrapper`](#HPOProblemWrapper) requires a dictionary as input."
#~ msgstr ""

#~ msgid ""
#~ "To summarize, you will need the follow 3 things to enable accelerator "
#~ "support:"
#~ msgstr "总结一下，您需要以下3个东西来启用加速器支持："

#~ msgid "GPU driver"
#~ msgstr "GPU驱动"

#~ msgid "CUDA libraries"
#~ msgstr "CUDA库"

#~ msgid "CPU only"
#~ msgstr "纯CPU版"

#~ msgid "CUDA (NVIDIA GPU)"
#~ msgstr "CUDA版 （NVIDIA GPU）"

#~ msgid ""
#~ "To enable CUDA acceleration, please ensure that the following components are"
#~ " installed in a compatible manner:"
#~ msgstr "为了能正确启用 CUDA 加速，请确保以下组件以能够兼容的方式安装："

#~ msgid "If your using any virtualization technology, like WSL, docker."
#~ msgstr "如果你正在使用任何虚拟化技术，例如 WSL 或 Docker。"

#~ msgid ""
#~ "**kernel space components**: should be installed on your host system. For "
#~ "example, if you are using WSL with Windows, then the driver should be "
#~ "installed on Windows, not inside WSL. If you are using container (e.g. "
#~ "docker), then the driver should be installed on your host OS (outside "
#~ "docker)."
#~ msgstr ""
#~ "**内核空间组件**：应安装在您的宿主机系统上。例如，如果您在 Windows 上使用 WSL，则应在 Windows 上安装驱动程序，而不是在 WSL"
#~ " 内部安装。如果您使用容器（例如 Docker），则应在您的宿主机操作系统（Docker 外部）上安装驱动程序。"

#~ msgid "**user space components**: need to be installed inside WSL or docker."
#~ msgstr "**用户空间组件**：需要安装在 WSL 或 Docker 内部。"

#~ msgid "Install NVIDIA's proprietary driver"
#~ msgstr "安装 NVIDIA 的闭源驱动程序"

#~ msgid ""
#~ "Please notice that this step requires administrative privileges and a "
#~ "reboot. So, if you are using a shared server, please contact the server's "
#~ "administrator for support."
#~ msgstr "请注意，这一步会需要管理员权限。所以，如果你在使用一个共享的服务器，请联系服务器的管理员来寻求帮助。"

#~ msgid "GNU/Linux"
#~ msgstr "GNU/Linux"

#~ msgid ""
#~ "If you are on GNU/Linux, I strongly recommend to install the driver via the "
#~ "package manager of your Linux distribution. Please do **NOT** install the "
#~ "driver from NVIDIA's website."
#~ msgstr ""
#~ "如果您使用 GNU/Linux 系统，我强烈建议您通过您的 Linux 发行版的包管理器（比如apt，pacman）来安装驱动程序，而不是从 "
#~ "NVIDIA 的网站下载安装包。"

#~ msgid ""
#~ "Only NVIDIA's proprietary driver works with CUDA, open-source drivers like "
#~ "Nouveau do not."
#~ msgstr "仅有NVIDIA的闭源驱动支持CUDA，像Nouveau这样的开源驱动则不支持。"

#~ msgid ""
#~ "The detailed installation guide depends on your operating system, for "
#~ "example"
#~ msgstr "具体的安装方法取决于您的操作系统，例如"

#~ msgid "ArchLinux"
#~ msgstr "ArchLinux"

#~ msgid "Ubuntu 22.04"
#~ msgstr ""

#~ msgid ""
#~ "NixOS first enable unfree software, and then add the following to your "
#~ "configuration."
#~ msgstr "NixOS首先启用非自由软件，然后添加以下配置。"

#~ msgid "After installing the driver, please reboot."
#~ msgstr "安装完驱动后，请重启电脑。"

#~ msgid "Cluster (e.g. slurm, k8s)"
#~ msgstr "集群（如slurm, k8s）"

#~ msgid ""
#~ "If the latest driver has already been installed in the cluster, please go "
#~ "ahead and skip this section."
#~ msgstr "如果集群中已经安装了最新的驱动，请跳过这个部分并继续。"

#~ msgid ""
#~ "Otherwise, please contact the administrator of the cluster to upgrade the "
#~ "GPU driver version. It is important to note that the driver must be "
#~ "installed on the host system, rendering any effort within the container "
#~ "(e.g. docker, singularity) meaningless. Thus only the administrator can "
#~ "solve this problem."
#~ msgstr ""
#~ "如果没有，请联系集群的管理员来升级GPU驱动版本。需要注意的是，驱动必须安装在宿主系统上，在容器内进行的任何尝试都是无效的。因此只有管理员才能解决这个问题。"

#~ msgid "Install CUDA libraries"
#~ msgstr "安装CUDA库"

#~ msgid ""
#~ "CUDA libraries are user space libraries, so you don't need to reboot after "
#~ "installation. Again, it depends on your operating system, for example"
#~ msgstr "CUDA 库是安装在用户空间的，所以在安装后您不需要重启。 具体的安装方式取决于您的操作系统，例如"

#~ msgid "Now, you can check your do"
#~ msgstr "现在您可以检查您做的"

#~ msgid ""
#~ "to see if your GPU is recognized by the driver. If you see something like "
#~ "this, then you are good to go."
#~ msgstr "查看您的GPU是否被驱动识别。如果您看到类似的信息，那么您可以开始了。"

#~ msgid "Then check your jaxlib version by"
#~ msgstr "之后通过其检查您的jaxlib版本"

#~ msgid ""
#~ "Please make sure you jaxlib's CUDA version is smaller or equal to the CUDA "
#~ "version of this host."
#~ msgstr "请确保您的`jaxlib-cuda`的版本小于或等于机器上的CUDA版本。"

#~ msgid ""
#~ "For example, we have `0.4.18+cuda11.cudnn86` installed, and 11 < 12.2 "
#~ "(displayed by `nvidia-smi`). So we are good to go."
#~ msgstr ""
#~ "例如，我们安装了0.4.18+cuda11.cudnn86版本，且nvidia-smi显示的CUDA版本是11，小于12.2。因此，我们可以开始使用了。"

#~ msgid ""
#~ "Since installing `jax[cuda12]` will usually install the jaxlib compiled with"
#~ " the latest CUDA version. Even if you have CUDA 12, your CUDA version might "
#~ "still be lower than the version of that jaxlib requires. In this case, try "
#~ "to install `jax[cuda11]`."
#~ msgstr ""
#~ "由于安装 jax[cuda12] 通常会安装到使用最新 CUDA 版本编译的 jaxlib，即使您有 CUDA 12，您的 CUDA 版本也可能低于 "
#~ "jaxlib 要求的版本（小版本号不够）。 在这种情况下，请尝试安装 jax[cuda11]。"

#~ msgid "AMD GPU (ROCM)"
#~ msgstr ""

#~ msgid ""
#~ "Despite being considered experimental, installing AMD GPUs for ROCm is "
#~ "surprisingly straightforward thanks to their open-source drivers. However, "
#~ "currently only a limited number of GPUs are supported, notably the Radeon RX"
#~ " 7900XTX and Radeon PRO W7900 for consumer-grade GPUs. Note that Windows is "
#~ "not currently supported."
#~ msgstr ""
#~ "虽然这目前是实验性的支持，由于AMD GPU的驱动是开源的，所以安装AMD "
#~ "GPU的驱动其实很简单。不过，需要注意的是，目前只有一小部分GPU是支持的，其中消费者级的GPU中主要是Radeon RX 7900XTX和Radeon"
#~ " PRO W7900。请注意这目前还不支持Windows。"

#~ msgid "Install GPU driver"
#~ msgstr "安装GPU驱动"

#~ msgid ""
#~ "Since the AMD driver is open-source, installation is simplified: simply "
#~ "install mesa through your Linux distribution's package manager. In many "
#~ "cases, the driver may already be pre-installed."
#~ msgstr ""
#~ "由于AMD的驱动是开源的，所以安装非常简单：只需要通过您的Linux发行版上的包管理器安装mesa这个包。大部分情况下，这个驱动已经被预先安装好了。"

#~ msgid "To verify that the driver is installed, run the following command:"
#~ msgstr "通过以下命令来检查驱动是否安装好了："

#~ msgid "And you should see `amdgpu` in the output."
#~ msgstr "然后你应该能在输出中看到`amdgpu`。"

#~ msgid "Install ROCm"
#~ msgstr "安装ROCm"

#~ msgid ""
#~ "The latest version of ROCm (v5.7.1 or later) may not be available in your "
#~ "Linux distribution's package manager. Therefore, using a containerized "
#~ "environment is the easiest way to get started."
#~ msgstr "由于新版本的ROCm库很可能不在你的Linux发行版的仓库中。所以我们推荐使用容器，这是最简单的方式。"

#~ msgid ""
#~ "Please visit [Docker Hub](https://hub.docker.com/r/rocm/jax) for further "
#~ "instructions."
#~ msgstr "更多的信息，请访问[Docker Hub](https://hub.docker.com/r/rocm/jax)。"

#~ msgid "Verify your installation"
#~ msgstr "验证安装是否正确"

#~ msgid "Here are some possible output:"
#~ msgstr "这里是几种可能的输出结果："

#~ msgid "Correct"
#~ msgstr "正确"

#~ msgid "EvoX not installed"
#~ msgstr "未安装EvoX"

#~ msgid "Wrong jaxlib version"
#~ msgstr "jaxlib版本错误"

#~ msgid "Wrong driver/library"
#~ msgstr "驱动或库版本错误"

#~ msgid "To install EvoX with optional dependencies:"
#~ msgstr "要安装带有可选依赖项的 EvoX："

#~ msgid "Install Pytorch"
#~ msgstr "安装ROCm"

#~ msgid ""
#~ "This guide provides instructions for installing PyTorch under various "
#~ "environments, including CPU-only setups and GPU-accelerated configurations "
#~ "using CUDA or ROCm. PyTorch is available via pip and conda. To install "
#~ "PyTorch, simply run:"
#~ msgstr ""

#~ msgid "Using pip"
#~ msgstr ""

#~ msgid "Using conda"
#~ msgstr ""

#~ msgid ""
#~ "If you’re in China, you can significantly speed up the installation by using"
#~ " the [Tsinghua University "
#~ "mirror](https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/)."
#~ msgstr ""

#~ msgid ""
#~ "Here’s an example of using the mirror to install PyTorch with CUDA support:"
#~ msgstr ""

#~ msgid "Install GPU support for PyTorch"
#~ msgstr ""

#~ msgid ""
#~ "PyTorch can leverage GPU acceleration for significant performance "
#~ "improvement. To enable this, the following components are required:"
#~ msgstr ""

#~ msgid "If you don’t have a compatible GPU or prefer CPU execution:"
#~ msgstr ""

#~ msgid "NVIDIA GPU (CUDA)"
#~ msgstr "CUDA版 （NVIDIA GPU）"

#~ msgid "For GPU support, ensure the following components are installed:"
#~ msgstr ""

#~ msgid "Install NVIDIA GPU Driver"
#~ msgstr "安装英伟达驱动"

#~ msgid ""
#~ "Download the [latest NVIDIA Windows GPU Driver](https://www.nvidia.com/en-"
#~ "us/drivers/) and install it."
#~ msgstr ""
#~ "下载 [最新的NVIDIA Windows "
#~ "GPU驱动](https://www.nvidia.com/Download/index.aspx?lang=en-us)，并安装."

#~ msgid ""
#~ "It is recommended to install the driver using your Linux distribution’s "
#~ "package manager:"
#~ msgstr ""

#~ msgid "Ubuntu:"
#~ msgstr ""

#~ msgid "ArchLinux:"
#~ msgstr "ArchLinux"

#~ msgid "Reboot after installation."
#~ msgstr "验证安装是否正确"

#~ msgid "Install CUDA Libraries"
#~ msgstr "安装CUDA库"

#~ msgid ""
#~ "CUDA libraries are user space components and don’t require a reboot. Install"
#~ " them using your package manager:"
#~ msgstr ""

#~ msgid "Verify installation with:"
#~ msgstr "验证安装是否正确"

#~ msgid "Install PyTorch with CUDA support"
#~ msgstr "安装支持GPU加速的JAX"

#~ msgid "Now, install PyTorch with the appropriate CUDA version:"
#~ msgstr ""

#~ msgid "AMD GPU (ROCm)"
#~ msgstr ""

#~ msgid "Install ROCm using a Docker container for ease:"
#~ msgstr ""

#~ msgid ""
#~ "To confirm your installation, open a Python terminal and run the following:"
#~ msgstr "打开 Python 终端，并运行以下命令："

#~ msgid "Windows with GPU acceleration"
#~ msgstr "Windows上GPU加速"

#~ msgid ""
#~ "EvoX support GPU acceleration through `PyTorch`. There are two ways to use "
#~ "PyTorch with GPU acceleration on Windows:"
#~ msgstr ""

#~ msgid "Directly install PyTorch on Windows, but you won't have `jit` support."
#~ msgstr ""

#~ msgid "WSL 2"
#~ msgstr ""

#~ msgid "Install WSL 2"
#~ msgstr "安装 WSL 2"

#~ msgid ""
#~ "Windows has a detailed guide on how to install WSL 2 "
#~ "[here](https://learn.microsoft.com/en-us/windows/wsl/install)"
#~ msgstr ""
#~ "Windows有一个详细的安装WSL 2的教程在[这里](https://learn.microsoft.com/en-"
#~ "us/windows/wsl/install)"

#~ msgid ""
#~ "The simple way to install a Linux distribution is to use the `Windows Store`"
#~ " and search for the name of the distribution (e.g. ubuntu, debian) and click"
#~ " the install button."
#~ msgstr "简单的安装Linux发行版的方式是去Windows商店，然后搜索发行版的名称并点击安装。"

#~ msgid "Install NVIDIA driver"
#~ msgstr "安装英伟达驱动"

#~ msgid ""
#~ "Go to [here](https://www.nvidia.com/Download/index.aspx), to download the "
#~ "latest NVIDIA Windows GPU Driver, and install it."
#~ msgstr ""
#~ "访问[这里](https://www.nvidia.com/Download/index.aspx)，下载最新的英伟达Windows "
#~ "GPU驱动，并安装。"

#~ msgid "Directly install PyTorch on Windows"
#~ msgstr ""

#~ msgid ""
#~ "You can install PyTorch on Windows by following the instructions on the "
#~ "[PyTorch website](https://pytorch.org/get-started/locally/)."
#~ msgstr ""

#~ msgid "You won't have `jit` support if you install PyTorch on Windows."
#~ msgstr ""

#~ msgid ""
#~ "The key to deploying HPO with EvoX is to transform the "
#~ "[`workflows`](#evox.workflows) into [`problems`](#evox.problems) using the "
#~ "[`HPOProblemWrapper`](#HPOProblemWrapper). Once transformed, we can treat "
#~ "the [`workflows`](#evox.workflows) as standard [`problems`](#evox.problems)."
#~ " The input to the 'HPO problem' consists of the hyperparameters, and the "
#~ "output is the evaluation metrics."
#~ msgstr ""

#~ msgid ""
#~ "To ensure the [`HPOProblemWrapper`](#HPOProblemWrapper) recognizes the "
#~ "hyperparameters, we need to wrap them using [`Parameter`](#Parameter). With "
#~ "this straightforward step, the hyperparameters will be automatically "
#~ "identified."
#~ msgstr ""

#~ msgid ""
#~ "Here, we'll demonstrate a simple example of using EvoX for HPO. "
#~ "Specifically, we will use the [PSO](#PSO) algorithm to optimize the "
#~ "hyperparameters of the [PSO](#PSO) algorithm for solving the sphere problem."
#~ msgstr ""

#~ msgid "Next, we define a simple sphere problem."
#~ msgstr ""

#~ msgid ""
#~ "num_instances: The number of instances to be executed in parallel in the "
#~ "optimization process."
#~ msgstr ""

#~ msgid ""
#~ "workflow: The workflow to be used in the optimization process. Must be "
#~ "wrapped by [`jit_class`](#jit_class)."
#~ msgstr ""

#~ msgid ""
#~ "copy_init_state: Whether to copy the initial state of the workflow for each "
#~ "evaluation. Defaults to `True`. If your workflow contains operations that "
#~ "IN-PLACE modify the tensor(s) in initial state, this should be set to "
#~ "`True`. Otherwise, you can set it to `False` to save memory."
#~ msgstr ""

#~ msgid ""
#~ "We can verify whether the [`HPOProblemWrapper`](#HPOProblemWrapper) "
#~ "correctly recognizes the hyperparameters we define. Since no modifications "
#~ "are made to the hyperparameters across the 5 instances, they should remain "
#~ "identical for all instances."
#~ msgstr ""

#~ msgid ""
#~ "We can also define a custom set of hyperparameter values. It is important to"
#~ " ensure that the number of hyperparameter sets matches the number of "
#~ "instances in the [`HPOProblemWrapper`](#HPOProblemWrapper). Additionally, "
#~ "custom hyperparameters must be provided as a dictionary whose values are "
#~ "wrapped using the [`Parameter`](#Parameter)."
#~ msgstr ""
