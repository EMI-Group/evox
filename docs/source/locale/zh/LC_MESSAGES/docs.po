# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1980, Bill Huang
# This file is distributed under the same license as the EvoX package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: EvoX\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 1980-01-01 00:00+0000\n"
"PO-Revision-Date: 2024-01-18 06:44+0000\n"
"Last-Translator: Shepherd29 <1449405401@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"evox/evox/zh_Hans/>\n"
"Language: zh\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 5.4-dev\n"
"Generated-By: Babel 2.14.0\n"

#: ../../source/api/algorithms/containers/cc.rst:3
#: ../../source/guide/advanced/4-container.md:28
msgid "Cooperative Coevolution"
msgstr "协同演化"

#: evox.algorithms.containers.coevolution.VectorizedCoevolution:2 of
msgid ""
"Automatically apply cooperative coevolution to any algorithm. The process"
" of cooperative coevolution is vectorized, meaning all sub-populations "
"will evolve at the same time in each generation."
msgstr "将协同演化自动应用于任何算法。协同演化的过程被向量化，意味着在每一代中，所有的子种群将同时进化。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.__init__
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.__init__
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell
#: evox.algorithms.containers.coevolution.Coevolution.__init__
#: evox.algorithms.containers.coevolution.Coevolution.setup
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.__init__
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup evox.algorithms.mo.bige.BiGE.setup
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup
#: evox.algorithms.mo.gde3.GDE3.setup evox.algorithms.mo.hype.HypE.setup
#: evox.algorithms.mo.ibea.IBEA.setup evox.algorithms.mo.knea.KnEA.setup
#: evox.algorithms.mo.lmocso.LMOCSO.setup evox.algorithms.mo.moead.MOEAD.setup
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup
#: evox.algorithms.mo.nsga2.NSGA2.setup evox.algorithms.mo.nsga3.NSGA3.setup
#: evox.algorithms.mo.rvea.RVEA.setup evox.algorithms.mo.spea2.SPEA2.setup
#: evox.algorithms.mo.sra.SRA.setup evox.algorithms.mo.tdea.TDEA.setup
#: evox.algorithms.so.de_variants.code.CoDE.setup
#: evox.algorithms.so.de_variants.de.DE.setup
#: evox.algorithms.so.de_variants.jade.JaDE.setup
#: evox.algorithms.so.de_variants.ode.ODE.setup
#: evox.algorithms.so.de_variants.sade.SaDE.setup
#: evox.algorithms.so.de_variants.shade.SHADE.setup
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup
#: evox.algorithms.so.es_variants.ars.ARS.__init__
#: evox.algorithms.so.es_variants.ars.ARS.setup
#: evox.algorithms.so.es_variants.asebo.ASEBO.__init__
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.__init__
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup
#: evox.algorithms.so.es_variants.des.DES.__init__
#: evox.algorithms.so.es_variants.des.DES.setup
#: evox.algorithms.so.es_variants.esmc.ESMC.__init__
#: evox.algorithms.so.es_variants.esmc.ESMC.setup
#: evox.algorithms.so.es_variants.guided_es.GuidedES.__init__
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup
#: evox.algorithms.so.es_variants.les.LES.__init__
#: evox.algorithms.so.es_variants.les.LES.setup
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup
#: evox.algorithms.so.es_variants.ma_es.MAES.setup
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup
#: evox.algorithms.so.es_variants.nes.XNES.setup
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.__init__
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup
#: evox.algorithms.so.es_variants.open_es.OpenES.setup
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.__init__
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup
#: evox.algorithms.so.es_variants.pgpe.PGPE.__init__
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup
#: evox.algorithms.so.es_variants.rmes.RMES.setup
#: evox.algorithms.so.es_variants.snes.SNES.__init__
#: evox.algorithms.so.es_variants.snes.SNES.setup
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup
#: evox.algorithms.so.pso_variants.cpso_s.CPSOS.__init__
#: evox.algorithms.so.pso_variants.cso.CSO.setup
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup
#: evox.algorithms.so.pso_variants.fips.FIPS.__init__
#: evox.algorithms.so.pso_variants.fips.FIPS.ask
#: evox.algorithms.so.pso_variants.fips.FIPS.setup
#: evox.algorithms.so.pso_variants.fips.FIPS.tell
#: evox.algorithms.so.pso_variants.pso.PSO.setup
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.__init__
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell
#: evox.core.algorithm.Algorithm.ask evox.core.algorithm.Algorithm.init_ask
#: evox.core.algorithm.Algorithm.init_tell evox.core.algorithm.Algorithm.tell
#: evox.core.module.Stateful.init evox.core.module.Stateful.setup
#: evox.core.problem.Problem.evaluate evox.core.state.State.__init__
#: evox.core.state.State.find_path_to evox.core.state.State.update
#: evox.metrics.hypervolume.HV.__init__
#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__
#: evox.monitors.std_mo_monitor.StdMOMonitor
#: evox.monitors.std_so_monitor.StdSOMonitor
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.__init__
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.__init__
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup
#: evox.problems.numerical.lsmop.LSMOP1.__init__
#: evox.problems.numerical.lsmop.LSMOP2.__init__
#: evox.problems.numerical.lsmop.LSMOP3.__init__
#: evox.problems.numerical.lsmop.LSMOP4.__init__
#: evox.problems.numerical.lsmop.LSMOP5.__init__
#: evox.problems.numerical.lsmop.LSMOP6.__init__
#: evox.problems.numerical.lsmop.LSMOP7.__init__
#: evox.problems.numerical.lsmop.LSMOP8.__init__
#: evox.problems.numerical.lsmop.LSMOP9.__init__
#: evox.workflows.distributed.RayDistributedWorkflow.__init__
#: evox.workflows.distributed.RayDistributedWorkflow.setup
#: evox.workflows.standard.StdWorkflow.__init__
#: evox.workflows.standard.StdWorkflow.setup
#: evox.workflows.uni_workflow.UniWorkflow.__init__
#: evox.workflows.uni_workflow.UniWorkflow.enable_distributed
#: evox.workflows.uni_workflow.UniWorkflow.enable_multi_devices
#: evox.workflows.uni_workflow.UniWorkflow.setup of
msgid "Parameters"
msgstr "参数"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:2
#: evox.core.algorithm.Algorithm.init_ask:2 of
msgid "Ask the algorithm for the initial population"
msgstr "向算法获取初始化种群"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:4
#: evox.core.algorithm.Algorithm.init_ask:4 of
msgid ""
"Override this method if you need to initialize the population in a "
"special way. For example, Genetic Algorithm needs to evaluate the fitness"
" of the initial population of size N, but after that, it only need to "
"evaluate the fitness of the offspring of size M, and N != M. Since JAX "
"requires the function return to have static shape, we need to have two "
"different functions, one is the normal `ask` and another is `init_ask`."
msgstr ""
"如果您需要以特殊的方式初始化种群，请重写此方法。例如，遗传算法需要评估大小为 N 的初始种群的适应度，但在那之后，它只需要评估大小为 M "
"的后代的适应度，并且 N != M。由于 JAX 要求函数返回具有静态形状，因此我们需要有两个不同的函数，一个是常规的 `ask`，另一个是 "
"`init_ask`。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:9
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:13
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:9
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:9
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:9
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:9
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:9
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:9
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:9
#: evox.core.algorithm.Algorithm.ask:9
#: evox.core.algorithm.Algorithm.init_ask:13
#: evox.core.algorithm.Algorithm.init_tell:9
#: evox.core.algorithm.Algorithm.tell:9 evox.core.problem.Problem.evaluate:8
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:8
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:9
#: evox.workflows.uni_workflow.UniWorkflow.enable_distributed:11
#: evox.workflows.uni_workflow.UniWorkflow.enable_multi_devices:8 of
msgid "**state**"
msgstr "**状态**"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:13
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:9
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:9
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:9
#: evox.core.algorithm.Algorithm.ask:9
#: evox.core.algorithm.Algorithm.init_ask:13 of
msgid "The state of this algorithm."
msgstr "这个算法的状态。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell
#: evox.algorithms.containers.coevolution.Coevolution.setup
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup evox.algorithms.mo.bige.BiGE.setup
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup
#: evox.algorithms.mo.gde3.GDE3.setup evox.algorithms.mo.hype.HypE.setup
#: evox.algorithms.mo.ibea.IBEA.setup evox.algorithms.mo.knea.KnEA.setup
#: evox.algorithms.mo.lmocso.LMOCSO.setup evox.algorithms.mo.moead.MOEAD.setup
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup
#: evox.algorithms.mo.nsga2.NSGA2.setup evox.algorithms.mo.nsga3.NSGA3.setup
#: evox.algorithms.mo.rvea.RVEA.setup evox.algorithms.mo.spea2.SPEA2.setup
#: evox.algorithms.mo.sra.SRA.setup evox.algorithms.mo.tdea.TDEA.setup
#: evox.algorithms.so.de_variants.code.CoDE.setup
#: evox.algorithms.so.de_variants.de.DE.setup
#: evox.algorithms.so.de_variants.jade.JaDE.setup
#: evox.algorithms.so.de_variants.ode.ODE.setup
#: evox.algorithms.so.de_variants.sade.SaDE.setup
#: evox.algorithms.so.de_variants.shade.SHADE.setup
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup
#: evox.algorithms.so.es_variants.ars.ARS.setup
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup
#: evox.algorithms.so.es_variants.des.DES.setup
#: evox.algorithms.so.es_variants.esmc.ESMC.setup
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup
#: evox.algorithms.so.es_variants.les.LES.setup
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup
#: evox.algorithms.so.es_variants.ma_es.MAES.setup
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup
#: evox.algorithms.so.es_variants.nes.XNES.setup
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup
#: evox.algorithms.so.es_variants.open_es.OpenES.setup
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup
#: evox.algorithms.so.es_variants.rmes.RMES.setup
#: evox.algorithms.so.es_variants.snes.SNES.setup
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup
#: evox.algorithms.so.pso_variants.cso.CSO.setup
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup
#: evox.algorithms.so.pso_variants.fips.FIPS.ask
#: evox.algorithms.so.pso_variants.fips.FIPS.setup
#: evox.algorithms.so.pso_variants.fips.FIPS.tell
#: evox.algorithms.so.pso_variants.pso.PSO.setup
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell
#: evox.core.algorithm.Algorithm.ask evox.core.algorithm.Algorithm.init_ask
#: evox.core.algorithm.Algorithm.init_tell evox.core.algorithm.Algorithm.tell
#: evox.core.module.Stateful.init evox.core.module.Stateful.setup
#: evox.core.problem.Problem.evaluate
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup
#: evox.workflows.distributed.RayDistributedWorkflow.setup
#: evox.workflows.standard.StdWorkflow.setup
#: evox.workflows.uni_workflow.UniWorkflow.enable_distributed
#: evox.workflows.uni_workflow.UniWorkflow.enable_multi_devices
#: evox.workflows.uni_workflow.UniWorkflow.setup of
msgid "Returns"
msgstr "返回值"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:14
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:14
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:18
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:14
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:14
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:14
#: evox.core.algorithm.Algorithm.ask:14
#: evox.core.algorithm.Algorithm.init_ask:18 of
msgid "population"
msgstr "种群"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:14
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:14
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:18
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:14
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:14
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:14
#: evox.core.algorithm.Algorithm.ask:14
#: evox.core.algorithm.Algorithm.init_ask:18 of
msgid "The candidate solution."
msgstr "候选解。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:29
#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:29
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:29
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:33
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:29
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:29
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:29
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:29
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:29
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:29
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:29
#: evox.core.algorithm.Algorithm.ask:29
#: evox.core.algorithm.Algorithm.init_ask:33
#: evox.core.algorithm.Algorithm.init_tell:26
#: evox.core.algorithm.Algorithm.tell:29 of
msgid "state"
msgstr "状态"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:17
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:17
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init_ask:21
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:17
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:17
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:17
#: evox.core.algorithm.Algorithm.ask:17
#: evox.core.algorithm.Algorithm.init_ask:21
#: evox.core.problem.Problem.evaluate:16
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:16 of
msgid "The new state of the algorithm."
msgstr "算法的新的状态。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup
#: evox.algorithms.containers.coevolution.Coevolution.setup
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup
#: evox.core.algorithm.Algorithm.ask evox.core.algorithm.Algorithm.init_ask
#: evox.core.algorithm.Algorithm.init_tell evox.core.algorithm.Algorithm.tell
#: evox.core.module.Stateful.__init__ evox.core.module.Stateful.init
#: evox.core.module.Stateful.setup evox.core.problem.Problem.evaluate
#: evox.core.state.State.__init__ evox.core.state.State.find_path_to
#: evox.core.state.State.update
#: evox.workflows.uni_workflow.UniWorkflow.enable_multi_devices of
msgid "Return type"
msgstr "返回值类型"

#: evox.core.algorithm.Algorithm.init_tell:2 of
msgid ""
"Tell the algorithm the fitness of the initial population Use in pair with"
" `init_ask`."
msgstr "告诉算法初始种群的适应度并应该与`init_ask`函数配对使用。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:9
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:9
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:9
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:9
#: evox.core.algorithm.Algorithm.init_tell:9
#: evox.core.algorithm.Algorithm.tell:9 of
msgid "The state of this algorithm"
msgstr "算法的状态"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:17
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:17
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:17
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:17
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:17
#: evox.core.algorithm.Algorithm.init_tell:14
#: evox.core.algorithm.Algorithm.tell:17 of
msgid "The new state of the algorithm"
msgstr "算法的新状态"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:2
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:2
#: evox.algorithms.containers.coevolution.Coevolution.setup:2
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup:2
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup:2
#: evox.algorithms.mo.bige.BiGE.setup:2
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup:2
#: evox.algorithms.mo.gde3.GDE3.setup:2 evox.algorithms.mo.hype.HypE.setup:2
#: evox.algorithms.mo.ibea.IBEA.setup:2 evox.algorithms.mo.knea.KnEA.setup:2
#: evox.algorithms.mo.lmocso.LMOCSO.setup:2
#: evox.algorithms.mo.moead.MOEAD.setup:2
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup:2
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup:2
#: evox.algorithms.mo.nsga2.NSGA2.setup:2
#: evox.algorithms.mo.nsga3.NSGA3.setup:2 evox.algorithms.mo.rvea.RVEA.setup:2
#: evox.algorithms.mo.spea2.SPEA2.setup:2 evox.algorithms.mo.sra.SRA.setup:2
#: evox.algorithms.mo.tdea.TDEA.setup:2
#: evox.algorithms.so.de_variants.code.CoDE.setup:2
#: evox.algorithms.so.de_variants.de.DE.setup:2
#: evox.algorithms.so.de_variants.jade.JaDE.setup:2
#: evox.algorithms.so.de_variants.ode.ODE.setup:2
#: evox.algorithms.so.de_variants.sade.SaDE.setup:2
#: evox.algorithms.so.de_variants.shade.SHADE.setup:2
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup:2
#: evox.algorithms.so.es_variants.ars.ARS.setup:2
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:2
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup:2
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup:2
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup:2
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup:2
#: evox.algorithms.so.es_variants.des.DES.setup:2
#: evox.algorithms.so.es_variants.esmc.ESMC.setup:2
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup:2
#: evox.algorithms.so.es_variants.les.LES.setup:2
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup:2
#: evox.algorithms.so.es_variants.ma_es.MAES.setup:2
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup:2
#: evox.algorithms.so.es_variants.nes.XNES.setup:2
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup:2
#: evox.algorithms.so.es_variants.open_es.OpenES.setup:2
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup:2
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup:2
#: evox.algorithms.so.es_variants.rmes.RMES.setup:2
#: evox.algorithms.so.es_variants.snes.SNES.setup:2
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup:2
#: evox.algorithms.so.pso_variants.cso.CSO.setup:2
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup:2
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:2
#: evox.algorithms.so.pso_variants.pso.PSO.setup:2
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup:2
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup:2
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:2
#: evox.core.module.Stateful.setup:2
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:2
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup:2
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:2
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup:2
#: evox.workflows.distributed.RayDistributedWorkflow.setup:2
#: evox.workflows.standard.StdWorkflow.setup:2
#: evox.workflows.uni_workflow.UniWorkflow.setup:2 of
msgid "Setup mutable state here"
msgstr "在这里设置可变状态"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:4
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:4
#: evox.algorithms.containers.coevolution.Coevolution.setup:4
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup:4
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup:4
#: evox.algorithms.mo.bige.BiGE.setup:4
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup:4
#: evox.algorithms.mo.gde3.GDE3.setup:4 evox.algorithms.mo.hype.HypE.setup:4
#: evox.algorithms.mo.ibea.IBEA.setup:4 evox.algorithms.mo.knea.KnEA.setup:4
#: evox.algorithms.mo.lmocso.LMOCSO.setup:4
#: evox.algorithms.mo.moead.MOEAD.setup:4
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup:4
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup:4
#: evox.algorithms.mo.nsga2.NSGA2.setup:4
#: evox.algorithms.mo.nsga3.NSGA3.setup:4 evox.algorithms.mo.rvea.RVEA.setup:4
#: evox.algorithms.mo.spea2.SPEA2.setup:4 evox.algorithms.mo.sra.SRA.setup:4
#: evox.algorithms.mo.tdea.TDEA.setup:4
#: evox.algorithms.so.de_variants.code.CoDE.setup:4
#: evox.algorithms.so.de_variants.de.DE.setup:4
#: evox.algorithms.so.de_variants.jade.JaDE.setup:4
#: evox.algorithms.so.de_variants.ode.ODE.setup:4
#: evox.algorithms.so.de_variants.sade.SaDE.setup:4
#: evox.algorithms.so.de_variants.shade.SHADE.setup:4
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup:4
#: evox.algorithms.so.es_variants.ars.ARS.setup:4
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:4
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup:4
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup:4
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup:4
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup:4
#: evox.algorithms.so.es_variants.des.DES.setup:4
#: evox.algorithms.so.es_variants.esmc.ESMC.setup:4
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup:4
#: evox.algorithms.so.es_variants.les.LES.setup:4
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup:4
#: evox.algorithms.so.es_variants.ma_es.MAES.setup:4
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup:4
#: evox.algorithms.so.es_variants.nes.XNES.setup:4
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup:4
#: evox.algorithms.so.es_variants.open_es.OpenES.setup:4
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup:4
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup:4
#: evox.algorithms.so.es_variants.rmes.RMES.setup:4
#: evox.algorithms.so.es_variants.snes.SNES.setup:4
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup:4
#: evox.algorithms.so.pso_variants.cso.CSO.setup:4
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup:4
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:4
#: evox.algorithms.so.pso_variants.pso.PSO.setup:4
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup:4
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup:4
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:4
#: evox.core.module.Stateful.setup:4
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:4
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup:4
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:4
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup:4
#: evox.workflows.distributed.RayDistributedWorkflow.setup:4
#: evox.workflows.standard.StdWorkflow.setup:4
#: evox.workflows.uni_workflow.UniWorkflow.setup:4 of
msgid ""
"The state it self is immutable, but it act as a mutable state by "
"returning new state each time."
msgstr "状态本身是不可变的，但是你可以通过生成一个新的状态来实现修改的操作。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:10
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:10
#: evox.algorithms.containers.coevolution.Coevolution.setup:10
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup:10
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup:10
#: evox.algorithms.mo.bige.BiGE.setup:10
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup:10
#: evox.algorithms.mo.gde3.GDE3.setup:10 evox.algorithms.mo.hype.HypE.setup:10
#: evox.algorithms.mo.ibea.IBEA.setup:10 evox.algorithms.mo.knea.KnEA.setup:10
#: evox.algorithms.mo.lmocso.LMOCSO.setup:10
#: evox.algorithms.mo.moead.MOEAD.setup:10
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup:10
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup:10
#: evox.algorithms.mo.nsga2.NSGA2.setup:10
#: evox.algorithms.mo.nsga3.NSGA3.setup:10
#: evox.algorithms.mo.rvea.RVEA.setup:10
#: evox.algorithms.mo.spea2.SPEA2.setup:10 evox.algorithms.mo.sra.SRA.setup:10
#: evox.algorithms.mo.tdea.TDEA.setup:10
#: evox.algorithms.so.de_variants.code.CoDE.setup:10
#: evox.algorithms.so.de_variants.de.DE.setup:10
#: evox.algorithms.so.de_variants.jade.JaDE.setup:10
#: evox.algorithms.so.de_variants.ode.ODE.setup:10
#: evox.algorithms.so.de_variants.sade.SaDE.setup:10
#: evox.algorithms.so.de_variants.shade.SHADE.setup:10
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup:10
#: evox.algorithms.so.es_variants.ars.ARS.setup:10
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:10
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup:10
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup:10
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup:10
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup:10
#: evox.algorithms.so.es_variants.des.DES.setup:10
#: evox.algorithms.so.es_variants.esmc.ESMC.setup:10
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup:10
#: evox.algorithms.so.es_variants.les.LES.setup:10
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup:10
#: evox.algorithms.so.es_variants.ma_es.MAES.setup:10
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup:10
#: evox.algorithms.so.es_variants.nes.XNES.setup:10
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup:10
#: evox.algorithms.so.es_variants.open_es.OpenES.setup:10
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup:10
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup:10
#: evox.algorithms.so.es_variants.rmes.RMES.setup:10
#: evox.algorithms.so.es_variants.snes.SNES.setup:10
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup:10
#: evox.algorithms.so.pso_variants.cso.CSO.setup:10
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup:10
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:10
#: evox.algorithms.so.pso_variants.pso.PSO.setup:10
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup:10
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup:10
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:10
#: evox.core.module.Stateful.init:9 evox.core.module.Stateful.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:12
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup:10
#: evox.workflows.distributed.RayDistributedWorkflow.setup:10
#: evox.workflows.standard.StdWorkflow.setup:10
#: evox.workflows.uni_workflow.UniWorkflow.setup:10 of
msgid "**key**"
msgstr "**随机数生成器密钥**"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:10
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:9
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:10
#: evox.algorithms.containers.coevolution.Coevolution.setup:10
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup:10
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup:10
#: evox.algorithms.mo.bige.BiGE.setup:10
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup:10
#: evox.algorithms.mo.gde3.GDE3.setup:10 evox.algorithms.mo.hype.HypE.setup:10
#: evox.algorithms.mo.ibea.IBEA.setup:10 evox.algorithms.mo.knea.KnEA.setup:10
#: evox.algorithms.mo.lmocso.LMOCSO.setup:10
#: evox.algorithms.mo.moead.MOEAD.setup:10
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup:10
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup:10
#: evox.algorithms.mo.nsga2.NSGA2.setup:10
#: evox.algorithms.mo.nsga3.NSGA3.setup:10
#: evox.algorithms.mo.rvea.RVEA.setup:10
#: evox.algorithms.mo.spea2.SPEA2.setup:10 evox.algorithms.mo.sra.SRA.setup:10
#: evox.algorithms.mo.tdea.TDEA.setup:10
#: evox.algorithms.so.de_variants.code.CoDE.setup:10
#: evox.algorithms.so.de_variants.de.DE.setup:10
#: evox.algorithms.so.de_variants.jade.JaDE.setup:10
#: evox.algorithms.so.de_variants.ode.ODE.setup:10
#: evox.algorithms.so.de_variants.sade.SaDE.setup:10
#: evox.algorithms.so.de_variants.shade.SHADE.setup:10
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup:10
#: evox.algorithms.so.es_variants.ars.ARS.setup:10
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:10
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup:10
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup:10
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup:10
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup:10
#: evox.algorithms.so.es_variants.des.DES.setup:10
#: evox.algorithms.so.es_variants.esmc.ESMC.setup:10
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup:10
#: evox.algorithms.so.es_variants.les.LES.setup:10
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup:10
#: evox.algorithms.so.es_variants.ma_es.MAES.setup:10
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup:10
#: evox.algorithms.so.es_variants.nes.XNES.setup:10
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup:10
#: evox.algorithms.so.es_variants.open_es.OpenES.setup:10
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup:10
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup:10
#: evox.algorithms.so.es_variants.rmes.RMES.setup:10
#: evox.algorithms.so.es_variants.snes.SNES.setup:10
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup:10
#: evox.algorithms.so.pso_variants.cso.CSO.setup:10
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup:10
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:10
#: evox.algorithms.so.pso_variants.pso.PSO.setup:10
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup:10
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup:10
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:10
#: evox.core.module.Stateful.init:9 evox.core.module.Stateful.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup:10
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:10
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup:10
#: evox.workflows.distributed.RayDistributedWorkflow.setup:10
#: evox.workflows.standard.StdWorkflow.setup:10
#: evox.workflows.uni_workflow.UniWorkflow.setup:10 of
msgid "A PRNGKey."
msgstr "一个伪随机数生成器密钥。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:27
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:26
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:27
#: evox.algorithms.containers.coevolution.Coevolution.setup:27
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup:27
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup:27
#: evox.algorithms.mo.bige.BiGE.setup:27
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup:27
#: evox.algorithms.mo.gde3.GDE3.setup:27 evox.algorithms.mo.hype.HypE.setup:27
#: evox.algorithms.mo.ibea.IBEA.setup:27 evox.algorithms.mo.knea.KnEA.setup:27
#: evox.algorithms.mo.lmocso.LMOCSO.setup:27
#: evox.algorithms.mo.moead.MOEAD.setup:27
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup:27
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup:27
#: evox.algorithms.mo.nsga2.NSGA2.setup:27
#: evox.algorithms.mo.nsga3.NSGA3.setup:27
#: evox.algorithms.mo.rvea.RVEA.setup:27
#: evox.algorithms.mo.spea2.SPEA2.setup:27 evox.algorithms.mo.sra.SRA.setup:27
#: evox.algorithms.mo.tdea.TDEA.setup:27
#: evox.algorithms.so.de_variants.code.CoDE.setup:27
#: evox.algorithms.so.de_variants.de.DE.setup:27
#: evox.algorithms.so.de_variants.jade.JaDE.setup:27
#: evox.algorithms.so.de_variants.ode.ODE.setup:27
#: evox.algorithms.so.de_variants.sade.SaDE.setup:27
#: evox.algorithms.so.de_variants.shade.SHADE.setup:27
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup:27
#: evox.algorithms.so.es_variants.ars.ARS.setup:27
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:27
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup:27
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup:27
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup:27
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup:27
#: evox.algorithms.so.es_variants.des.DES.setup:27
#: evox.algorithms.so.es_variants.esmc.ESMC.setup:27
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup:27
#: evox.algorithms.so.es_variants.les.LES.setup:27
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup:27
#: evox.algorithms.so.es_variants.ma_es.MAES.setup:27
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup:27
#: evox.algorithms.so.es_variants.nes.XNES.setup:27
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup:27
#: evox.algorithms.so.es_variants.open_es.OpenES.setup:27
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup:27
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup:27
#: evox.algorithms.so.es_variants.rmes.RMES.setup:27
#: evox.algorithms.so.es_variants.snes.SNES.setup:27
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup:27
#: evox.algorithms.so.pso_variants.cso.CSO.setup:27
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup:27
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:27
#: evox.algorithms.so.pso_variants.pso.PSO.setup:27
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup:27
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup:27
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:27
#: evox.core.module.Stateful.init:26 evox.core.module.Stateful.setup:27
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:27
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup:27
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:27
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup:27
#: evox.workflows.distributed.RayDistributedWorkflow.setup:27
#: evox.workflows.standard.StdWorkflow.setup:27
#: evox.workflows.uni_workflow.UniWorkflow.enable_distributed:28
#: evox.workflows.uni_workflow.UniWorkflow.enable_multi_devices:29
#: evox.workflows.uni_workflow.UniWorkflow.setup:27 of
msgid "State"
msgstr "状态"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.setup:15
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.setup:15
#: evox.algorithms.containers.coevolution.Coevolution.setup:15
#: evox.algorithms.containers.coevolution.VectorizedCoevolution.setup:15
#: evox.algorithms.mo.bce_ibea.BCEIBEA.setup:15
#: evox.algorithms.mo.bige.BiGE.setup:15
#: evox.algorithms.mo.eagmoead.EAGMOEAD.setup:15
#: evox.algorithms.mo.gde3.GDE3.setup:15 evox.algorithms.mo.hype.HypE.setup:15
#: evox.algorithms.mo.ibea.IBEA.setup:15 evox.algorithms.mo.knea.KnEA.setup:15
#: evox.algorithms.mo.lmocso.LMOCSO.setup:15
#: evox.algorithms.mo.moead.MOEAD.setup:15
#: evox.algorithms.mo.moeaddra.MOEADDRA.setup:15
#: evox.algorithms.mo.moeadm2m.MOEADM2M.setup:15
#: evox.algorithms.mo.nsga2.NSGA2.setup:15
#: evox.algorithms.mo.nsga3.NSGA3.setup:15
#: evox.algorithms.mo.rvea.RVEA.setup:15
#: evox.algorithms.mo.spea2.SPEA2.setup:15 evox.algorithms.mo.sra.SRA.setup:15
#: evox.algorithms.mo.tdea.TDEA.setup:15
#: evox.algorithms.so.de_variants.code.CoDE.setup:15
#: evox.algorithms.so.de_variants.de.DE.setup:15
#: evox.algorithms.so.de_variants.jade.JaDE.setup:15
#: evox.algorithms.so.de_variants.ode.ODE.setup:15
#: evox.algorithms.so.de_variants.sade.SaDE.setup:15
#: evox.algorithms.so.de_variants.shade.SHADE.setup:15
#: evox.algorithms.so.es_variants.amalgam.IndependentAMaLGaM.setup:15
#: evox.algorithms.so.es_variants.ars.ARS.setup:15
#: evox.algorithms.so.es_variants.asebo.ASEBO.setup:15
#: evox.algorithms.so.es_variants.cma_es.CMAES.setup:15
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.setup:15
#: evox.algorithms.so.es_variants.cma_es.SepCMAES.setup:15
#: evox.algorithms.so.es_variants.cr_fm_nes.CR_FM_NES.setup:15
#: evox.algorithms.so.es_variants.des.DES.setup:15
#: evox.algorithms.so.es_variants.esmc.ESMC.setup:15
#: evox.algorithms.so.es_variants.guided_es.GuidedES.setup:15
#: evox.algorithms.so.es_variants.les.LES.setup:15
#: evox.algorithms.so.es_variants.ma_es.LMMAES.setup:15
#: evox.algorithms.so.es_variants.ma_es.MAES.setup:15
#: evox.algorithms.so.es_variants.nes.SeparableNES.setup:15
#: evox.algorithms.so.es_variants.nes.XNES.setup:15
#: evox.algorithms.so.es_variants.noise_reuse_es.Noise_reuse_es.setup:15
#: evox.algorithms.so.es_variants.open_es.OpenES.setup:15
#: evox.algorithms.so.es_variants.persistent_es.PersistentES.setup:15
#: evox.algorithms.so.es_variants.pgpe.PGPE.setup:15
#: evox.algorithms.so.es_variants.rmes.RMES.setup:15
#: evox.algorithms.so.es_variants.snes.SNES.setup:15
#: evox.algorithms.so.pso_variants.clpso.CLPSO.setup:15
#: evox.algorithms.so.pso_variants.cso.CSO.setup:15
#: evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL.setup:15
#: evox.algorithms.so.pso_variants.fips.FIPS.setup:15
#: evox.algorithms.so.pso_variants.pso.PSO.setup:15
#: evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS.setup:15
#: evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS.setup:15
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.setup:15
#: evox.core.module.Stateful.setup:15
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.setup:15
#: evox.problems.neuroevolution.reinforcement_learning.env_pool.EnvPool.setup:15
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.setup:15
#: evox.problems.neuroevolution.supervised_learning.torchvision_dataset.TorchvisionDataset.setup:15
#: evox.workflows.distributed.RayDistributedWorkflow.setup:15
#: evox.workflows.standard.StdWorkflow.setup:15
#: evox.workflows.uni_workflow.UniWorkflow.setup:15 of
msgid "The state of this module."
msgstr "这个模块的状态。"

#: evox.algorithms.containers.coevolution.Coevolution:2 of
msgid ""
"Automatically apply cooperative coevolution to any algorithm. The process"
" of cooperative coevolution is not vectorized, meaning all sub-"
"populations will evolve one at a time (round-robin) in each generation."
msgstr "将协同演化自动应用于任何算法。协同演化的过程未被向量化，这意味着在每一代中，所有子种群将逐一（轮流）进行进化。"

#: ../../source/api/algorithms/containers/clustered.rst:3
msgid "Clustered Algorithm"
msgstr "聚类算法"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm:2 of
msgid ""
"A container that split the encoding into subproblems, and run an "
"Algorithm on each."
msgstr "一个容器，它将编码分割成若干子问题，并在每个子问题上运行一个算法。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm:4 of
msgid ""
"Can take in any base algorithm, split the problem into n different sub-"
"problems and solve each problem using the base algorithm. Dim must be a "
"multiple of num_cluster, and num_cluster must be a multiple of num_gpus."
msgstr ""
"能够接收任何基础算法，将问题分割成 n "
"个不同的子问题，并使用基础算法解决每个子问题。其中，维度（Dim）必须是簇数量（num_cluster）的倍数，而簇数量（num_cluster）必须是"
" GPU 数量（num_gpus）的倍数。"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:2
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:2
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:2
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:2
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:2
#: evox.core.algorithm.Algorithm.ask:2 of
msgid "Ask the algorithm"
msgstr "询问这个算法"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.ask:4
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.ask:4
#: evox.algorithms.so.es_variants.asebo.ASEBO.ask:4
#: evox.algorithms.so.pso_variants.fips.FIPS.ask:4
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.ask:4
#: evox.core.algorithm.Algorithm.ask:4 of
msgid "Ask the algorithm for points to explore"
msgstr "向算法询问要探索的点"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:2
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:2
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:2
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:2
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:2
#: evox.core.algorithm.Algorithm.tell:2 of
msgid "Tell the algorithm more information"
msgstr "告诉算法更多的信息"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:4
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:4
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:4
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:4
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:4
#: evox.core.algorithm.Algorithm.tell:4 of
msgid ""
"Tell the algorithm about the points it chose and their corresponding "
"fitness"
msgstr "告诉算法它选择的点以及它们对应的适应度"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:12
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:12
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:12
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:12
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:12
#: evox.core.algorithm.Algorithm.tell:12 of
msgid "**fitness**"
msgstr "**适应度**"

#: evox.algorithms.containers.clustered_algorithm.ClusterdAlgorithm.tell:12
#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.tell:12
#: evox.algorithms.so.es_variants.asebo.ASEBO.tell:12
#: evox.algorithms.so.pso_variants.fips.FIPS.tell:12
#: evox.algorithms.so.pso_variants.swmmpso.SwmmPSO.tell:12
#: evox.core.algorithm.Algorithm.tell:12 of
msgid "The fitness"
msgstr "适应度值"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm:2 of
msgid "Cluster container with random mask"
msgstr "带有随机掩码的簇容器"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm:4 of
msgid ""
"pop_size is needed, because JAX needs static shape, if pop_size is None, "
"it will try to read pop_size from base_algorithm"
msgstr "需要指定种群大小（pop_size），因为 JAX 需要静态形状，如果种群大小（pop_size）未设定，系统将尝试从基础算法中读取种群大小"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:2
#: evox.core.module.Stateful.init:2 of
msgid "Initialize this module and all submodules"
msgstr "初始化这个模块和所有的子模块"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:4
#: evox.core.module.Stateful.init:4 of
msgid "This method should not be overwritten."
msgstr "此方法不应被复写。"

#: evox.algorithms.containers.clustered_algorithm.RandomMaskAlgorithm.init:14
#: evox.core.module.Stateful.init:14 of
msgid "The state of this module and all submodules combined."
msgstr "该模块及其所有子模块的组合之和。"

#: ../../source/api/algorithms/containers/index.rst:3
msgid "Containers"
msgstr "容器"

#: ../../source/api/algorithms/containers/tree.rst:3
msgid "Tree Algorithm"
msgstr "树算法"

#: ../../source/api/algorithms/index.rst:3
msgid "Algorithms"
msgstr "算法"

#: evox.algorithms:1 of
msgid ""
"The module that contains all pre-defined algorithms, including both "
"single-objective algorithms and multi-objective algorithms."
msgstr "包含所有预定义算法的模块，包括单目标算法和多目标算法。"

#: ../../source/api/algorithms/mo/bce_ibea.rst:3
msgid "BCEIBEA"
msgstr "BCEIBEA"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:2 of
msgid "Bi-criterion evolution based IBEA"
msgstr "Bi-criterion evolution based IBEA"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:4 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/7347391"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/7347391"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:6 of
msgid ""
"Note: The number of outer iterations needs to be set to Maximum "
"Generation*2+1."
msgstr "注意：外部迭代次数需要设置为最大代数（Maximum Generation）的两倍加一。"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:25 evox.algorithms.mo.ibea.IBEA:21
#: evox.algorithms.mo.lmocso.LMOCSO:23 evox.algorithms.mo.rvea.RVEA:24 of
msgid "Args:"
msgstr "参数："

#: evox.algorithms.mo.bce_ibea.BCEIBEA:25 of
msgid ""
"kappa (float, optional): The scaling factor for selecting parents in the "
"environmental selection."
msgstr "kappa（浮点型，可选）：环境选择中用于选择父代的缩放因子。"

#: evox.algorithms.mo.bce_ibea.BCEIBEA:10 of
msgid ""
"It controls the probability of selecting parents based on their fitness "
"values. Defaults to 0.05."
msgstr "它控制了基于个体适应度值选择父代的概率。默认值为0.05。"

#: ../../source/api/algorithms/mo/bige.rst:3
msgid "BiGE"
msgstr "BiGE"

#: evox.algorithms.mo.bige.BiGE:2 of
msgid "BiGE algorithm"
msgstr "BiGE算法"

#: evox.algorithms.mo.bige.BiGE:4 of
msgid "link: https://doi.org/10.1016/j.artint.2015.06.007"
msgstr "链接：https://doi.org/10.1016/j.artint.2015.06.007"

#: ../../source/api/algorithms/mo/eagmoead.rst:3
msgid "EAG-MOEA/D"
msgstr "EAG-MOEA/D"

#: evox.algorithms.mo.eagmoead.EAGMOEAD:2 of
msgid "EAG-MOEA/D algorithm"
msgstr "EAG-MOEA/D算法"

#: evox.algorithms.mo.eagmoead.EAGMOEAD:4 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/6882229"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/6882229"

#: ../../source/api/algorithms/mo/gde3.rst:3
msgid "GDE3"
msgstr "GDE3"

#: evox.algorithms.mo.gde3.GDE3:2 of
msgid "GDE3 algorithm"
msgstr "GDE3算法"

#: evox.algorithms.mo.gde3.GDE3:4 of
msgid "link: https://ieeexplore.ieee.org/document/1554717"
msgstr "链接：https://ieeexplore.ieee.org/document/1554717"

#: evox.algorithms.mo.gde3.GDE3.__init__:3 of
msgid "Parameters for Differential Evolution"
msgstr "差分演化的参数"

#: evox.algorithms.mo.gde3.GDE3.__init__:4 of
msgid "F"
msgstr "F"

#: evox.algorithms.mo.gde3.GDE3.__init__:5 of
msgid "The scaling factor"
msgstr "缩放因子"

#: evox.algorithms.mo.gde3.GDE3.__init__:22 of
msgid "CR"
msgstr "CR"

#: evox.algorithms.mo.gde3.GDE3.__init__:7 of
msgid "The probability of crossover"
msgstr "交叉概率"

#: ../../source/api/algorithms/mo/hype.rst:3
msgid "HypE"
msgstr "HypE"

#: evox.algorithms.mo.hype.HypE:2 of
msgid "HypE algorithm"
msgstr "HypE算法"

#: evox.algorithms.mo.hype.HypE:4 of
msgid ""
"link: https://direct.mit.edu/evco/article-abstract/19/1/45/1363/HypE-An-"
"Algorithm-for-Fast-Hypervolume-Based-Many"
msgstr ""
"链接：https://direct.mit.edu/evco/article-abstract/19/1/45/1363/HypE-An-"
"Algorithm-for-Fast-Hypervolume-Based-Many"

#: ../../source/api/algorithms/mo/ibea.rst:3
msgid "IBEA"
msgstr "IBEA"

#: evox.algorithms.mo.ibea.IBEA:2 of
msgid "IBEA algorithm"
msgstr "IBEA算法"

#: evox.algorithms.mo.ibea.IBEA:4 of
msgid "link: https://link.springer.com/chapter/10.1007/978-3-540-30217-9_84"
msgstr "链接：https://link.springer.com/chapter/10.1007/978-3-540-30217-9_84"

#: evox.algorithms.mo.ibea.IBEA:7 of
msgid "kappa: fitness scaling factor. Default: 0.05"
msgstr "kappa：适应度缩放因子。默认值：0.05"

#: ../../source/api/algorithms/mo/index.rst:3
msgid "Multi-objective"
msgstr "多目标"

#: ../../source/api/algorithms/mo/knea.rst:3
msgid "KnEA"
msgstr "KnEA"

#: evox.algorithms.mo.knea.KnEA:2 of
msgid "KnEA algorithm"
msgstr "KnEA算法"

#: evox.algorithms.mo.knea.KnEA:4 of
msgid "link: https://ieeexplore.ieee.org/document/6975108"
msgstr "链接：https://ieeexplore.ieee.org/document/6975108"

#: ../../source/api/algorithms/mo/lmocso.rst:3
msgid "LMOCSO"
msgstr "LMOCSO"

#: evox.algorithms.mo.lmocso.LMOCSO:2 of
msgid "LMOCSO algorithm"
msgstr "LMOCSO算法"

#: evox.algorithms.mo.lmocso.LMOCSO:4 of
msgid "link: https://ieeexplore.ieee.org/document/8681243"
msgstr "链接：https://ieeexplore.ieee.org/document/8681243"

#: evox.algorithms.mo.lmocso.LMOCSO:7 of
msgid ""
"alpha : The parameter controlling the rate of change of penalty. Defaults"
" to 2. max_gen : The maximum number of generations. Defaults to 100. If "
"the number of iterations is not 100, change the value based on the actual"
" value."
msgstr "alpha：控制罚分变化率的参数。默认值为2。max_gen：最大代数。默认值为100。如果迭代次数不是100，根据实际值更改该值。"

#: ../../source/api/algorithms/mo/moead.rst:3
msgid "MOEA/D"
msgstr "MOEA/D"

#: evox.algorithms.mo.moead.MOEAD:2 of
msgid "MOEA/D algorithm"
msgstr "MOEA/D算法"

#: evox.algorithms.mo.moead.MOEAD:4 of
msgid "link: https://ieeexplore.ieee.org/document/4358754"
msgstr "链接：https://ieeexplore.ieee.org/document/4358754"

#: ../../source/api/algorithms/mo/moeaddra.rst:3
msgid "MOEA/D-DRA"
msgstr "MOEA/D-DRA"

#: evox.algorithms.mo.moeaddra.MOEADDRA:2 of
msgid "MOEA/D-DRA algorithm"
msgstr "MOEA/D-DRA算法"

#: evox.algorithms.mo.moeaddra.MOEADDRA:4 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/4982949"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/4982949"

#: ../../source/api/algorithms/mo/moeadm2m.rst:3
msgid "MOEA/D-M2M"
msgstr "MOEA/D-M2M"

#: evox.algorithms.mo.moeadm2m.MOEADM2M:2 of
msgid "MOEA/D based on MOP to MOP algorithm"
msgstr "MOEA/D M2M 算法"

#: evox.algorithms.mo.moeadm2m.MOEADM2M:4 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/6595549"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/6595549"

#: ../../source/api/algorithms/mo/nsga2.rst:3
msgid "NSGA-II"
msgstr "NSGA-II"

#: evox.algorithms.mo.nsga2.NSGA2:2 of
msgid "NSGA-II algorithm"
msgstr "NSGA-II算法"

#: evox.algorithms.mo.nsga2.NSGA2:4 of
msgid "link: https://ieeexplore.ieee.org/document/996017"
msgstr "链接：https://ieeexplore.ieee.org/document/996017"

#: ../../source/api/algorithms/mo/nsga3.rst:3
msgid "NSGA-III"
msgstr "NSGA-III"

#: evox.algorithms.mo.nsga3.NSGA3:2 of
msgid "NSGA-III algorithm"
msgstr "NSGA-III算法"

#: evox.algorithms.mo.nsga3.NSGA3:4 of
msgid "link: https://ieeexplore.ieee.org/document/6600851"
msgstr "链接：https://ieeexplore.ieee.org/document/6600851"

#: ../../source/api/algorithms/mo/rvea.rst:3
msgid "RVEA"
msgstr "RVEA"

#: evox.algorithms.mo.rvea.RVEA:2 of
msgid "RVEA algorithms"
msgstr "RVEA算法"

#: evox.algorithms.mo.rvea.RVEA:4 of
msgid "link: https://ieeexplore.ieee.org/document/7386636"
msgstr "链接：https://ieeexplore.ieee.org/document/7386636"

#: evox.algorithms.mo.rvea.RVEA:7 of
msgid ""
"alpha : The parameter controlling the rate of change of penalty. Defaults"
" to 2. fr : The frequency of reference vector adaptation. Defaults to "
"0.1. max_gen : The maximum number of generations. Defaults to 100. If the"
" number of iterations is not 100, change the value based on the actual "
"value."
msgstr "alpha：控制罚分变化率的参数。默认值为2。fr：参考向量适应频率。默认值为0.1。max_gen：最大代数。默认值为100。如果迭代次数不是100，根据实际值更改该值。"

#: ../../source/api/algorithms/mo/spea2.rst:3
msgid "SPEA2"
msgstr "SPEA2"

#: evox.algorithms.mo.spea2.SPEA2:2 of
msgid "SPEA2 algorithm"
msgstr "SPEA2算法"

#: evox.algorithms.mo.spea2.SPEA2:4 of
msgid "link: https://www.research-collection.ethz.ch/handle/20.500.11850/145755"
msgstr "链接：https://www.research-collection.ethz.ch/handle/20.500.11850/145755"

#: ../../source/api/algorithms/mo/sra.rst:3
msgid "SRA"
msgstr "SRA"

#: evox.algorithms.mo.sra.SRA:2 of
msgid "Stochastic ranking algorithm"
msgstr "随机排序算法"

#: evox.algorithms.mo.sra.SRA:4 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/7445185"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/7445185"

#: ../../source/api/algorithms/mo/tdea.rst:3
msgid "tDEA"
msgstr "tDEA"

#: evox.algorithms.mo.tdea.TDEA:2 of
msgid "Theta-dominance based evolutionary algorithm"
msgstr "基于θ优势的演化算法"

#: evox.algorithms.mo.tdea.TDEA:4 of
msgid "link: https://ieeexplore.ieee.org/abstract/document/7080938"
msgstr "链接：https://ieeexplore.ieee.org/abstract/document/7080938"

#: ../../source/api/algorithms/so/amalgam.rst:3
msgid "AMaLGaM"
msgstr "AMaLGaM"

#: ../../source/api/algorithms/so/ars.rst:3
msgid "ARS"
msgstr "ARS"

#: ../../source/api/algorithms/so/asebo.rst:3
msgid "ASEBO"
msgstr "ASEBO"

#: ../../source/api/algorithms/so/clpso.rst:3
msgid "CLPSO"
msgstr "CLPSO"

#: ../../source/api/algorithms/so/cma_es.rst:3
msgid "CMA-ES"
msgstr "CMA-ES"

#: evox.algorithms.so.es_variants.cma_es.CMAES.__init__:2
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.__init__:2
#: evox.algorithms.so.es_variants.ma_es.LMMAES.__init__:2
#: evox.algorithms.so.es_variants.ma_es.MAES.__init__:2
#: evox.algorithms.so.es_variants.rmes.RMES.__init__:2 of
msgid ""
"This implementation follows `The CMA Evolution Strategy: A Tutorial "
"<https://arxiv.org/pdf/1604.00772.pdf>`_."
msgstr ""
"这个实现遵循了《CMA 演化策略：教程》（The CMA Evolution Strategy: A "
"Tutorial），详情可见：https://arxiv.org/pdf/1604.00772.pdf。"

#: evox.algorithms.so.es_variants.cma_es.CMAES.__init__:5
#: evox.algorithms.so.es_variants.cma_es.IPOPCMAES.__init__:5
#: evox.algorithms.so.es_variants.ma_es.LMMAES.__init__:5
#: evox.algorithms.so.es_variants.ma_es.MAES.__init__:5
#: evox.algorithms.so.es_variants.rmes.RMES.__init__:5 of
msgid ""
"CMA-ES involves eigendecomposition, which introduces relatively large "
"numerical error, and may lead to non-deterministic behavior on different "
"hardware backends."
msgstr "CMA-ES涉及特征分解，这会引入相对较大的数值误差，并可能导致在不同硬件后端上的非确定性行为。"

#: ../../source/api/algorithms/so/code.rst:3
msgid "CoDE"
msgstr "CoDE"

#: evox.algorithms.so.de_variants.code.CoDE:2 of
msgid ""
"CoDE Wang Y, Cai Z, Zhang Q. Differential evolution with composite trial "
"vector generation strategies and control parameters[J]. IEEE transactions"
" on evolutionary computation, 2011, 15(1): 55-66."
msgstr ""
"CoDE Wang Y, Cai Z, Zhang Q. Differential evolution with composite trial "
"vector generation strategies and control parameters[J]. IEEE transactions"
" on evolutionary computation, 2011, 15(1): 55-66."

#: ../../source/api/algorithms/so/cpso_s.rst:3
msgid "CPSO_S"
msgstr "CPSO_S"

#: evox.algorithms.so.pso_variants.cpso_s.CPSOS:2 of
msgid ""
"Cooperative particle swarm optimizer. Implemented using EvoX's built-in "
"coevolution framework. CPSOS essentially a wrapper around PSO and "
"Coevolution."
msgstr ""
"协同粒子群优化器（CPSO）在EvoX库中通过其内置的协同演化框架得以实现，实质上，C"
"PSOS本质上是对PSO（粒子群优化算法）和协同演化的封装。"

#: evox.algorithms.so.pso_variants.cpso_s.CPSOS:6 of
msgid "https://ieeexplore.ieee.org/document/1304845"
msgstr "https://ieeexplore.ieee.org/document/1304845"

#: ../../source/api/algorithms/so/cr_fm_nes.rst:3
msgid "CR-FM-NES"
msgstr "CR-FM-NES"

#: ../../source/api/algorithms/so/cso.rst:3
msgid "CSO"
msgstr "CSO"

#: ../../source/api/algorithms/so/de.rst:3
msgid "DE"
msgstr "DE"

#: ../../source/api/algorithms/so/des.rst:3
msgid "DES"
msgstr "DES"

#: ../../source/api/algorithms/so/dms_pso_el.rst:3
msgid "DMS-PSO-EL"
msgstr "DMS-PSO-EL"

#: ../../source/api/algorithms/so/esmc.rst:3
msgid "ESMC"
msgstr "ESMC"

#: ../../source/api/algorithms/so/fips.rst:3
msgid "FIPS"
msgstr "FIPS"

#: ../../source/api/algorithms/so/guide_es.rst:3
msgid "GuidedES"
msgstr "GuidedES"

#: ../../source/api/algorithms/so/index.rst:3
msgid "Single-objective"
msgstr "单目标"

#: ../../source/api/algorithms/so/jade.rst:3
msgid "JaDE"
msgstr "JaDE"

#: evox.algorithms.so.de_variants.jade.JaDE:2 of
msgid ""
"JaDE Zhang J, Sanderson A C. JADE: adaptive differential evolution with "
"optional external archive[J]. IEEE Transactions on evolutionary "
"computation, 2009, 13(5): 945-958."
msgstr ""
"JaDE Zhang J, Sanderson A C. JADE: adaptive differential evolution with "
"optional external archive[J]. IEEE Transactions on evolutionary "
"computation, 2009, 13(5): 945-958."

#: ../../source/api/algorithms/so/les.rst:3
msgid "LES"
msgstr "LES"

#: ../../source/api/algorithms/so/ma_es.rst:3
msgid "MA-ES"
msgstr "MA-ES"

#: ../../source/api/algorithms/so/nes.rst:3
msgid "xNES"
msgstr "xNES"

#: evox.algorithms.so.es_variants.nes.SeparableNES.__init__:2
#: evox.algorithms.so.es_variants.nes.XNES.__init__:2 of
msgid "See [link](https://arxiv.org/pdf/1106.4487.pdf) for default parameters"
msgstr "参考链接[link](https://arxiv.org/pdf/1106.4487.pdf)中的默认参数"

#: ../../source/api/algorithms/so/noise_reuse_es.rst:3
msgid "Noise-Reuse-ES"
msgstr "Noise-Reuse-ES"

#: ../../source/api/algorithms/so/ode.rst:3
msgid "ODE"
msgstr "ODE"

#: ../../source/api/algorithms/so/open_es.rst:3
msgid "OpenES"
msgstr "OpenES"

#: evox.algorithms.so.es_variants.open_es.OpenES.__init__:2 of
msgid ""
"Implement the algorithm described in \"Evolution Strategies as a Scalable"
" Alternative to Reinforcement Learning\" from "
"https://arxiv.org/abs/1703.03864"
msgstr ""
"实现论文 \"Evolution Strategies as a Scalable Alternative to Reinforcement "
"Learning\" 中描述的算法，链接为https://arxiv.org/abs/1703.03864"

#: ../../source/api/algorithms/so/persistent_es.rst:3
msgid "PersistentES"
msgstr "PersistentES"

#: ../../source/api/algorithms/so/pgpe.rst:3
msgid "PGPE"
msgstr "PGPE"

#: ../../source/api/algorithms/so/pso.rst:3
msgid "PSO"
msgstr "PSO"

#: ../../source/api/algorithms/so/rmes.rst:3
msgid "RMES"
msgstr "RMES"

#: ../../source/api/algorithms/so/sade.rst:3
msgid "SaDE"
msgstr "SaDE"

#: evox.algorithms.so.de_variants.sade.SaDE:2 of
msgid ""
"SaDE Qin A K, Huang V L, Suganthan P N. Differential evolution algorithm "
"with strategy adaptation for global numerical optimization[J]. IEEE "
"transactions on Evolutionary Computation, 2008, 13(2): 398-417."
msgstr ""
"SaDE Qin A K, Huang V L, Suganthan P N. Differential evolution algorithm "
"with strategy adaptation for global numerical optimization[J]. IEEE "
"transactions on Evolutionary Computation, 2008, 13(2): 398-417."

#: ../../source/api/algorithms/so/shade.rst:3
msgid "SHADE"
msgstr "SHADE"

#: evox.algorithms.so.de_variants.shade.SHADE:2 of
msgid ""
"SHADE Tanabe R, Fukunaga A. Success-history based parameter adaptation "
"for differential evolution[C]//2013 IEEE congress on evolutionary "
"computation. IEEE, 2013: 71-78."
msgstr ""
"SHADE Tanabe R, Fukunaga A. Success-history based parameter adaptation "
"for differential evolution[C]//2013 IEEE congress on evolutionary "
"computation. IEEE, 2013: 71-78."

#: ../../source/api/algorithms/so/sl_pso_gs.rst:3
msgid "SL-PSO-GS"
msgstr "SL-PSO-GS"

#: ../../source/api/algorithms/so/sl_pso_us.rst:3
msgid "SL-PSO-US"
msgstr "SL-PSO-US"

#: ../../source/api/algorithms/so/snes.rst:3
msgid "SNES"
msgstr "SNES"

#: ../../source/api/algorithms/so/swmmpso.rst:3
msgid "SWMMPSO"
msgstr "SWMMPSO"

#: ../../source/api/core/algorithm.rst:3
msgid "Algorithm Class"
msgstr "算法类"

#: evox.core.algorithm.Algorithm:2 evox.core.problem.Problem:2 of
msgid "Base class for all algorithms"
msgstr "所有算法的基类"

#: ../../source/api/core/index.rst:3
msgid "Core Classes"
msgstr "核心类"

#: ../../source/api/core/module.rst:3
msgid "Module Class"
msgstr "模块类"

#: evox.core.module.Stateful:2 of
msgid "Base class for all evox modules."
msgstr "所有EvoX模块的基础类。"

#: evox.core.module.Stateful:4 of
msgid "This module allow easy managing of states."
msgstr "这个模块允许轻松管理状态。"

#: evox.core.module.Stateful:6 of
msgid ""
"All the constants (e.g. hyperparameters) are initialized in the "
"``__init__``, and mutated states are initialized in the ``setup`` method."
msgstr "所有常数（例如超参数）都在“ __init__” 中初始化，而变异状态则在 “setup” 方法中初始化。"

#: evox.core.module.Stateful:9 of
msgid ""
"The ``init`` method will automatically call the ``setup`` of the current "
"module and recursively call ``setup`` methods of all submodules."
msgstr "“init” 方法将自动调用当前模块的 “setup”，并递归地调用所有子模块的 “setup” 方法。"

#: ../../source/api/core/problem.rst:3
msgid "Problem Class"
msgstr "问题类"

#: evox.core.problem.Problem.evaluate:2
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:2 of
msgid "Evaluate the fitness at given points"
msgstr "在给定点评估适应度"

#: evox.core.problem.Problem.evaluate:-1 evox.core.problem.Problem.evaluate:16
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:-1
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:16 of
msgid "dict"
msgstr "字典"

#: evox.core.problem.Problem.evaluate:8
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:8 of
msgid "The state of this problem."
msgstr "这个问题的状态。"

#: evox.core.problem.Problem.evaluate:11
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:11 of
msgid "**X**"
msgstr "**X**"

#: evox.core.problem.Problem.evaluate:-1 evox.core.problem.Problem.evaluate:31
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:-1
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:31 of
msgid "ndarray"
msgstr "ndarray"

#: evox.core.problem.Problem.evaluate:11
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:11 of
msgid "The population."
msgstr "种群。"

#: evox.core.problem.Problem.evaluate:19
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.evaluate:19 of
msgid "The fitness."
msgstr "适应度值。"

#: ../../source/api/core/state.rst:3
msgid "State Class"
msgstr "状态类"

#: evox.core.state.State:2 of
msgid "A class represents state"
msgstr "一个表示状态的类"

#: evox.core.state.State:4 of
msgid ""
"``State`` is immutable, to update state, use the ``update`` method or the"
" ``|`` operator. ``State`` has already implemented ``tree_flatten``, "
"``tree_unflatten`` and has registered as a valid pytree node. So it can "
"be used as pytree with JAX without any issue."
msgstr ""
"“State ”是不可变的，要更新状态，请使用“update ” 方法或 “| ”运算符。“State ” 已经实现了 "
"“tree_flatten”、“tree_unflatten ”并且已注册为有效的 pytree 节点。因此，它可以与 JAX 一起作为 "
"pytree 使用。"

#: evox.core.state.State.__init__:2 of
msgid "Construct a ``State`` from dict or keyword arguments"
msgstr "从Python字典（dict）或关键字（keyword arguments）构建一个状态（State）对象"

#: evox.core.state.State.__init__:23 evox.core.state.State.update:28 of
msgid "Example::"
msgstr "例子："

#: evox.core.state.State.find_path_to:2 of
msgid ""
"Find the state with node_id matching the state_id A hint can be given "
"with the module_name"
msgstr "找到节点 ID 与状态 ID 匹配的状态。可以通过模块名称给出提示"

#: evox.core.state.State.update:2 of
msgid "Update the current State with another State or dict and return new State."
msgstr "使用另一个 State 或 dict 更新当前 State，并返回新的 State。"

#: evox.core.state.State.update:4 of
msgid "This method also accept keyword arguments."
msgstr "这个方法也接受关键字参数。"

#: ../../source/api/metrics/gd.rst:3
msgid "Generational Distance"
msgstr "世代距离"

#: ../../source/api/metrics/hv.rst:3
msgid "Hypervolume"
msgstr "超体积"

#: evox.metrics.hypervolume.HV:2 of
msgid ""
"Hypervolume indicator Implemented using monte carlo. We offers two "
"different sample methods: `bounding_cube` and `each_cube`. With "
"`bounding_cube`, we draw samples from a hypercube that can bound all "
"objectives. With `each_cube`, we draw samples from each hypercube form by"
" each objective and the reference point. Since reference point is often "
"far from pf, `bounding_cube` method usually gives more accurate result."
msgstr ""
"超体积指标，使用蒙特卡洛方法实现。我们提供两种不同的样本方法：`bounding_cube` 和 `each_cube`。使用 "
"`bounding_cube` 方法，我们从一个可以包围所有目标的超立方体中抽取样本。使用 `each_cube` "
"方法，我们从由每个目标和参考点形成的每个超立方体中抽取样本。由于参考点通常远离帕雷托前沿（pf），`bounding_cube`方法通常能提供更准确的结果。"

#: evox.metrics.hypervolume.HV.__init__:8 of
msgid "**ref**"
msgstr "**ref**"

#: evox.metrics.hypervolume.HV.__init__:8 of
msgid "The reference point."
msgstr "参考点。"

#: evox.metrics.hypervolume.HV.__init__:11 of
msgid "**num_sample**"
msgstr "**样本数量**"

#: evox.metrics.hypervolume.HV.__init__:11 of
msgid "Number of samples to draw when doing monte carlo."
msgstr "在使用蒙特卡洛方法的时候样本的数量。"

#: evox.metrics.hypervolume.HV.__init__:28 of
msgid "**sample_method**"
msgstr "**sample_method**"

#: evox.metrics.hypervolume.HV.__init__:14 of
msgid "`bounding_cube` or `each_cube`. Default to `bounding_cube`."
msgstr "`bounding_cube` 或 `each_cube`. 默认为 `bounding_cube`."

#: ../../source/api/metrics/igd.rst:3
msgid "Inverted Generational Distance"
msgstr "反世代距离"

#: ../../source/api/metrics/index.rst:3
msgid "Metrics"
msgstr "度量指标"

#: ../../source/api/monitors/evoxvis.rst:3
msgid "EvoXVis Monitor"
msgstr "EvoXVis 监视器"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor:2 of
msgid ""
"This class serialize data to apache arrow format, which can be picked up "
"and used in EvoXVis. The tensors are stored as fixed size binary and the "
"dtype is recorded in the metadata."
msgstr "这个类将数据序列化为可以在EvoXVis中提取和使用的apache arrow格式。张量被存储为固定大小的二进制，并且数据类型被记录在元数据中。"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:10 of
msgid "**base_filename**"
msgstr "**base_filename**"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:8 of
msgid ""
"The base filename of the log file, the final filename will be "
"``<base_filename>_<i>.arrow``, where i is an incrementing number."
msgstr "日志文件的基本文件名，最终文件名将是``<base_filename>_<i>.arrow``，其中i是递增的数字。"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:17 of
msgid "**out_dir**"
msgstr "**out_dir**"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:13 of
msgid ""
"This directory to write the log file into. When set to None, the default "
"directory will be used. The default is ``<TEMP_DIR>/evox``, on Windows, "
"it's usually ``C:\\TEMP\\evox``, and on MacOS/Linux/BSDs it's "
"``/tmp/evox``."
msgstr "将日志文件写入的目录。当设置为None时，将使用默认目录。默认为``<TEMP_DIR>/evox``，在Windows上通常为``C：\\temp\\evox``，在MacOS/Linux/BSD上为``/tMP/evox``。"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:22 of
msgid "**out_type**"
msgstr "**out_type**"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:20 of
msgid ""
"\"stream\" or \"file\", For more information, please refer to "
"https://arrow.apache.org/docs/python/ipc.html"
msgstr ""
"\"stream\" 或\"file\"，更多信息，请参考 "
"https://arrow.apache.org/docs/python/ipc.html"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:29
#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:16 of
msgid "**batch_size**"
msgstr "**batch_size**"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:25 of
msgid ""
"The monitor will buffer the data in memory and write out every `batch "
"size`. Choose a larger value may improve I/O performance and improve "
"compression ratio, if compression is enabled. Default to 64."
msgstr "监控器会将数据缓存在内存中，并写出每个`batch size`。如果启用了压缩，则选择较大的值可能会提高I/O性能并提高压缩比。默认为64。"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:48 of
msgid "**compression**"
msgstr "**compression**"

#: evox.monitors.evoxvis_monitor.EvoXVisMonitor.__init__:32 of
msgid ""
"Controls the compression algorithm used when writing to the file. "
"Available options are None, \"lz4\", \"zstd\", \"lz4\" is extremely fast,"
" with poor compression ratio, \"zstd\" is fast, but also with good "
"compression ratio."
msgstr "控制写入文件时使用的压缩算法。可供选择的有None、“lz4”、“zstd”，“lz4”速度极快，压缩比差，“zstd”速度快，同时压缩比也很好。"

#: ../../source/api/monitors/index.rst:3
msgid "Monitors"
msgstr "监视器"

#: ../../source/api/monitors/std_mo.rst:3
msgid "Standard Multi-objective Monitor"
msgstr "标准多目标监视器"

#: evox.monitors.std_mo_monitor.StdMOMonitor:2 of
msgid ""
"Standard multi-objective monitor Used for multi-objective workflow, can "
"monitor fitness and record the pareto front."
msgstr "标准多目标监视器，用于多目标工作流，可以监控适应度并记录帕累托前沿。"

#: evox.monitors.std_mo_monitor.StdMOMonitor:14 of
msgid "**record_pf**"
msgstr "**record_pf**"

#: evox.monitors.std_mo_monitor.StdMOMonitor:10 of
msgid ""
"Whether to record the pareto front during the run. Default to False. "
"Setting it to True will cause the monitor to maintain a pareto front of "
"all the solutions with unlimited size, which may hurt performance."
msgstr "是否在运行过程中记录帕累托前沿。默认值为假（False）。将其设置为真（True）将导致监视器维护一个无限大小的所有解决方案的帕累托前沿，这可能会影响性能。"

#: evox.monitors.std_mo_monitor.StdMOMonitor:31
#: evox.monitors.std_so_monitor.StdSOMonitor:28 of
msgid "**record_fit_history**"
msgstr "**record_fit_history**"

#: evox.monitors.std_mo_monitor.StdMOMonitor:17
#: evox.monitors.std_so_monitor.StdSOMonitor:14 of
msgid ""
"Whether to record the full history of fitness value. Default to True. "
"Setting it to False may reduce memory usage."
msgstr "是否记录适应度值的完整历史。默认为True。将其设置为FALSE可能会减少内存使用。"

#: evox.monitors.std_mo_monitor.StdMOMonitor.plot:2
#: evox.monitors.std_so_monitor.StdSOMonitor.plot:2 of
msgid ""
"A Built-in plot function for visualizing the population of single-"
"objective algorithm. Use plotly internally, so you need to install plotly"
" to use this function."
msgstr "内置的单目标算法种群可视化绘图函数。内部使用plotly库，因此要使用此功能，您需"
"要先安装plotly。"

#: evox.monitors.std_mo_monitor.StdMOMonitor.plot:5
#: evox.monitors.std_so_monitor.StdSOMonitor.plot:5 of
msgid ""
"If the problem is provided, we will plot the fitness landscape of the "
"problem."
msgstr "如果提供了问题实例，我们将绘制该问题的适应度landscape。"

#: ../../source/api/monitors/std_so.rst:3
msgid "Standard Single-objective Monitor"
msgstr "标准单目标监视器"

#: evox.monitors.std_so_monitor.StdSOMonitor:2 of
msgid ""
"Standard single-objective monitor Used for single-objective workflow, can"
" monitor fitness and the population."
msgstr "标准单目标监控器 用于单目标工作流，可以监控适应度和种群。"

#: evox.monitors.std_so_monitor.StdSOMonitor:11 of
msgid "**record_topk**"
msgstr "**record_topk**"

#: evox.monitors.std_so_monitor.StdSOMonitor:10 of
msgid ""
"Control how many elite solutions are recorded. Default is 1, which will "
"record the best individual."
msgstr "控制录制多少精英解决方案。默认为1，它将记录最好的个体。"

#: ../../source/api/problems/index.rst:3
msgid "Problems"
msgstr "问题"

#: evox.problems:1 of
msgid "The module that contains all pre-defined problems"
msgstr "包含所有预定义的问题的模块"

#: ../../source/api/problems/neuroevolution/index.rst:3
msgid "Neuroevolution"
msgstr "神经演化"

#: ../../source/api/problems/neuroevolution/reinforcement_learning/brax.rst:3
msgid "Brax-based Problem"
msgstr "基于Brax的问题"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:2 of
msgid "Contruct a brax-based problem"
msgstr "构造一个基于Brax的问题"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:9
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:9 of
msgid "**policy**"
msgstr "**策略**"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:8
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:8 of
msgid ""
"A function that accept two arguments the first one is the parameter and "
"the second is the input."
msgstr "一个接受两个参数的函数，第一个参数是参数本身，第二个是输入。"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:12
#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:15 of
msgid "**env_name**"
msgstr "**env_name**"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:12 of
msgid "The environment name."
msgstr "环境名。"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:15 of
msgid ""
"The number of brax environments to run in parallel. Usually this should "
"match the population size at the algorithm side."
msgstr "要并行运行的BRAX环境的数量。通常，这应该与算法端的种群大小相匹配。"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:19 of
msgid "**cap_episode**"
msgstr "**cap_episode**"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:19 of
msgid "The maximum number episodes to run."
msgstr "运行的最大episode数量。"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:36 of
msgid "**backend**"
msgstr "**后端**"

#: evox.problems.neuroevolution.reinforcement_learning.brax.Brax.__init__:22 of
msgid ""
"Brax's backend, one of \"generalized\", \"positional\", \"spring\". "
"Default to \"generalized\"."
msgstr "Brax的后端，是“generalized”、“positional”、“spring”中的其中一个。默认为“generalized”。"

#: ../../source/api/problems/neuroevolution/reinforcement_learning/env_pool.rst:3
msgid "Env Pool"
msgstr "环境池"

#: ../../source/api/problems/neuroevolution/reinforcement_learning/gym.rst:3
msgid "Gym"
msgstr "Gym"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:2 of
msgid "Construct a gym problem"
msgstr "构建一个gym 问题"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:12
#: evox.workflows.distributed.RayDistributedWorkflow.__init__:22 of
msgid "**num_workers**"
msgstr "**num_workers**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:12 of
msgid "Number of worker actors."
msgstr "工作者（worker）actor的数量。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:15 of
msgid "The name of the gym environment."
msgstr "Gym环境的名称。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:18 of
msgid "**env_options**"
msgstr "**env_options**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:18 of
msgid "The options of the gym environment."
msgstr "gym 环境的选项。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:21 of
msgid "**env_creator**"
msgstr "**env_creator**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:21 of
msgid "A function with zero argument that returns an environment when called."
msgstr "一个调用时返回一个环境的零参数函数。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:28 of
msgid "**mo_keys**"
msgstr "**mo_keys**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:24 of
msgid ""
"Optional, a list of strings. If set, the environment is treated as a "
"multi-objective problem, and different objective values are obtained "
"through the `info` term returned by Gym. The `mo_keys` parameter provides"
" the keys for accessing the objective values in the info dictionary. The "
"objective values will be returned in the same order as specified in "
"`mo_keys`."
msgstr ""
"可选参数，一个字符串列表。如果设置，环境被视为一个多目标问题，不同的目标值通"
"过Gym返回的`info`项获取。`mo_keys`参数提供了在info字典中访问目标值的键。目标"
"值将按照在`mo_keys`中指定的顺序返回。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:36 of
msgid "**controller_options**"
msgstr "**控制器选项**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:31 of
msgid ""
"The runtime options for controller actor. This actor is used to control "
"workers and run the policy at each step. For example, to enable GPU "
"acceleration on the policy network, set this field to::"
msgstr ""
"控制器actor的运行时选项。这个actor用于控制工作者worker，并在每一步运行策略。"
"例如，要启用策略网络的GPU加速功能，请将此字段设置为::"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:52 of
msgid "**worker_options**"
msgstr "**工作者选项**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.__init__:39 of
msgid "The runtime options for worker actors."
msgstr "工作者（actor）的运行时选项。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:2 of
msgid ""
"Visualize your policy, passin a single set of weights, and it will be put"
" in the environment for interaction."
msgstr "可视化您的策略，通过传递一组权重，该策略将会被置于环境中进行互动展示。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:9
#: evox.workflows.uni_workflow.UniWorkflow.enable_distributed:11
#: evox.workflows.uni_workflow.UniWorkflow.enable_multi_devices:8 of
msgid "The state."
msgstr "状态。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:12 of
msgid "This key will be used to seed the test environment."
msgstr "此密钥将会作为测试环境的随机数种子。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:15 of
msgid "**weights**"
msgstr "**权重**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:15 of
msgid "A single set of weights for your policy."
msgstr "策略的一组权重。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:41 of
msgid "**ale_render_mode**"
msgstr "**ale_render_mode**"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:18 of
msgid "'rgb_array' or 'human'."
msgstr "'rgb_array' 或 'human'。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:20 of
msgid ""
"In 'rgb_array' mode, this function will return a list of frames, each "
"frame is a numpy array."
msgstr "在\"rgb_array\"模式下，该函数将返回一个帧列表，每个帧都是一个numpy数组。"

#: evox.problems.neuroevolution.reinforcement_learning.gym.Gym.visualize:23 of
msgid ""
"In 'human' mode, the frame should be displayed directly onto your screen."
" However, if your using remote python environment, for example vscode ssh"
" or jupyter notebook, this method may fail to find a valid display. "
"Default to 'rgb_array'."
msgstr ""
"在\"human\"模式下，帧应直接显示在屏幕上。但是，如果您正在使用远程Python环境（"
"例如VSCode SSH或Jupyter Notebook），这种方法可能无法找到有效的显示器，"
"因此默认设置为\"rgb_array\"模式。"

#: ../../source/api/problems/neuroevolution/reinforcement_learning/index.rst:3
msgid "Reinforcement Learning"
msgstr "强化学习"

#: ../../source/api/problems/neuroevolution/supervised_learning/index.rst:3
msgid "Supervised Learning"
msgstr "监督学习"

#: ../../source/api/problems/neuroevolution/supervised_learning/torchvision.rst:3
msgid "Torchvision Dataset"
msgstr "Torchvision 数据集"

#: ../../source/api/problems/numerical/index.rst:3
msgid "Numerical Benchmarks"
msgstr "数值基准测试"

#: ../../source/api/problems/numerical/test_functions/ackley.rst:3
msgid "Ackley"
msgstr "Ackley"

#: ../../source/api/problems/numerical/test_functions/griewank.rst:3
msgid "Griewank"
msgstr "Griewank"

#: ../../source/api/problems/numerical/test_functions/index.md:1
msgid "Test functions"
msgstr "测试函数"

#: ../../source/api/problems/numerical/test_functions/rastrigin.rst:3
msgid "Rastrigin"
msgstr "Rastrigin"

#: ../../source/api/problems/numerical/test_functions/rosenbrock.rst:3
msgid "Rosenbrock"
msgstr "Rosenbrock"

#: ../../source/api/problems/numerical/test_functions/schwefel.rst:3
msgid "Schwefel"
msgstr "Schwefel"

#: evox.problems.numerical.schwefel.Schwefel:2 of
msgid "The Schwefel function The minimum is x = [420.9687462275036, ...]"
msgstr "Schwefel函数，最小值位于 x = [420.9687462275036, ...]"

#: ../../source/api/problems/numerical/test_functions/sphere.rst:3
msgid "Sphere"
msgstr "Sphere"

#: ../../source/api/problems/numerical/test_suits/cec2022.rst:3
msgid "CEC2022 Test Suit"
msgstr "CEC2022 测试套件"

#: evox.problems.numerical.cec2022_so.CEC2022TestSuit:2 of
msgid ""
"Instantiation format: problem_instance = CEC2022.create(1) i.e., "
"problem_instance = F1_CEC2022()"
msgstr ""
"实例化格式：problem_instance = CEC2022.create(1)，即 problem_instance = "
"F1_CEC2022()"

#: evox.problems.numerical.cec2022_so.F10_CEC2022:2
#: evox.problems.numerical.cec2022_so.F11_CEC2022:2
#: evox.problems.numerical.cec2022_so.F12_CEC2022:2
#: evox.problems.numerical.cec2022_so.F1_CEC2022:2
#: evox.problems.numerical.cec2022_so.F2_CEC2022:2
#: evox.problems.numerical.cec2022_so.F3_CEC2022:2
#: evox.problems.numerical.cec2022_so.F4_CEC2022:2
#: evox.problems.numerical.cec2022_so.F5_CEC2022:2
#: evox.problems.numerical.cec2022_so.F6_CEC2022:2
#: evox.problems.numerical.cec2022_so.F7_CEC2022:2
#: evox.problems.numerical.cec2022_so.F8_CEC2022:2
#: evox.problems.numerical.cec2022_so.F9_CEC2022:2 of
msgid "Test problems of CEC2022"
msgstr "CEC2022测试问题集"

#: ../../source/api/problems/numerical/test_suits/dtlz.rst:3
msgid "DTLZ Test Suit"
msgstr "DTLZ测试套件"

#: ../../source/api/problems/numerical/test_suits/index.md:1
msgid "Test suits"
msgstr "测试套件"

#: ../../source/api/problems/numerical/test_suits/lsmop.rst:3
msgid "LSMOP Test Suit"
msgstr "LSMOP测试套件"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:2
#: evox.problems.numerical.lsmop.LSMOP2.__init__:2
#: evox.problems.numerical.lsmop.LSMOP3.__init__:2
#: evox.problems.numerical.lsmop.LSMOP4.__init__:2
#: evox.problems.numerical.lsmop.LSMOP5.__init__:2
#: evox.problems.numerical.lsmop.LSMOP6.__init__:2
#: evox.problems.numerical.lsmop.LSMOP7.__init__:2
#: evox.problems.numerical.lsmop.LSMOP8.__init__:2
#: evox.problems.numerical.lsmop.LSMOP9.__init__:2 of
msgid "init"
msgstr "init"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:8
#: evox.problems.numerical.lsmop.LSMOP2.__init__:8
#: evox.problems.numerical.lsmop.LSMOP3.__init__:8
#: evox.problems.numerical.lsmop.LSMOP4.__init__:8
#: evox.problems.numerical.lsmop.LSMOP5.__init__:8
#: evox.problems.numerical.lsmop.LSMOP6.__init__:8
#: evox.problems.numerical.lsmop.LSMOP7.__init__:8
#: evox.problems.numerical.lsmop.LSMOP8.__init__:8
#: evox.problems.numerical.lsmop.LSMOP9.__init__:8 of
msgid "**d**"
msgstr "**维度**"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:8
#: evox.problems.numerical.lsmop.LSMOP2.__init__:8
#: evox.problems.numerical.lsmop.LSMOP3.__init__:8
#: evox.problems.numerical.lsmop.LSMOP4.__init__:8
#: evox.problems.numerical.lsmop.LSMOP5.__init__:8
#: evox.problems.numerical.lsmop.LSMOP6.__init__:8
#: evox.problems.numerical.lsmop.LSMOP7.__init__:8
#: evox.problems.numerical.lsmop.LSMOP8.__init__:8
#: evox.problems.numerical.lsmop.LSMOP9.__init__:8 of
msgid "the dimension of decision space"
msgstr "决策空间的维度"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:11
#: evox.problems.numerical.lsmop.LSMOP2.__init__:11
#: evox.problems.numerical.lsmop.LSMOP3.__init__:11
#: evox.problems.numerical.lsmop.LSMOP4.__init__:11
#: evox.problems.numerical.lsmop.LSMOP5.__init__:11
#: evox.problems.numerical.lsmop.LSMOP6.__init__:11
#: evox.problems.numerical.lsmop.LSMOP7.__init__:11
#: evox.problems.numerical.lsmop.LSMOP8.__init__:11
#: evox.problems.numerical.lsmop.LSMOP9.__init__:11 of
msgid "**m**"
msgstr "**目标数目**"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:11
#: evox.problems.numerical.lsmop.LSMOP2.__init__:11
#: evox.problems.numerical.lsmop.LSMOP3.__init__:11
#: evox.problems.numerical.lsmop.LSMOP4.__init__:11
#: evox.problems.numerical.lsmop.LSMOP5.__init__:11
#: evox.problems.numerical.lsmop.LSMOP6.__init__:11
#: evox.problems.numerical.lsmop.LSMOP7.__init__:11
#: evox.problems.numerical.lsmop.LSMOP8.__init__:11
#: evox.problems.numerical.lsmop.LSMOP9.__init__:11 of
msgid "the number of object"
msgstr "目标数量"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:27
#: evox.problems.numerical.lsmop.LSMOP2.__init__:27
#: evox.problems.numerical.lsmop.LSMOP3.__init__:27
#: evox.problems.numerical.lsmop.LSMOP4.__init__:27
#: evox.problems.numerical.lsmop.LSMOP5.__init__:27
#: evox.problems.numerical.lsmop.LSMOP6.__init__:27
#: evox.problems.numerical.lsmop.LSMOP7.__init__:27
#: evox.problems.numerical.lsmop.LSMOP8.__init__:27
#: evox.problems.numerical.lsmop.LSMOP9.__init__:27 of
msgid "**ref_num**"
msgstr "**ref_num**"

#: evox.problems.numerical.lsmop.LSMOP1.__init__:14
#: evox.problems.numerical.lsmop.LSMOP2.__init__:14
#: evox.problems.numerical.lsmop.LSMOP3.__init__:14
#: evox.problems.numerical.lsmop.LSMOP4.__init__:14
#: evox.problems.numerical.lsmop.LSMOP5.__init__:14
#: evox.problems.numerical.lsmop.LSMOP6.__init__:14
#: evox.problems.numerical.lsmop.LSMOP7.__init__:14
#: evox.problems.numerical.lsmop.LSMOP8.__init__:14
#: evox.problems.numerical.lsmop.LSMOP9.__init__:14 of
msgid "ref_num * m is the Population of PF"
msgstr "ref_num * m 是 Pareto 前沿（PF）的种群数量"

#: ../../source/api/problems/numerical/test_suits/maf.rst:3
msgid "MaF Test Suit"
msgstr "MaF测试套件"

#: ../../source/api/problems/numerical/test_suits/zdt.rst:3
msgid "ZDT Test Suit"
msgstr "ZDT测试套件"

#: ../../source/api/workflows/distributed.rst:3
msgid "Ray-based Distributed Workflow"
msgstr "基于Ray的分布式工作流"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:2 of
msgid "Create a distributed workflow"
msgstr "创建分布式工作流"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:4 of
msgid ""
"Distributed workflow can distribute the workflow to different nodes, it "
"will create num_workers copies of the workflows with the same seed, and "
"at each step each workflow only evaluate part of the population, then "
"pass the fitness to other nodes to recreate the whole fitness array."
msgstr ""
"分布式工作流能够将工作流程分布到不同的节点上。它会使用相同的随机种子创建num_w"
"orkers个相同工作流程副本，并且在每一步中，每个工作流程仅评估种群的一部分，然"
"后将适应度值传递给其他节点以重建整个适应度数组。这样，通过各节点间的协作，实"
"现大规模并行计算和优化过程的高效执行。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:9 of
msgid ""
"pop_transform and fitness_transform are applied at each node, while "
"global_fitness_transform is applied at the main node once per step, so "
"monitor should be passed as global_fitness_transform."
msgstr ""
"pop_transform和fitness_transform在每个节点上分别应用，而global_fitness_transf"
"orm则在主节点上每一步执行一次。因此，monitor应当作为global_fitness_transform"
"传递。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:16
#: evox.workflows.standard.StdWorkflow.__init__:8
#: evox.workflows.uni_workflow.UniWorkflow.__init__:8 of
msgid "**algorithm**"
msgstr "**算法**"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:16
#: evox.workflows.standard.StdWorkflow.__init__:8
#: evox.workflows.uni_workflow.UniWorkflow.__init__:8 of
msgid "The algorithm."
msgstr "算法。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:19
#: evox.workflows.standard.StdWorkflow.__init__:11
#: evox.workflows.uni_workflow.UniWorkflow.__init__:11 of
msgid "**problem**"
msgstr "**问题**"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:19
#: evox.workflows.standard.StdWorkflow.__init__:11
#: evox.workflows.uni_workflow.UniWorkflow.__init__:11 of
msgid "The problem."
msgstr "问题。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:22 of
msgid "Number of workers."
msgstr "工作者的数目。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:26
#: evox.workflows.standard.StdWorkflow.__init__:18
#: evox.workflows.uni_workflow.UniWorkflow.__init__:18 of
msgid "**opt_direction**"
msgstr "**opt_direction**"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:25
#: evox.workflows.standard.StdWorkflow.__init__:17
#: evox.workflows.uni_workflow.UniWorkflow.__init__:17 of
msgid ""
"The optimization direction, can be either \"min\" or \"max\" or a list of"
" \"min\"/\"max\" to specific the direction for each objective."
msgstr ""
"优化方向，可以是\"min\"（最小化）或\"max\"（最大化），也可以是一个包含\"min\""
"/\"max\"的列表来指定每个目标的具体优化方向。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:29 of
msgid "**options**"
msgstr "**options**"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:29 of
msgid "The runtime options of the worker actor."
msgstr "工作者（worker）actor的运行时选项。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:32 of
msgid "**pop_transform:**"
msgstr "**pop_transform:**"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:32 of
msgid "Population transform, this transform is applied at each worker node."
msgstr "Population transform，这种转换会被应用到每一个worker节点。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:35 of
msgid "**fitness_transform:**"
msgstr "**fitness_transform:**"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:35 of
msgid "Fitness transform, this transform is applied at each worker node."
msgstr "适应度变换，这个变换在每个工作节点上应用。"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:51 of
msgid "**global_fitness_transform:**"
msgstr "**global_fitness_transform:**"

#: evox.workflows.distributed.RayDistributedWorkflow.__init__:38 of
msgid "This transform is applied at the main node."
msgstr "这个变换在主节点上应用。"

#: ../../source/api/workflows/index.rst:3
msgid "Workflows"
msgstr "工作流"

#: ../../source/api/workflows/standard.rst:3
msgid "Standard Workflow"
msgstr "标准工作流"

#: evox.workflows.standard.StdWorkflow.__init__:14
#: evox.workflows.uni_workflow.UniWorkflow.__init__:14 of
msgid "**monitor**"
msgstr "**监控器**"

#: evox.workflows.standard.StdWorkflow.__init__:14
#: evox.workflows.uni_workflow.UniWorkflow.__init__:14 of
msgid "Optional monitor."
msgstr "可选监控器。"

#: evox.workflows.standard.StdWorkflow.__init__:23
#: evox.workflows.uni_workflow.UniWorkflow.__init__:23 of
msgid "**pop_transform**"
msgstr "**pop_transform**"

#: evox.workflows.standard.StdWorkflow.__init__:21
#: evox.workflows.uni_workflow.UniWorkflow.__init__:21 of
msgid ""
"Optional population transform function, usually used to decode the "
"population into the format that can be understood by the problem."
msgstr "可选种群变换函数，通常用于将种群解码为问题能够理解的格式。"

#: evox.workflows.standard.StdWorkflow.__init__:27
#: evox.workflows.uni_workflow.UniWorkflow.__init__:27 of
msgid "**fit_transform**"
msgstr "**fit_transform**"

#: evox.workflows.standard.StdWorkflow.__init__:26
#: evox.workflows.uni_workflow.UniWorkflow.__init__:26 of
msgid ""
"Optional fitness transform function. usually used to apply fitness "
"shaping."
msgstr "可选适应度变换函数，通常用于应用适应度整形。"

#: evox.workflows.standard.StdWorkflow.__init__:30
#: evox.workflows.uni_workflow.UniWorkflow.__init__:30 of
msgid "**record_pop**"
msgstr "**种群记录**"

#: evox.workflows.standard.StdWorkflow.__init__:30
#: evox.workflows.uni_workflow.UniWorkflow.__init__:30 of
msgid "Whether to record the population if monitor is enabled."
msgstr "如果启用了monitor，是否要记录种群数据。"

#: evox.workflows.standard.StdWorkflow.__init__:49
#: evox.workflows.uni_workflow.UniWorkflow.__init__:36 of
msgid "**record_time**"
msgstr "**时间记录**"

#: evox.workflows.standard.StdWorkflow.__init__:33
#: evox.workflows.uni_workflow.UniWorkflow.__init__:33 of
msgid ""
"Whether to record the time at the end of each generation. Due to its "
"timing nature, record_time requires synchronized functional call. Default"
" to False."
msgstr "是否记录每代结束的时间。由于它的计时性质，record_time需要同步的函数调用。默认"
"为False。"

#: evox.workflows.standard.StdWorkflow.sample:2 of
msgid "Sample the algorithm but don't change it's state"
msgstr "对算法采样但不改变它的状态"

#: ../../source/api/workflows/uni.rst:3
msgid "Universal Workflow"
msgstr "通用工作流"

#: evox.workflows.uni_workflow.UniWorkflow:2 of
msgid ""
"Experimental unified workflow, designed to provide unparallel performance"
" for EC workflow."
msgstr "实验中的统一workflow，设计目的是大幅提升EC的性能."

#: evox.workflows.uni_workflow.UniWorkflow:5 of
msgid ""
"Provide automatic multi-device (e.g. multiple gpus) computation as well "
"as distributed computation using JAX's native components."
msgstr "提供自动多设备（例如，多个GPU）计算以及使用JAX的原生组件进行分布式计算。"

#: evox.workflows.uni_workflow.UniWorkflow:8 of
msgid ""
"Monitor is called using JAX's asynchronous host callback, thus closing "
"the monitor is needed to wait for the callback to complete."
msgstr "监视器是使用JAX的异步主机回调调用的，因此需要关闭监视器以等待回调完成。"

#: evox.workflows.uni_workflow.UniWorkflow.__init__:40 of
msgid "**jit_problem**"
msgstr "**jit_problem**"

#: evox.workflows.uni_workflow.UniWorkflow.__init__:39 of
msgid "If the problem can be jit compiled by JAX or not. Default to True."
msgstr "问题是否可以通过JAX进行jit编译。默认为True。"

#: evox.workflows.uni_workflow.UniWorkflow.__init__:44 of
msgid "**jit_monitor**"
msgstr "**jit_monitor**"

#: evox.workflows.uni_workflow.UniWorkflow.__init__:43 of
msgid "If the monitor can be jit compiled by JAX or not. Default to False."
msgstr "监视器是否可以通过JAX进行jit编译。默认为False。"

#: evox.workflows.uni_workflow.UniWorkflow.__init__:63 of
msgid "**num_objectives**"
msgstr "**num_objectives**"

#: evox.workflows.uni_workflow.UniWorkflow.__init__:47 of
msgid ""
"Number of objectives. When the problem can be jit compiled, this field is"
" not needed. When the problem cannot be jit compiled, this field should "
"be set, if not, default to 1."
msgstr "目标数量。当问题可以被 JIT（即时编译）时，这个字段不是必需的。当问题不能被 "
"JIT 编译时，应设置这个字段，如果没有设置，默认为 1。"

#: evox.workflows.uni_workflow.UniWorkflow.enable_distributed:2 of
msgid ""
"Enable the distributed workflow to run across multiple nodes. To use "
"jax's distribution ability, one need to run the same program on all nodes"
" with different parameters in `jax.distributed.initialize`."
msgstr ""
"启用分布式工作流在多个节点上运行。要使用 JAX "
"的分布式处理能力，需要在所有节点上运行相同的程序，并在 "
"jax.distributed.initialize 中使用不同的参数。"

#: evox.workflows.uni_workflow.UniWorkflow.enable_distributed:16 of
msgid "The sharded state, distributed amoung all nodes."
msgstr "分布在所有节点上的分片状态。"

#: evox.workflows.uni_workflow.UniWorkflow.enable_multi_devices:2 of
msgid "Enable the workflow to run on multiple local devices."
msgstr "允许workflow利用单台机器的多个设备（GPU）。"

#: evox.workflows.uni_workflow.UniWorkflow.enable_multi_devices:12 of
msgid "**devices**"
msgstr "**设备**"

#: evox.workflows.uni_workflow.UniWorkflow.enable_multi_devices:11 of
msgid "A list of devices. If set to None, all local devices will be used."
msgstr "设备列表。如果设置为“None”，将使用所有本地设备。"

#: evox.workflows.uni_workflow.UniWorkflow.enable_multi_devices:17 of
msgid "The sharded state, distributed amoung all devices."
msgstr "分布在所有设备上的分片状态。"

#: ../../source/example/atari_pong.ipynb:10002
msgid "Solving Pong with EvoX"
msgstr "用EvoX解决Pong问题"

#: ../../source/example/atari_pong.ipynb:10005
msgid ""
"Running this notebook requires installing evox, gymnasium, ale-py as well"
" as Pong's image. Due to copy right issues, we cannot distribute the "
"image here. Please follow the instructions [here](https://github.com"
"/Farama-Foundation/AutoROM) to install the image."
msgstr ""
"运行这个文档需要先安装 evox，gymnasium，ale-"
"py以及Pong这个游戏的镜像文件。由于版权问题，我们无法在这里给出游戏镜像文件。请按照这里[AutoROM](https://github.com"
"/Farama-Foundation/AutoROM)的教程安装游戏镜像。"

#: ../../source/example/custom_algorithm_and_problem.ipynb:10002
msgid "Custom algorithm and problem"
msgstr "自定义算法和问题"

#: ../../source/example/custom_algorithm_and_problem.ipynb:10004
msgid ""
"This this notebook, we will show how to use the `Algorithm` and `Problem`"
" classes to create a custom algorithm and problem. We will use the one-"
"max problem as an example. The one-max problem is a simple problem where "
"the goal is to maximize the number of ones in a binary string. For "
"example, the string `01011` has a fitness of 3."
msgstr ""
"在这个文档中，我们将会展示如何通过`Algorithm`和`Problem`两个类来写一个自定义的算法和问题。我们将会以one-max问题为例"
"。one-max问题是一个非常简单的问题，这个问题的目标是最大化一个由0或1组成的字符串中1的数量。比如说字符串`01011`的适应度值是3。"

#: ../../source/example/gym_classic_control.ipynb:10002
msgid "Classic control with Gym"
msgstr "基于Gym的经典控制问题"

#: ../../source/example/gym_classic_control.ipynb:10004
msgid ""
"In this notebook, we will use the Gym to train an agent that solves "
"classic control problems."
msgstr "在这个文档里，我们会借助Gym来训练一个解决经典控制问题的智能体。"

#: ../../source/example/gym_classic_control.ipynb:70002
msgid "Now run the workflow. You may see warnings like"
msgstr "现在运行workflow。你可能会看到这样的警报"

#: ../../source/example/gym_classic_control.ipynb:70007
msgid ""
"This is expected behaivor, because we have a controller thread that "
"manages a group of Gym workers, and the controller thread does not use "
"GPU."
msgstr "这是预期的行为，因为我们有一个控制器线程来管理一组Gym工作线程，而控制器线程并"
"不使用GPU。"

#: ../../source/example/gym_classic_control.ipynb:70010
msgid ""
"If the program stucks, you may want to check whether is `num_workers` is "
"larger than the number of available cores on your computer."
msgstr "如果程序卡住了，你可能需要检查 num_workers "
"设置的值是否大于你电脑上可用核心的数量。"

#: ../../source/example/index.md:1
msgid "EvoX's examples"
msgstr "EvoX的样例"

#: ../../source/example/pso_ackley.ipynb:10002
msgid "Numerical Optimization"
msgstr "数值优化"

#: ../../source/example/pso_ackley.ipynb:10004
msgid ""
"In this notebook, we will use the Particle Swarm Optimization (PSO) "
"algorithm to find the minimum of the Ackley function."
msgstr "在这个文档里，我们会使用粒子群算法来寻找Ackley测试问题的最小值。"

#: ../../source/guide/advanced/1-state.md:1
msgid "Working with state in EvoX"
msgstr "在EvoX中使用State"

#: ../../source/guide/advanced/1-state.md:3
msgid "EvoX is designed around the stateful computation."
msgstr "EvoX是基于状态计算设计的。"

#: ../../source/guide/advanced/1-state.md:5
msgid ""
"There are two most fundamental classes, namely {class}`Stateful "
"<evox.Stateful>` and {class}`State <evox.State>`."
msgstr "有两个最基本的类，即 {class}Stateful <evox.Stateful> 和 {class}State <evox."
"State>。"

#: ../../source/guide/advanced/1-state.md:7
msgid ""
"All class that involves stateful computation are inherented from "
"`Stateful`. In EvoX, `Algorithm`, `Problem`, `Operator` and workflows are"
" all stateful."
msgstr ""
"所有涉及状态计算的类都继承自 Stateful。在EvoX中，Algorithm（算法）、Problem（"
"问题）、Operator（操作符）和工作流都是有状态的。"

#: ../../source/guide/advanced/1-state.md:9
msgid "The idea behind the design"
msgstr "设计背后的想法"

#: ../../source/guide/advanced/1-state.md:11
msgid "hierarchical state"
msgstr "分层状态"

#: ../../source/guide/advanced/1-state.md:16
msgid ""
"Here we have five different objects, and notice that they have a "
"hierarchical structure. To work with such structure, at each level we "
"must \"lift the state\" by managing the states of child components. So, "
"the state at the `workflow` level must contains the state of both "
"`algorithm` and `problem`, and since the state at the `algorithm` level "
"must contains the state of both operators, the state `workflow` level "
"actual need to handle states from all 5 components."
msgstr ""
"这里我们有五个不同的对象，注意它们具有层次结构。为了处理这种结构，在每个层级"
"我们必须通过管理子组件的状态来“提升状态”。因此，workflow 层级的状态必须包含 "
"algorithm（算法）和 problem（问题）的状态，由于 algorithm "
"层级的状态必须包含所有操作符的状态，所以 workflow "
"层级的状态实际上需要处理来自所有5个组件的状态。"

#: ../../source/guide/advanced/1-state.md:22
msgid ""
"However, it is frustrating to managing the hierarchy manually, and it is "
"not good for modular design. To solve this problem, we introduce "
"`Stateful` and `State`."
msgstr "然而，手动管理这种层次结构是令人沮丧的，而且不利于模块化设计。为了解决这个问"
"题，我们引入了 Stateful 和 State。"

#: ../../source/guide/advanced/1-state.md:25
msgid "An overview of Stateful"
msgstr "关于状态的概述"

#: ../../source/guide/advanced/1-state.md:27
msgid ""
"In a `Stateful` class, all immutable data are initialized in `__init__`, "
"the initial mutable state is generated in `setup`, besides these two "
"method and private methods(start with \"\\_\"), all other methods are "
"wrapped with `use_state`."
msgstr ""
"在 Stateful 类中，所有不可变数据都在 __init__ 中初始化，初始的可变状态在 "
"setup 中生成，除了这两个方法和私有方法（以 \"_\" 开头）之外，"
"所有其他方法都用 use_state 包装。"

#: ../../source/guide/advanced/1-state.md:48
msgid ""
"will be wrapped with `use_state` decorator. This decorator requires the "
"method have the following signature:"
msgstr "将会用 use_state 装饰器包装。这个装饰器要求方法具有以下签名："

#: ../../source/guide/advanced/1-state.md:54
msgid "which is common pattern in stateful computation."
msgstr "这是状态计算中常见的模式。"

#: ../../source/guide/advanced/1-state.md:56
msgid ""
":::{warning} Currently, for all user defined private methods, the name of"
" the method should starts with `_`. :::"
msgstr ":::{警告} 目前，对于所有用户定义的私有方法，方法名称应该以 _ 开头。 :::"

#: ../../source/guide/advanced/1-state.md:60
msgid "An overview of State"
msgstr "关于状态的概述"

#: ../../source/guide/advanced/1-state.md:62
msgid ""
"In EvoX `State` represents a tree of states, which stores the state of "
"the current object and all child objects."
msgstr "在EvoX中，“State”代表一个状态树，它存储当前对象和所有子对象的状态。"

#: ../../source/guide/advanced/1-state.md:64
msgid "Combined together"
msgstr "结合一起"

#: ../../source/guide/advanced/1-state.md:66
msgid ""
"When combined together, they will automatically go 1 level down in the "
"tree of states, and merge the subtree back to current level."
msgstr "当它们组合在一起时，将自动下降到状态树的下一层，并将子树合并回当前层。"

#: ../../source/guide/advanced/1-state.md:70
msgid "So you could write code like this."
msgstr "所以你可以这样写代码。"

#: ../../source/guide/advanced/1-state.md:81
msgid ""
"Notice that, when calling the method `step`, `state` is the state of the "
"workflow, but when calling `self.algorithm.ask`, `state` behaves like the"
" state of the algorithm, and after the call, the state of the algorithm "
"is automatically merged back into the state of the workflow."
msgstr ""
"请注意，当调用 step 方法时，state 是工作流的状态，但是当调用 "
"self.algorithm.ask 时，state "
"的行为就像是算法的状态，调用之后，算法的状态会自动合并回工作流的状态。"

#: ../../source/guide/advanced/2-jit-able.md:1
msgid "Jit-able components"
msgstr "Jit-able 组件"

#: ../../source/guide/advanced/2-jit-able.md:3
msgid "A common pitfall in jit"
msgstr "jit中常见的一个陷阱"

#: ../../source/guide/advanced/2-jit-able.md:5
msgid ""
"In JAX, it's hard to jump out of a jit-compiled function, meaning if you "
"jit-compile one function, then all other functions used within this "
"function must also be jit-compiled."
msgstr ""
"在 JAX 中，跳出一个 JIT 编译的函数是困难的，这意味着如果你 JIT "
"编译了一个函数，那么在这个函数内部使用的所有其他函数也必须被 JIT 编译。"

#: ../../source/guide/advanced/2-jit-able.md:8
msgid "For example, the follow code will result in compilation error"
msgstr "例如，下面的代码将导致编译错误"

#: ../../source/guide/advanced/2-jit-able.md:19
msgid ""
"Even though `bar` is not marked with `jax.jit`, it is still compiled as "
"`foo` calls `bar`. And since bar uses dynamic index, which is not "
"compatible with `jax.jit`, an error will occur."
msgstr ""
"尽管 bar 没有被标记为 jax.jit，但由于 foo 调用了 bar，它仍然会被编译。由于 "
"bar 使用了动态索引，这与 jax.jit 不兼容，因此会发生错误。"

#: ../../source/guide/advanced/2-jit-able.md:22
msgid "Solution"
msgstr "解决方案"

#: ../../source/guide/advanced/2-jit-able.md:24
msgid ""
"To solve is problem, it is common practice to jit-compile low level "
"components, thus give high level components more freedom. In EvoX, we "
"have some general rules on whether a function should be jit-able or not."
msgstr ""
"为了解决这个问题，通常的做法是 JIT 编译低层组件，从而给高层组件更多的自由。"
"在 EvoX 中，我们有一些关于函数是否应该是可 JIT 编译的通用规则。"

#: ../../source/guide/advanced/2-jit-able.md
msgid "Component"
msgstr "组件"

#: ../../source/guide/advanced/2-jit-able.md
msgid "jit-able"
msgstr "可以被jit编译的"

#: ../../source/guide/advanced/2-jit-able.md
msgid "Workflow"
msgstr "工作流"

#: ../../source/guide/advanced/2-jit-able.md
msgid "Optional"
msgstr "可选的"

#: ../../source/guide/advanced/2-jit-able.md
msgid "Algorithm"
msgstr "算法"

#: ../../source/guide/advanced/2-jit-able.md
msgid "Yes"
msgstr "是的"

#: ../../source/guide/advanced/2-jit-able.md
msgid "Problem"
msgstr "问题"

#: ../../source/guide/advanced/2-jit-able.md
msgid "Operators"
msgstr "操作符"

#: ../../source/guide/advanced/2-jit-able.md
#: ../../source/guide/basics/1-start.ipynb:180002
msgid "Monitor"
msgstr "监控器"

#: ../../source/guide/advanced/2-jit-able.md
msgid "No"
msgstr "不是"

#: ../../source/guide/advanced/2-jit-able.md:35
msgid ""
"For standard workflow, one can jit compile when not using monitors and "
"working with jit-able problems. But even though the workflow can be "
"compiled, there isn't much performance gain. For problems, it depends on "
"the task."
msgstr ""
"对于标准工作流，当不使用监视器并且处理可 JIT 编译的问题时，可以进行 JIT "
"编译。但即使工作流可以被编译，性能提升也不大。对于问题，这取决于任务。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:7
msgid "Custom algorithms and problems in EvoX"
msgstr "EvoX中的自定义算法和问题"

#: ../../source/guide/advanced/3-custom-alg-pro.md:9
msgid ""
"In this chapter, we will introduce how to implement your own algorithm in"
" EvoX."
msgstr "在本章中，我们将介绍如何在 EvoX 中实现您自己的算法。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:11
msgid "The Algorithm Class"
msgstr "算法类"

#: ../../source/guide/advanced/3-custom-alg-pro.md:13
msgid ""
"The {class}`Algorithm <evox.Algorithm>` class is inherented from "
"{class}`Stateful <evox.Stateful>`. Besides the things in `Stateful`, your"
" should also implement a `ask` and a `tell` method. In total, there are "
"four methods one need to implement."
msgstr ""
"{class}Algorithm <evox.Algorithm> 类继承自 {class}Stateful <evox.Stateful>。"
"除了 Stateful 中的内容外，您还应该实现一个 ask 方法和一个 tell "
"方法。总共有四个方法需要实现。"

#: ../../source/guide/advanced/3-custom-alg-pro.md
#: ../../source/guide/advanced/3-custom-alg-pro.md:89
msgid "Method"
msgstr "方法"

#: ../../source/guide/advanced/3-custom-alg-pro.md
#: ../../source/guide/advanced/3-custom-alg-pro.md:89
msgid "Signature"
msgstr "签名"

#: ../../source/guide/advanced/3-custom-alg-pro.md
#: ../../source/guide/advanced/3-custom-alg-pro.md:89
msgid "Usage"
msgstr "使用情况"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "\\_\\_init\\_\\_"
msgstr "\\_\\_init\\_\\_"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "{python}`(self, ...)`"
msgstr "{python}`(self, ...)`"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid ""
"Initialize hyperparameters that are fixed though out the optimization "
"process, for example, the `population size`."
msgstr "初始化在整个优化过程中固定的超参数，例如，`population size`。"

#: ../../source/guide/advanced/3-custom-alg-pro.md
#: ../../source/guide/advanced/3-custom-alg-pro.md:93
msgid "setup"
msgstr "设置"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "{python}`(self, RRNGKey) -> State`"
msgstr "{python}`(self, RRNGKey) -> State`"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "Initialize mutable state, for example the `momentum`."
msgstr "初始化可变状态，例如`momentum`。"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "ask"
msgstr "ask"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "{python}`(self, State) -> Array, State`"
msgstr "{python}`(self, State) -> Array, State`"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "Gives a candidate population for evaluation."
msgstr "给出用于评估的候选种群。"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "tell"
msgstr "tell"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "{python}`(self, State, Array) -> State`"
msgstr "{python}`(self, State, Array) -> State`"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid ""
"Receive the fitness for the candidate population and update the "
"algorithm's state."
msgstr "接收候选种群的适应度并更新算法的状态。"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "init_ask (Optional)"
msgstr "init_ask (可选的)"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid ""
"Gives initial population for evaluation. The population can have "
"different shape than `ask`."
msgstr "提供用于评估的初始种群。种群的形状可以与`ask`不同。"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid "init_tell (Optional)"
msgstr "init_tell (可选的 )"

#: ../../source/guide/advanced/3-custom-alg-pro.md
msgid ""
"Receive the fitness for the initial population and update the algorithm's"
" state."
msgstr "接收初始种群的适应度并更新算法的状态。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:26
#: ../../source/guide/advanced/3-custom-alg-pro.md:81
msgid "Migrate from traditional EC library"
msgstr "迁移自传统的EC库"

#: ../../source/guide/advanced/3-custom-alg-pro.md:28
msgid ""
"In traditional EC library, algorithm usually calls the objective function"
" internally, which gives the following layout"
msgstr "在传统的EC库中，算法通常在内部调用目标函数，其布局如下"

#: ../../source/guide/advanced/3-custom-alg-pro.md:36
msgid "But in EvoX, we have a flat layout"
msgstr "但在 EvoX 中，我们采用了扁平布局"

#: ../../source/guide/advanced/3-custom-alg-pro.md:42
msgid "Here is a pseudocode of a genetic algorithm."
msgstr "这是一个遗传算法的伪代码。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:57
msgid "And Here is what each part of the algorithm correspond to in EvoX."
msgstr "这里是算法的每个部分在 EvoX 中对应的内容。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:77
msgid "The Problem Class"
msgstr "问题类"

#: ../../source/guide/advanced/3-custom-alg-pro.md:79
msgid ""
"The Problem class is quite simple, beside `__init__` and `setup`, the "
"only required the method is `evaluate`."
msgstr "`Problem` 类相当简单，除了 `__init__` 和 `setup`，唯一必需的方法是 "
"`evaluate`。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:83
msgid ""
"There is one thing to notice here, `evaluate` is a stateful function, "
"meaning it should accept a state and return a new state. So, if you are "
"working with numerical benchmark functions, which don't need to "
"statefule, you can simply ignore the state, but remember that you still "
"have to use this stateful interface."
msgstr ""
"这里有一点需要注意，`evaluate` 是一个有状态的函数，这意味着它应该接受一个状态"
"并返回一个新状态。所以，如果你正在处理不需要有状态的数值基准函数，你可以简单"
"地忽略状态，但请记住，你仍然需要使用这个有状态的接口。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:91
msgid "__init__"
msgstr "__init__"

#: ../../source/guide/advanced/3-custom-alg-pro.md:91
msgid ":python:`(self, ...)`"
msgstr ":python:`(self, ...)`"

#: ../../source/guide/advanced/3-custom-alg-pro.md:91
msgid "Initialize the settings of the problem."
msgstr "为问题初始化设置。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:93
msgid ":python:`(self, RRNGKey) -> State`"
msgstr ":python:`(self, RRNGKey) -> State`"

#: ../../source/guide/advanced/3-custom-alg-pro.md:93
msgid "Initialize mutable state of this problem."
msgstr "初始化这个问题的可变状态。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:95
msgid "evaluate"
msgstr "评估"

#: ../../source/guide/advanced/3-custom-alg-pro.md:95
msgid ":python:`(self, State, Array) -> Array, State`"
msgstr ":python:`(self, State, Array) -> Array, State`"

#: ../../source/guide/advanced/3-custom-alg-pro.md:95
msgid "Evaluate the fitness of the given candidate solution."
msgstr "评估给定候选解的适应度。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:99
msgid "More on the problem's state"
msgstr "关于问题的状态的更多信息"

#: ../../source/guide/advanced/3-custom-alg-pro.md:101
msgid ""
"If you still wonders what the problem's state actually do, here are the "
"explanations."
msgstr "如果您仍然想知道问题的状态实际上是做什么的，以下是解释。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:103
msgid ""
"Unlike numerical benchmark functions, real-life problems are more "
"complex, and may require stateful computations. Here are some examples:"
msgstr "与数值基准函数不同，现实生活中的问题更加复杂，可能需要有状态的计算。以下是一"
"些例子："

#: ../../source/guide/advanced/3-custom-alg-pro.md:106
msgid ""
"When dealing with ANN training, we often have training, validation and "
"testing phase. This implies that the same solution could have different "
"fitness values during different phases. So clearly, we can't model the "
"`evaluate` as a stateless pure function any more. To implement this "
"mechanism, simple put an value in the state to indicate the phase."
msgstr ""
"在处理人工神经网络(ANN)训练时，我们通常有训练、验证和测试阶段。这意味着同一个"
"解决方案在不同阶段可能有不同的适应度值。因此，显然我们不能再将`evaluate`建模"
"为一个无状态的纯函数。要实现这种机制，只需在状态中放置一个值来指示阶段。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:110
msgid ""
"Virtual batch norm is a effective trick especially when dealing with RL "
"tasks. To implement this mechanism, the problem must be stateful, as the "
"problem have to remember the initial batch norm parameters during the "
"first run."
msgstr ""
"虚拟批量归一化是一个有效的技巧，特别是在处理强化学习(RL)任务时。要实现这种机"
"制，问题必须是有状态的，因为问题需要记住第一次运行时的初始批量归一化参数。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:114
msgid "Example"
msgstr "样例"

#: ../../source/guide/advanced/3-custom-alg-pro.md:116
msgid ""
"Here we give an exmaple of implementing the OneMax problem, along with a "
"genetic algorithm that solves this problem. The problem itself is "
"straight forward, the fitness is defined as the sum of every digits in a "
"fixed-length bitstring. For example, \"100111\" gives 4 and \"000101\" "
"gives 2."
msgstr ""
"这里我们给出了一个实现 OneMax 问题的例子，以及解决这个问题的遗传算法。这个问"
"题本身很直接，适应度定义为固定长度比特串中每个数字的总和。例如，\"100111\" "
"的适应度是 4，而 \"000101\" 的适应度是 2。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:120
msgid ""
"Let's starts with implementing the OneMax problem. In JAX a bitstring can"
" be easily represented with a tensor of type bool."
msgstr "让我们从实现 OneMax 问题开始。在 JAX "
"中，比特串可以很容易地用布尔类型的张量来表示。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:145
msgid ""
"Then we implement a genetic algorithm that uses bitflip mutation and one-"
"point crossover."
msgstr "然后我们实现了一个遗传算法，使用位翻转变异和单点交叉。"

#: ../../source/guide/advanced/3-custom-alg-pro.md:205
msgid "Now, you can assemble a workflow and run it."
msgstr "现在你可以组合出一个workflow并运行。"

#: ../../source/guide/advanced/4-container.md:1
msgid "Container Algorithms"
msgstr "容器算法"

#: ../../source/guide/advanced/4-container.md:3
msgid ""
"Container algorithms are a special type of algorithms that works by "
"containing other algorithms and cannot work on its own. Container "
"algorithms can be used to compose a series of normal algorithms together."
msgstr "容器算法是一种特殊类型的算法，通过包含其他算法来工作，不能单独工作。容器算法"
"可以用来将一系列普通算法组合在一起。"

#: ../../source/guide/advanced/4-container.md:6
msgid "Working with expensive algorithms"
msgstr "处理高成本算法"

#: ../../source/guide/advanced/4-container.md:8
msgid ""
"Many algorithms are expensive in term of space or time. For example, CMA-"
"ES requires $O(N^2)$ space. Thus, it is costly to run CMA-ES on high-"
"dimension problems. Sep-CMA-ES scales better, but sacrifice the "
"performance. That's where container algorithm comes in. With it, we can "
"easily construct a variant of CMA-ES that uses $O((\\frac{N}{M})^2)$ "
"space, where $M$ is the number of block. This variant is a balance "
"between the normal CMA-ES and Sep-CMA-ES."
msgstr ""
"许多算法在空间或时间方面的成本都很高。例如，CMA-ES需要$O(N^2)$的空间。因此"
"，在高维问题上运行CMA-ES的成本很高。Sep-CMA-ES的扩展性更好，但牺牲了性能。这"
"就是容器算法的用武之地。有了它，我们可以轻松构建一个使用$O((\\frac{N}{M})^2"
")$空间的CMA-ES变体，其中$M$是块的数量。这种变体是普通CMA-ES和Sep-CMA-"
"ES之间的平衡。"

#: ../../source/guide/advanced/4-container.md:15
msgid "Working with PyTree"
msgstr "处理 PyTree"

#: ../../source/guide/advanced/4-container.md:17
msgid ""
"Usually, algorithms expect the decision variables to be in the form of a "
"1D-vector. PyTrees are tree-like structures that are not directly "
"compatible with normal algorithms. So, there are two solutions out there:"
msgstr "一般来说，算法期望决策变量以一维形式呈现。但是Pytrees是树类结构不能直接与常见"
"的算法兼容。所以这里有两种解决方法："

#: ../../source/guide/advanced/4-container.md:21
msgid "Flatten the PyTree to 1D-vector."
msgstr "将Pytree平展成一维向量。"

#: ../../source/guide/advanced/4-container.md:22
msgid "Use a specialized algorithm that work with PyTree directly."
msgstr "使用经过特殊化算法来直接处理Pytree。"

#: ../../source/guide/advanced/4-container.md:24
msgid ""
"Solution 1 is called `adapter` in EvoX, which is quite simple, but we are"
" not talking about this here. Solution 2 seems more complicated, but the "
"advantage is that the structural information is preserved, meaning the "
"algorithm could see the tree structure and apply some type of heuristic "
"here."
msgstr ""
"在EvoX中方法1被命名为adapter并且非常简单，这里不再进行赘述。方法2更为复杂，但"
"是保留原本的信息结构是他的一个优点，这意味着算法可以知道树的结构并且在此使用"
"某种类型的启发式算法。"

#: ../../source/guide/advanced/4-container.md:30
msgid ""
"We offer Cooperative Coevolution (CC) framework for all algorithms. "
"Currently, there are two types of CC container in EvoX, "
"{class}`evox.algorithms.Coevolution` and "
"{class}`evox.algorithms.VectorizedCoevolution`. The difference is that "
"`VectorizedCoevolution` update all sub-populations at the same time in "
"each iteration, but `Coevolution` follows traditional approach that "
"update a single sub-populations at each iteration. Thus "
"`VectorizedCoevolution` is faster, but `Coevolution` could be better in "
"terms of best fitness with a limited number of evaluations."
msgstr ""
"我们为所有的算法提供了合作协同进化（CC）框架。目前，再EvoX中有两种类型的CC容"
"器，分别是{class}`evox.algorithms.Coevolution` 和 {class}`evox.algorithms.Vec"
"torizedCoevolution`。两者的不同在于`VectorizedCoevolution`在每次迭代的同时更"
"新所有子代，而`Coevolution`沿用传统的方法在每迭代时更新单个子代。因此`Vectori"
"zedCoevolution` "
"更快，但是`Coevolution`在有限数量的评估下最佳适应度方案可能会更好。"

#: ../../source/guide/advanced/index.md:1
msgid "Advanced Tutorial"
msgstr "进阶教程"

#: ../../source/guide/basics/1-start.ipynb:10002
msgid "Quick Start"
msgstr "快速开始"

#: ../../source/guide/basics/1-start.ipynb:10004 ../../source/index.md:36
msgid ""
"EvoX is a distributed GPU-accelerated framework for scalable evolutionary"
" computation."
msgstr "EvoX是一个可以对大规模演化计算进行分布式GPU加速的框架。"

#: ../../source/guide/basics/1-start.ipynb:40002
msgid "Create an algorithm and a problem"
msgstr "创建一个算法和一个问题"

#: ../../source/guide/basics/1-start.ipynb:50002
msgid "To demostrate, we will create a PSO algorithm and an Ackley function."
msgstr "我们将创建一个PSO算法和一个Ackley函数来进行证明。"

#: ../../source/guide/basics/1-start.ipynb:50004
msgid ""
"For more detailed list, please refer to our API documentation. [List of "
"Algorithms](https://evox.readthedocs.io/en/latest/api/algorithms/index.html)"
" and [List of "
"Problems](https://evox.readthedocs.io/en/latest/api/problems/index.html)."
msgstr ""
"有关更详细的列表，请参阅我们的 API 文档。[算法列表](https://evox.readthedocs."
"io/en/latest/api/algorithms/index.html) 和 [问题列表](https://evox."
"readthedocs.io/en/latest/api/problems/index.html)。"

#: ../../source/guide/basics/1-start.ipynb:70002
msgid ""
"Now we want to run the algorithm against the problem. To accomplish this,"
" we need to create a `workflow` which represents the overall process of "
"evolutionary computation."
msgstr "现在我们想要运行针对问题的算法。为了实现这一点，我们需要创建一个代表进化计算"
"整体过程的`workflow`。"

#: ../../source/guide/basics/1-start.ipynb:90002
msgid ""
"Since we adopt the functional programming paradigm. We must explicitly "
"initialize and use the state of a module. To initialize, call `init` with"
" a pseudorandom number generators key (PRNGKey)."
msgstr "由于我们采用了函数式编程范式。我们必须显式地初始化并使用模块的状态。要进行初"
"始化，使用伪随机数生成器的键（PRNGKey）调用`init`。"

#: ../../source/guide/basics/1-start.ipynb:110002
msgid ""
"The `state` represents the mutatable variables within the whole workflow,"
" including those inside the algorithm and the problem. For example, the "
"`population` in an algorithm is part of the `state`, because it will be "
"changing across iterations."
msgstr ""
"`state`代表整个工作流中的可变变量，包括算法和问题内部的变量。例如，算法中的`p"
"opulation`（种群）是 state 的一部分，因为它会在迭代过程中发生变化。"

#: ../../source/guide/basics/1-start.ipynb:120002
msgid "Now, call `step` on the workflow to execute one iteration."
msgstr "现在，调用工作流上的 `step` 来执行一个迭代。"

#: ../../source/guide/basics/1-start.ipynb:140002
msgid "To run multiple iterations, wrap it inside a for-loop."
msgstr "想要执行多次迭代，只要在这外面套一个for循环即可。"

#: ../../source/guide/basics/1-start.ipynb:160002
msgid ""
"Notice that we are passing `state` as an argument of `step` and it "
"returns a new `state`. This is exactly how the stateful computation works"
" in functional programming."
msgstr ""
"请注意，我们将 `state` 作为 `step` 的一个参数传递，并且它返回一个新的 "
"`state`。这正是函数式编程中有状态计算的工作方式。"

#: ../../source/guide/basics/1-start.ipynb:170002
msgid ""
"And you may also notice that the `step` doesn't give any feedback, like "
"the result of the optimization. This is because we are missing another "
"component in our workflow. Introducing `monitor`."
msgstr ""
"你可能还会注意到，`step` "
"并没有提供任何反馈，比如优化的结果。这是因为我们的工作流中缺少另一个组件。"
"这里介绍 `monitor`（监视器）。"

#: ../../source/guide/basics/1-start.ipynb:180004
msgid ""
"Monitor is a standard way to monitor the intermediate values inside a "
"optimization process. Information like fitness or population can be "
"easily obtained by the monitor."
msgstr "监视器是监控优化过程中中间值的标准方法。像适应度或种群这样的信息可以通过监视"
"器轻松获得。"

#: ../../source/guide/basics/1-start.ipynb:190002
msgid "Now, create a \"Standard single-objective monitor\""
msgstr "现在，创建一个“标准单目标监视器”"

#: ../../source/guide/basics/1-start.ipynb:210002
msgid "The monitor can be plugged into the workflow."
msgstr "监视器可以插入到工作流中。"

#: ../../source/guide/basics/1-start.ipynb:230002
msgid "Now, re-initialize the workflow, and executed it again."
msgstr "现在，重新初始化工作流，并再次执行它。"

#: ../../source/guide/basics/1-start.ipynb:250002
msgid ""
"This time, we can access the minimum fitness achieved through the "
"`monitor`."
msgstr "这次，我们可以通过 `monitor` 访问达到的最小适应度。"

#: ../../source/guide/basics/1-start.ipynb:270002
msgid ""
"Execute another 5 iterations, and the minimum fitness will change "
"accordingly."
msgstr "再执行5次迭代，最小适应度将相应改变。"

#: ../../source/guide/basics/1-start.ipynb:290002
msgid ""
"To record information related to the population as well, turn on "
"`record_pop` option in the workflow."
msgstr "要同时记录与种群相关的信息，请在工作流中打开 `record_pop` 选项。"

#: ../../source/guide/basics/1-start.ipynb:290004
msgid ""
"This will cause the population be sent to the monitor as well, and the "
"monitor can then determine the best solution on the fly."
msgstr "这将导致种群也被发送到监视器，监视器随后可以即时确定最佳解决方案。"

#: ../../source/guide/basics/1-start.ipynb:290006
msgid ""
"Please note that when the population size is very large, is option can "
"harm the overall performance."
msgstr "请注意，当种群规模非常大时，这个选项可能会影响整体性能。"

#: ../../source/guide/basics/1-start.ipynb:330002
msgid ""
"It show the best solution is (-0.02271652, -0.19201761), which is close "
"to the global minimum at (0,0). 🥳"
msgstr "它显示最佳解为 (-0.02271652, -0.19201761)，这接近于全局最小值 (0,0)。🥳"

#: ../../source/guide/basics/1-start.ipynb:330004
msgid ""
"Additionally, please note that the best fitness remains the same as last "
"time. This is because we are using the same `key` when initializing the "
"workflow as before. This deterministic behavior in EvoX allows others to "
"easily reproduce your results."
msgstr ""
"另外，请注意最佳适应度与上次相同。"
"这是因为我们在初始化工作流程时使用了与之前相同的 "
"`key`。EvoX中的这种确定性行为使其他人可以轻松复现你的结果。"

#: ../../source/guide/basics/2-problems.ipynb:10002
msgid "Working with extended applications"
msgstr "处理扩展应用"

#: ../../source/guide/basics/2-problems.ipynb:10004
msgid "Working with extended applications in EvoX is easy."
msgstr "在EvoX中处理扩展应用很简单。"

#: ../../source/guide/basics/2-problems.ipynb:40002
#, fuzzy
msgid "Neuroevolution Tasks"
msgstr "神经演化任务"

#: ../../source/guide/basics/2-problems.ipynb:40004
msgid ""
"Here we will be focusing on neuroevolution tasks, where one need to "
"evolve a neural network that suits a certain tasks."
msgstr "在这里，我们将专注于神经进化任务，其中需要进化出适合特定任务的神经网络。"

#: ../../source/guide/basics/2-problems.ipynb:50002
msgid "Brax"
msgstr "Brax"

#: ../../source/guide/basics/2-problems.ipynb:50004
msgid ""
"To begin with we will be using Brax, a GPU accelerated physical engine "
"that is also written in JAX. Since Brax is also using JAX, running EvoX "
"with Brax is quite easy."
msgstr "首先，我们将使用Brax，这是一个用JAX编写的GPU加速物理引擎。由于Brax也使用JAX，"
"因此将EvoX与Brax一起运行相当容易。"

#: ../../source/guide/basics/2-problems.ipynb:50007
msgid "We will be demostrating using the \"swimmer\" environment in Brax."
msgstr "我们将演示在Brax中使用“swimmer”环境。"

#: ../../source/guide/basics/2-problems.ipynb:60002
msgid ""
"First we will need to decide how we are going to evolve a neural network."
" In this case, we will be using a fixed-size ANN, and only evolve it's "
"weights."
msgstr "首先，我们需要决定如何进化神经网络。在这种情况下，我们将使用固定大小的人工神"
"经网络（ANN），并仅进化其权重。"

#: ../../source/guide/basics/2-problems.ipynb:90002
msgid ""
"However, if we check the weights for this network, we will see that it's "
"group of parameter sets, and EC algorithms cannot directly work with data"
" in this format."
msgstr "然而，如果我们检查这个网络的权重，我们会发现它是一组参数集，而进化计算（EC）"
"算法无法直接处理这种格式的数据。"

#: ../../source/guide/basics/2-problems.ipynb:90005
msgid ""
"Thankfully, EvoX provides some useful utilities to help us bridge the "
"gap, and in this case, we have `TreeAndVector` to help us convert a tree-"
"like struct into a vector and back."
msgstr ""
"幸运的是，EvoX提供了一些有用的工具来帮助我们弥合这一差距，在这种情况下，我们"
"有`TreeAndVector`来帮助我们将树状结构转换成向量，然后再转换回来。"

#: ../../source/guide/basics/2-problems.ipynb:110002
msgid "Now, `adapter` can help us convert the data back-and-forth."
msgstr "现在`adapter`可以帮助我们来回转换数据格式。"

#: ../../source/guide/basics/2-problems.ipynb:110004
msgid "`to_vector` can convert a tree into a vector."
msgstr "`to_vector` 可以将树转化成向量形式。"

#: ../../source/guide/basics/2-problems.ipynb:110005
msgid "`to_tree` can convert a vector back to a tree."
msgstr "`to_tree` 可以把向量转化回树的形式。"

#: ../../source/guide/basics/2-problems.ipynb:110007
msgid "There are also batched version conversion."
msgstr "还有批量版本的转换。"

#: ../../source/guide/basics/2-problems.ipynb:110009
msgid "`batched_to_vector` can convert a batch of trees into a batch of vectors."
msgstr "`batched_to_vector`可以将一批树状结构转换为一批向量。"

#: ../../source/guide/basics/2-problems.ipynb:110010
msgid "`batched_to_tree` can convert a batch of vectors into a batch of trees."
msgstr "`batched_to_tree` 可以将一批向量转换为一批树状结构。"

#: ../../source/guide/basics/2-problems.ipynb:130002
msgid "Now we can create an algorithm object."
msgstr "现在我们可以创建一个算法对象。"

#: ../../source/guide/basics/2-problems.ipynb:150002
msgid ""
"Now create brax-based problem. The `batch_size` defines how many "
"environment in a single batch,  and `cap_episode` controls when to "
"truncate the episode."
msgstr "现在创建基于Brax的问题。`batch_size` 定义了单个批次中有多少个环境，而 "
"`cap_episode` 控制了何时截断一个情节。"

#: ../../source/guide/basics/2-problems.ipynb:150006
msgid ""
"In this case, we set `batch_size` to 4096, which is the same as our "
"population size. This means the whole population will be evaluated in a "
"single pass!"
msgstr "在这种情况下，我们将 `batch_size` "
"设置为4096，这与我们的种群大小相同。这意味着整个种群将在一次传递中被评估！"

#: ../../source/guide/basics/2-problems.ipynb:170002
msgid "Assemble our workflow and fire it!"
msgstr "组装我们的工作流程并启动它！"

#: ../../source/guide/basics/2-problems.ipynb:170004
msgid ""
"Notice the `pop_transform` option. It's used to convert the population "
"into the tree-like structure that representing a neural network's weight."
msgstr "请注意 `pop_transform` 选项。它用于将种群转换成表示神经网络权重的树状结构。"

#: ../../source/guide/basics/3-distributed.md:1
msgid "Distribute the workflow"
msgstr "分发工作流程"

#: ../../source/guide/basics/3-distributed.md:3
msgid ""
"EvoX provides two distributed workflow implementation, one is based on "
"Ray, and the other one is based on jax.distribute."
msgstr "EvoX 提供了两种分布式工作流实现，一种基于 Ray，另一种基于 jax.distribute。"

#: ../../source/guide/basics/3-distributed.md:5
msgid "RayDistributedWorkflow"
msgstr "RayDistributedWorkflow"

#: ../../source/guide/basics/3-distributed.md:7
#, fuzzy
msgid ""
"RayDistributedWorkflow is built upon Ray. It can be used on any ray "
"cluster. The Ray cluster should be setup before running the EvoX program."
msgstr "RayDistributedWorkflow是基于Ray构建的。它可以在任何Ray集群上使用。在运行EvoX"
"程序之前，应该先设置Ray集群。"

#: ../../source/guide/basics/3-distributed.md:9
#, fuzzy
msgid "Setup Ray cluster"
msgstr "设置Ray集群"

#: ../../source/guide/basics/3-distributed.md:11
#, fuzzy
msgid ""
"Please refer to [Ray's official "
"documentation](https://docs.ray.io/en/latest/cluster/getting-"
"started.html) for guide on setting up an Ray cluster."
msgstr ""
"请参考Ray的官方文档(https://docs.ray.io/en/latest/cluster/getting-started."
"html)来获取关于设置Ray集群的指南。"

#: ../../source/guide/basics/3-distributed.md:13
msgid "Here is a simple way to setup the cluster locally."
msgstr "这里有一个简单的本地集群搭建方法。"

#: ../../source/guide/basics/3-distributed.md:15
msgid "On the head node"
msgstr "在头节点上"

#: ../../source/guide/basics/3-distributed.md:19
msgid "On worker nodes"
msgstr "在工作节点上"

#: ../../source/guide/basics/3-distributed.md:24
#, fuzzy
msgid ""
"If you only have 1 machine, but multiple devices, then there is nothing "
"needs to be done. Ray will setup itself in this case."
msgstr "如果你只有一台机器但是有多个设备，这种情况下，不需要进行别的设置，Ray会自行进"
"行配置。"

#: ../../source/guide/basics/3-distributed.md:26
#: ../../source/guide/basics/3-distributed.md:72
#, fuzzy
msgid "Setup EvoX"
msgstr "设置 EvoX"

#: ../../source/guide/basics/3-distributed.md:28
msgid ""
"To scale the workflow using multiple machines through Ray, use the "
"{class}`RayDistributedWorkflow <evox.workflows.RayDistributedWorkflow>` "
"instead of StdWorkflow."
msgstr ""
"要通过Ray使用多台机器扩展工作流，请使用RayDistributedWorkflow <evox.workflows"
".RayDistributedWorkflow>类替代标准工作流StdWorkflow。"

#: ../../source/guide/basics/3-distributed.md:30
msgid "First, import `workflows` from evox"
msgstr "首先，从evox中导入'workflows'"

#: ../../source/guide/basics/3-distributed.md:36
msgid "then create your algorithm, problem, monitor object as usual."
msgstr "接下来创建algorithm，problem，monitor对象。"

#: ../../source/guide/basics/3-distributed.md:44
msgid "Now use `RayDistributedWorkflow`"
msgstr "现在使用 `RayDistributedWorkflow`"

#: ../../source/guide/basics/3-distributed.md:57
msgid ""
"The `RayDistributedWorkflow` also uses the `workflow.step` function to "
"execute iterations. However, under the hood, it employs a distinct "
"approach that allows for the utilization of multiple devices across "
"different machines."
msgstr ""
"`RayDistributedWorkflow`同样运用 `workflow.step`函数来执行迭代过程。然而，在"
"底层实现上，它采用了一种独特的方法，能够跨多台机器利用多个设备。"

#: ../../source/guide/basics/3-distributed.md:60
#, python-format
msgid ""
"It is recommanded that one set the environment variable "
"`XLA_PYTHON_CLIENT_PREALLOCATE=false`. By default JAX will pre-allocate "
"80% of the device's memory. This variable disables the GPU memory "
"preallocation, otherwise running multiple JAX processes may cause OOM. "
"For more information, please refer to [JAX's "
"documentation](https://jax.readthedocs.io/en/latest/gpu_memory_allocation.html)"
" on this matter."
msgstr ""
"建议设置环境变量XLA_PYTHON_CLIENT_PREALLOCATE=false。默认情况下，JAX会预先分"
"配设备内存的80%。此变量用于禁用GPU内存预分配，否则运行多个JAX进程可能会导致内"
"存不足（OOM）。有关此事项的更多信息，请参考JAX的文档(https://jax.readthedocs."
"io/en/latest/gpu_memory_allocation.html) 。"

#: ../../source/guide/basics/3-distributed.md:66
msgid "UniWorkflow"
msgstr "UniWorkflow"

#: ../../source/guide/basics/3-distributed.md:68
msgid ""
"UniWorkflow is short for \"Universal Workflow\", which aims to use pure "
"JAX to build a workflow that fits any requirement. Since `UniWorkflow` is"
" written in pure JAX, it has less overhead and don't need any additional "
"dependencies."
msgstr ""

#: ../../source/guide/basics/3-distributed.md:74
msgid ""
"Use `UniWorkflow` to create an workflow, and use `enable_distributed` and"
" pass in the state to enable this feature."
msgstr ""

#: ../../source/guide/basics/3-distributed.md:90
#, fuzzy
msgid ""
"Then, at the start of your program, before any JAX function is called, do"
" this:"
msgstr "在你的程序开始之前进行任何JAX函数调用，需要做这些操作："

#: ../../source/guide/basics/3-distributed.md:96
msgid ""
"In this system, the `coordinator` serves as the primary or head node. The"
" total number of participating processes is indicated by `num_process`. "
"The process with `process_id=0` acts as the coordinator."
msgstr ""

#: ../../source/guide/basics/3-distributed.md:98
msgid ""
"From more information, please refer to "
"[jax.distributed.initialize](https://jax.readthedocs.io/en/latest/_autosummary/jax.distributed.initialize.html)"
" and [Using JAX in multi-host and multi-process "
"environments](https://jax.readthedocs.io/en/latest/multi_process.html)."
msgstr ""

#: ../../source/guide/basics/3-distributed.md:100
msgid "Run in a cluster"
msgstr ""

#: ../../source/guide/basics/3-distributed.md:102
msgid ""
"Unlike Ray, JAX's doesn't have the concept of cluster or scheduler. "
"Instead, it offers tools for enabling distributed interactions among "
"multiple JAX instances. JAX follows the SPMD (single program multiple "
"data) paradigm. To initiate a distributed program in JAX, you simply need"
" to run the same script on different machines. For instance, if your "
"program is named `main.py`, you should execute the following command on "
"all participating machines with different `process_id` argument in "
"`jax.distributed.initialize`:"
msgstr ""

#: ../../source/guide/basics/3-distributed.md:110
msgid ""
"To have `process_id` in the argument, one can use `argparse` to parse the"
" argument from the commandline. For example:"
msgstr ""

#: ../../source/guide/basics/3-distributed.md:125
msgid ""
"Then call `python main.py 0` on the first machine, `python main 1` on the"
" second machine and so on."
msgstr ""

#: ../../source/guide/basics/index.md:1
msgid "Getting Started"
msgstr "开始"

#: ../../source/guide/install.md:1
msgid "Installation Guide"
msgstr "安装教程"

#: ../../source/guide/install.md:3
msgid "Install EvoX"
msgstr "安装EvoX"

#: ../../source/guide/install.md:5
msgid "EvoX is available at Pypi and can be installed via:"
msgstr "EvoX 可以在 PyPI 上找到，可以通过以下方式安装："

#: ../../source/guide/install.md:11
msgid "To install EvoX with optional dependencies:"
msgstr "要安装带有可选依赖项的 EvoX："

#: ../../source/guide/install.md:17
msgid ""
"available features are `gymnasium`, `neuroevolution`, `envpool`, "
"`distributed`, and `full` which concludes all features. For example, to "
"install EvoX with all features, do:"
msgstr ""
"EvoX 提供多种可选特性，包括 "
"`gymnasium`、`neuroevolution`、`envpool`、`distributed`和`full`（包含所有特性）。例如，要安装包含所有特性的"
" EvoX，您可以使用以下命令："

#: ../../source/guide/install.md:24
msgid "Install JAX with accelerator support"
msgstr "安装支持GPU加速的JAX"

#: ../../source/guide/install.md:26
msgid ""
"`EvoX` relies on `JAX` to provide hardware acceleration. The overall "
"architecture of these Python packages looks like this:"
msgstr "`EvoX`依赖于`JAX`来提供硬件加速的能力。这些Python包的整体架构如下："

#: ../../source/guide/install.md:43
msgid ""
"`JAX` itself is pure Python, and `jaxlib` provides the C/C++ code. To "
"utilize JAX's hardware acceleration ability, make sure to install the "
"correct `jaxlib` version."
msgstr ""
"`JAX`本身是纯 Python 库，而`jaxlib`则提供了支持加速器的 C/C++ "
"代码。要充分利用JAX的硬件加速能力，必须确保安装了正确的`jaxlib`版本。"

#: ../../source/guide/install.md:47
msgid ""
"For more information, e.g. other platforms, please check out JAX's "
"[official installation guide](https://github.com/google/jax/?tab=readme-"
"ov-file#installation)."
msgstr ""
"想要了解更多信息，比如在其他平台上安装的教程，请查阅JAX的[官方安装指南](https://github.com/google/jax/?tab"
"=readme-ov-file#installation)。"

#: ../../source/guide/install.md:50
msgid "CPU only"
msgstr "纯CPU版"

#: ../../source/guide/install.md:56
msgid "CUDA (NVIDIA GPU)"
msgstr "CUDA版 （NVIDIA GPU）"

#: ../../source/guide/install.md:58
msgid ""
"To enable CUDA acceleration, please ensure that the following components "
"are installed in a compatible manner:"
msgstr "为了能正确启用 CUDA 加速，请确保以下组件以能够兼容的方式安装："

#: ../../source/guide/install.md:85
#, fuzzy
msgid "If your using any virtualization technology, like WSL, docker."
msgstr "如果你正在使用任何虚拟化技术，例如 WSL 或 Docker。"

#: ../../source/guide/install.md:86
msgid ""
"**kernel space components**: should be installed on your host system. For"
" example, if you are using WSL with Windows, then the driver should be "
"installed on Windows, not inside WSL. If you are using container (e.g. "
"docker), then the driver should be installed on your host OS (outside "
"docker)."
msgstr ""
"**内核空间组件**：应安装在您的宿主机系统上。例如，如果您在 Windows 上使用 WSL，则应在 Windows 上安装驱动程序，而不是在 "
"WSL 内部安装。如果您使用容器（例如 Docker），则应在您的宿主机操作系统（Docker 外部）上安装驱动程序。"

#: ../../source/guide/install.md:89
msgid "**user space components**: need to be installed inside WSL or docker."
msgstr "**用户空间组件**：需要安装在 WSL 或 Docker 内部。"

#: ../../source/guide/install.md:92
msgid "Install NVIDIA's proprietary driver"
msgstr "安装 NVIDIA 的闭源驱动程序"

#: ../../source/guide/install.md:95
msgid "Windows WSL 2"
msgstr "Windows WSL 2"

#: ../../source/guide/install.md:97
msgid ""
"Download the [latest NVIDIA Windows GPU "
"Driver](https://www.nvidia.com/Download/index.aspx?lang=en-us), and "
"install it."
msgstr ""
"下载 [最新的NVIDIA Windows "
"GPU驱动](https://www.nvidia.com/Download/index.aspx?lang=en-us)，并安装."

#: ../../source/guide/install.md:100
msgid ""
"You must **NOT** install any NVIDIA GPU Linux driver within WSL 2. GPU "
"driver this a kernel space program, so it should be installed on the "
"Windows side."
msgstr ""
"请**不要**在 WSL 2 内部安装任何 NVIDIA GPU Linux 驱动程序。GPU 驱动程序属于内核空间程序，应安装在 Windows"
" 主机系统上。"

#: ../../source/guide/install.md:105
msgid ""
"NVIDIA has a detailed [CUDA on WSL User "
"Guide](https://docs.nvidia.com/cuda/wsl-user-guide/index.html)"
msgstr ""
"NVIDIA官方有一个详细的教程 [CUDA on WSL User Guide](https://docs.nvidia.com/cuda"
"/wsl-user-guide/index.html)"

#: ../../source/guide/install.md:108
msgid "GNU/Linux"
msgstr ""

#: ../../source/guide/install.md:111
msgid ""
"If you are on GNU/Linux, I strongly recommend to install the driver via "
"the package manager of your Linux distribution. Please do **NOT** install"
" the driver from NVIDIA's website."
msgstr ""
"如果您使用 GNU/Linux 系统，我强烈建议您通过您的 Linux 发行版的包管理器（比如apt，pacman）来安装驱动程序，而不是从 "
"NVIDIA 的网站下载安装包。"

#: ../../source/guide/install.md:117
msgid ""
"Only NVIDIA's proprietary driver works with CUDA, open-source drivers "
"like Nouveau do not."
msgstr "仅有NVIDIA的闭源驱动支持CUDA，像Nouveau这样的开源驱动则不支持。"

#: ../../source/guide/install.md:120
msgid ""
"The detailed installation guide depends on your operating system, for "
"example"
msgstr "具体的安装方法取决于您的操作系统，例如"

#: ../../source/guide/install.md:122 ../../source/guide/install.md:153
msgid "ArchLinux"
msgstr ""

#: ../../source/guide/install.md:126 ../../source/guide/install.md:157
msgid "Ubuntu 22.04"
msgstr ""

#: ../../source/guide/install.md:130
msgid ""
"NixOS first enable unfree software, and then add the following to your "
"configuration."
msgstr ""

#: ../../source/guide/install.md:136
msgid "After installing the driver, please reboot."
msgstr "安装完驱动后，请重启电脑。"

#: ../../source/guide/install.md:139
msgid "Cluster (e.g. slurm, k8s)"
msgstr ""

#: ../../source/guide/install.md:141
msgid ""
"If the latest driver has already been installed in the cluster, please go"
" ahead and skip this section."
msgstr ""

#: ../../source/guide/install.md:143
msgid ""
"Otherwise, please contact the administrator of the cluster to upgrade the"
" GPU driver version. It is important to note that the driver must be "
"installed on the host system, rendering any effort within the container "
"(e.g. docker, singularity) meaningless. Thus only the administrator can "
"solve this problem."
msgstr ""

#: ../../source/guide/install.md:148
msgid "Install CUDA libraries"
msgstr "安装CUDA库"

#: ../../source/guide/install.md:150
msgid ""
"CUDA libraries are user space libraries, so you don't need to reboot "
"after installation. Again, it depends on your operating system, for "
"example"
msgstr "CUDA 库是安装在用户空间的，所以在安装后您不需要重启。 具体的安装方式取决于您的操作系统，例如"

#: ../../source/guide/install.md:163
msgid "Now, you can check your do"
msgstr ""

#: ../../source/guide/install.md:167
msgid ""
"to see if your GPU is recognized by the driver. If you see something like"
" this, then you are good to go."
msgstr ""

#: ../../source/guide/install.md:191
msgid "Then check your jaxlib version by"
msgstr "之后通过其检查您的jaxlib版本"

#: ../../source/guide/install.md:197
msgid ""
"Please make sure you CUDA version is smaller or equal to the version of "
"`jaxlib-cuda`."
msgstr "请确保您的CUDA版本小于或等于`jaxlib-cuda`的版本。"

#: ../../source/guide/install.md:210
msgid ""
"For example, we have `0.4.18+cuda11.cudnn86` installed, and 11 < 12.2 "
"(displayed by `nvidia-smi`). So we are good to go."
msgstr ""

#: ../../source/guide/install.md:213
msgid ""
"Since installing `jax[cuda12]` will usually install the jaxlib compiled "
"with the latest CUDA version. Even if you have CUDA 12, your CUDA version"
" might still be lower than the version of that jaxlib requires. In this "
"case, try to install `jax[cuda11]`."
msgstr ""
"由于安装 jax[cuda12] 通常会安装到使用最新 CUDA 版本编译的 jaxlib，即使您有 CUDA 12，您的 CUDA "
"版本也可能低于 jaxlib 要求的版本（小版本号不够）。 在这种情况下，请尝试安装 jax[cuda11]。"

#: ../../source/guide/install.md:218
msgid "Verify your installation"
msgstr "验证安装是否正确"

#: ../../source/guide/install.md:220
msgid "Open a Python terminal, and run the following:"
msgstr "打开 Python 终端，并运行以下命令："

#: ../../source/guide/install.md:228
msgid "Here are some possible output:"
msgstr "这里是几种可能的输出结果："

#: ../../source/guide/install.md
msgid "Correct"
msgstr "正确"

#: ../../source/guide/install.md
msgid "EvoX not installed"
msgstr "未安装EvoX"

#: ../../source/guide/install.md
msgid "Wrong jaxlib version"
msgstr "jaxlib版本错误"

#: ../../source/guide/install.md
msgid "Wrong driver/library"
msgstr "驱动或库版本错误"

#: ../../source/index.md:4
msgid "User Guide"
msgstr "用户指引"

#: ../../source/index.md:14
msgid "API Reference"
msgstr ""

#: ../../source/index.md:26
msgid "Examples"
msgstr ""

#: ../../source/index.md:26
msgid "Additional Resources"
msgstr "补充资源"

#: ../../source/index.md:1
msgid "Welcome to EvoX's documentation!"
msgstr "欢迎来到EvoX的文档！"

#: ../../source/index.md:34
msgid ""
"[[English Version]](https://evox.readthedocs.io/en/latest/)   "
"[[中文版本]](https://evox.readthedocs.io/zh/latest/)"
msgstr ""

#: ../../source/index.md:40
msgid "Key Features"
msgstr ""

#: ../../source/index.md:42
msgid "🚀 **Fast Performance**:"
msgstr "🚀 **超高性能**："

#: ../../source/index.md:43
msgid ""
"Experience **GPU-Accelerated** optimization, achieving speeds 100x faster"
" than traditional methods."
msgstr "体验**GPU 加速**的优化，速度比传统方法快百倍以上。"

#: ../../source/index.md:44
msgid ""
"Leverage the power of {class}`Distributed Workflows "
"<evox.workflows.RayDistributedWorkflow>` for even more rapid "
"optimization."
msgstr ""

#: ../../source/index.md:46
msgid "🌐 **Versatile Optimization Suite**:"
msgstr ""

#: ../../source/index.md:47
msgid ""
"Cater to all your needs with both {doc}`Single-objective "
"<api/algorithms/so/index>` and {doc}`Multi-objective "
"<api/algorithms/mo/index>` optimization capabilities."
msgstr ""

#: ../../source/index.md:48
msgid ""
"Dive into a comprehensive library of {doc}`Benchmark Problems "
"<api/problems/numerical/index>`, ensuring robust testing and evaluation."
msgstr ""

#: ../../source/index.md:49
msgid ""
"Explore the frontier of AI with extensive tools for {doc}`Neuroevolution "
"<api/problems/neuroevolution/index>` tasks."
msgstr ""

#: ../../source/index.md:51
msgid "🛠️ **Designed for Simplicity**:"
msgstr ""

#: ../../source/index.md:52
msgid ""
"Embrace the elegance of **Functional Programming**, simplifying complex "
"algorithmic compositions."
msgstr "拥抱优雅的**函数式编程**，化繁为简，轻松构建复杂算法。"

#: ../../source/index.md:53
msgid ""
"Benefit from **Hierarchical State Management**, ensuring modular and "
"clean programming."
msgstr "得益于**层次化状态管理**，体验模块化和清爽的编程体验。"

#: ../../source/index.md:56
msgid "<br></br>"
msgstr ""

#: ../../source/index.md:63
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-desktop-download\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path d=\"M11.25 9.331V.75a.75.75 0 011.5 "
"0v8.58l1.949-2.11A.75.75 0 1115.8 8.237l-3.25 3.52a.75.75 0 01-1.102 "
"0l-3.25-3.52A.75.75 0 119.3 7.22l1.949 2.111z\"></path><path fill-"
"rule=\"evenodd\" d=\"M2.5 3.75a.25.25 0 01.25-.25h5.5a.75.75 0 "
"100-1.5h-5.5A1.75 1.75 0 001 3.75v11.5c0 .966.784 1.75 1.75 "
"1.75h6.204c-.171 1.375-.805 2.652-1.77 3.757A.75.75 0 007.75 "
"22h8.5a.75.75 0 "
"00.565-1.243c-.964-1.105-1.598-2.382-1.769-3.757h6.204A1.75 1.75 0 0023 "
"15.25V3.75A1.75 1.75 0 0021.25 2h-5.5a.75.75 0 000 1.5h5.5a.25.25 0 "
"01.25.25v11.5a.25.25 0 01-.25.25H2.75a.25.25 0 01-.25-.25V3.75zM10.463 "
"17c-.126 1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5h-3.074z\"></path></svg> "
"Installation Guide"
msgstr ""
"<path fill-rule=\"evenodd\" d=\"M3.5 8a5.5 5.5 0 118.596 4.547 9.005 "
"9.005 0 015.9 8.18.75.75 0 01-1.5.045 7.5 7.5 0 00-14.993 0 .75.75 0 "
"01-1.499-.044 9.005 9.005 0 015.9-8.181A5.494 5.494 0 013.5 8zM9 4a4 4 0 "
"100 8 4 4 0 000-8z\"><path d=\"M17.29 8c-.148 0-.292.01-.434.03a.75.75 0 "
"11-.212-1.484 4.53 4.53 0 013.38 8.097 6.69 6.69 0 013.956 6.107.75.75 0 "
"01-1.5 0 5.193 5.193 0 00-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03"
" 0 0017.29 8z\"><path fill-rule=\"evenodd\" d=\"M2.5 3.75a.25.25 0 "
"01.25-.25h5.5a.75.75 0 100-1.5h-5.5A1.75 1.75 0 001 3.75v11.5c0 .966.784 "
"1.75 1.75 1.75h6.204c-.171 1.375-.805 2.652-1.77 3.757A.75.75 0 007.75 "
"22h8.5a.75.75 0 "
"00.565-1.243c-.964-1.105-1.598-2.382-1.769-3.757h6.204A1.75 1.75 0 0023 "
"15.25V3.75A1.75 1.75 0 0021.25 2h-5.5a.75.75 0 000 1.5h5.5a.25.25 0 "
"01.25.25v11.5a.25.25 0 01-.25.25H2.75a.25.25 0 01-.25-.25V3.75zM10.463 "
"17c-.126 1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5h-3.074z\"> 安装教程"

#: ../../source/index.md:69
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"fill-rule=\"evenodd\" d=\"M3.5 8a5.5 5.5 0 118.596 4.547 9.005 9.005 0 "
"015.9 8.18.75.75 0 01-1.5.045 7.5 7.5 0 00-14.993 0 .75.75 0 "
"01-1.499-.044 9.005 9.005 0 015.9-8.181A5.494 5.494 0 013.5 8zM9 4a4 4 0 "
"100 8 4 4 0 000-8z\"></path><path d=\"M17.29 8c-.148 "
"0-.292.01-.434.03a.75.75 0 11-.212-1.484 4.53 4.53 0 013.38 8.097 6.69 "
"6.69 0 013.956 6.107.75.75 0 01-1.5 0 5.193 5.193 0 "
"00-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0017.29 "
"8z\"></path></svg> Getting Started"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"fill-rule=\"evenodd\" d=\"M3.5 8a5.5 5.5 0 118.596 4.547 9.005 9.005 0 "
"015.9 8.18.75.75 0 01-1.5.045 7.5 7.5 0 00-14.993 0 .75.75 0 "
"01-1.499-.044 9.005 9.005 0 015.9-8.181A5.494 5.494 0 013.5 8zM9 4a4 4 0 "
"100 8 4 4 0 000-8z\"></path><path d=\"M17.29 8c-.148 "
"0-.292.01-.434.03a.75.75 0 11-.212-1.484 4.53 4.53 0 013.38 8.097 6.69 "
"6.69 0 013.956 6.107.75.75 0 01-1.5 0 5.193 5.193 0 "
"00-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0017.29 "
"8z\"></path></svg> 新手教程"

#: ../../source/index.md:75
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M12.292 2.06a.75.75 0 "
"00-.584 0L.458 6.81a.75.75 0 000 1.38L4.25 9.793v3.803a2.901 2.901 0 "
"00-1.327.757c-.579.58-.923 1.41-.923 2.43v4.5c0 "
".248.128.486.335.624.06.04.117.073.22.124.124.062.297.138.52.213.448.149 "
"1.09.288 1.925.288s1.477-.14 1.925-.288c.223-.075.396-.15.52-.213a2.11 "
"2.11 0 00.21-.117A.762.762 0 008 "
"21.28v-4.5c0-1.018-.344-1.85-.923-2.428a2.9 2.9 0 "
"00-1.327-.758v-3.17l5.958 2.516a.75.75 0 00.584 0l5.208-2.2v4.003a2.552 "
"2.552 0 01-.079.085 4.057 4.057 0 01-.849.65c-.826.488-2.255 1.021-4.572 "
"1.021-.612 0-1.162-.037-1.654-.1a.75.75 0 00-.192 1.487c.56.072 1.173.113"
" 1.846.113 2.558 0 4.254-.592 5.334-1.23.538-.316.914-.64 1.163-.896a2.84"
" 2.84 0 00.392-.482h.001A.75.75 0 0019 15v-4.892l4.542-1.917a.75.75 0 "
"000-1.382l-11.25-4.75zM5 15c-.377 "
"0-.745.141-1.017.413-.265.265-.483.7-.483 1.368v4.022c.299.105.797.228 "
"1.5.228s1.201-.123 1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.431 "
"1.431 0 005 15zm7-3.564L2.678 7.5 12 3.564 21.322 7.5 12 "
"11.436z\"></path></svg> Advanced Guide"
msgstr ""

#: ../../source/index.md:85
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M4 7a1 1 0 100-2 1 1 0 "
"000 2zm4.75-1.5a.75.75 0 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0"
" 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0 000 1.5h11.5a.75.75 0 "
"000-1.5H8.75zM5 12a1 1 0 11-2 0 1 1 0 012 0zm-1 7a1 1 0 100-2 1 1 0 000 "
"2z\"></path></svg> Algorithms"
msgstr ""

#: ../../source/index.md:91
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M4 7a1 1 0 100-2 1 1 0 "
"000 2zm4.75-1.5a.75.75 0 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0"
" 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0 000 1.5h11.5a.75.75 0 "
"000-1.5H8.75zM5 12a1 1 0 11-2 0 1 1 0 012 0zm-1 7a1 1 0 100-2 1 1 0 000 "
"2z\"></path></svg> Problems"
msgstr ""

#: ../../source/index.md:98
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon "
"sd-octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-"
"hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M4 7a1 1 0 100-2 1 1 0 "
"000 2zm4.75-1.5a.75.75 0 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0"
" 000 1.5h11.5a.75.75 0 000-1.5H8.75zm0 6a.75.75 0 000 1.5h11.5a.75.75 0 "
"000-1.5H8.75zM5 12a1 1 0 11-2 0 1 1 0 012 0zm-1 7a1 1 0 100-2 1 1 0 000 "
"2z\"></path></svg> Metrics"
msgstr ""

#~ msgid "EvoX's API"
#~ msgstr "EvoX的API"

#~ msgid "**env_per_worker**"
#~ msgstr ""

#~ msgid "Number of gym environment per worker."
#~ msgstr ""

#~ msgid "**pop_size**"
#~ msgstr ""

#~ msgid ""
#~ "Population size, this argument together "
#~ "with num_workers will be used to "
#~ "determine the sharding strategy."
#~ msgstr ""

#~ msgid ""
#~ "[![Open in Colab](https://colab.research.google.com/assets"
#~ "/colab-badge.svg)](https://colab.research.google.com/github/EMI-"
#~ "Group/evox/blob/main/docs/source/guide/basics/1-start.ipynb)"
#~ msgstr ""

#~ msgid "Open in Colab"
#~ msgstr "在Colab中打开"

#~ msgid ""
#~ "[![Open in Colab](https://colab.research.google.com/assets"
#~ "/colab-badge.svg)](https://colab.research.google.com/github/EMI-"
#~ "Group/evox/blob/main/docs/source/guide/basics/2-problems.ipynb)"
#~ msgstr ""

#~ msgid "EvoX's guide!"
#~ msgstr ""

#~ msgid "API reference"
#~ msgstr ""

#~ msgid "Contents:"
#~ msgstr ""

#~ msgid "Indices and tables"
#~ msgstr ""

#~ msgid "{ref}`genindex`"
#~ msgstr ""

#~ msgid "{ref}`modindex`"
#~ msgstr ""

#~ msgid "{ref}`search`"
#~ msgstr "{ref}`search`"
